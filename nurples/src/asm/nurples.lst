PC     Output      Line
040000             0001   ; macro files generally want to go here, before any of the other includes
040000             0002   ; which call the macro, otherwise the assembler won't have the macro
040000             0003   ; available to run when it is called, and will fail with something
040000             0004   ; along the lines of 'invalid label' at such and such a line
040000             0005       include "nurples/src/asm/macros.inc"
040000             0001*  
040000             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
040000             0003*  ; Macro for loading bitmaps to VDP buffers
040000             0004*  	macro LOADBMP n,width,height,file
040000             0005*  	db 23,27,0  ; VDU 23, 27, 0 select bitmap
040000             0006*  	db n      ; specify target bitmap number (8-bits)
040000             0007*  	db 23,27,1  ; load bitmap data
040000             0008*      dw width    ; in pixels
040000             0009*      dw height   ; in pixels
040000             0010*  	incbin file ; path to file containing binary bitmap data
040000             0011*  	endmacro
040000             0012*  
040000             0013*  ; https://discord.com/channels/1158535358624039014/1158536809916149831/1208492884861653145
040000             0014*  	; load an rgba2222 bitmap to a 16-bit bufferId
040000             0015*  	macro LOADBMPBUFFER2 bufferId,width,height,file
040000             0016*  
040000             0017*      ; Clear buffer
040000             0018*      db 23,0,0xA0
040000             0019*      dw bufferId
040000             0020*      db 2
040000             0021*  
040000             0022*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0023*      dw bufferId
040000             0024*  
040000             0025*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0026*      db 23,0,0xA0
040000             0027*      dw bufferId
040000             0028*      db 0
040000             0029*  	dw width * height ; length of data in bytes
040000             0030*      incbin file ; bitmap data
040000             0031*  
040000             0032*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0033*      db 23,27,0x21
040000             0034*      dw width ; in pixels
040000             0035*      dw height ; in pixels
040000             0036*      db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040000             0037*      endmacro
040000             0038*  
040000             0039*  	; load an rgba8888 bitmap to a 16-bit bufferId
040000             0040*  	macro LOADBMPBUFFER8 bufferId,width,height,file
040000             0041*  
040000             0042*      ; Clear buffer
040000             0043*      db 23,0,0xA0
040000             0044*      dw bufferId
040000             0045*      db 2
040000             0046*  
040000             0047*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0048*      dw bufferId
040000             0049*  
040000             0050*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0051*      db 23,0,0xA0
040000             0052*      dw bufferId
040000             0053*      db 0
040000             0054*  	dw width * height * 4 ; length of data in bytes
040000             0055*      incbin file ; bitmap data
040000             0056*  
040000             0057*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0058*      db 23,27,0x21
040000             0059*      dw width ; in pixels
040000             0060*      dw height ; in pixels
040000             0061*      db 0 ; bitmap format: 0 = RGBA8888 (4-bytes per pixel)
040000             0062*      endmacro
040000             0006   
040000             0007   ;MOS INITIALIATION MUST GO HERE BEFORE ANY OTHER CODE
040000             0008       .assume adl=1
040000             0009       .org 0x040000
040000             0010   
040000 C3 45 00 04 0011       jp start
040004             0012   
040004 FF FF FF FF 0013       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0014       .db "MOS"
040043 00          0015       .db 00h
040044 01          0016       .db 01h
040045             0017   
040045             0018   start:
040045 F5          0019       push af
040046 C5          0020       push bc
040047 D5          0021       push de
040048 DD E5       0022       push ix
04004A FD E5       0023       push iy
04004C             0024   
04004C             0025   ; ###############################################
04004C             0026   ; ez80asmLinker.py loader code goes here if used.
04004C             0027   ; ###############################################
04004C             0028   
04004C             0029   ; ###############################################
04004C CD 75 6B 04 0030   	call	init			; Initialization code
040050 CD 04 6C 04 0031   	call 	main			; Call the main function
040054             0032   ; ###############################################
040054             0033   
040054             0034   exit:
040054             0035   
040054 FD E1       0036       pop iy                              ; Pop all registers back from the stack
040056 DD E1       0037       pop ix
040058 D1          0038       pop de
040059 C1          0039       pop bc
04005A F1          0040       pop af
04005B 21 00 00 00 0041       ld hl,0                             ; Load the MOS API return code (0) for no errors.
04005F             0042   
04005F C9          0043       ret                                 ; Return MOS
040060             0044   
040060             0045   ; after this we can put includes in any order we wish, even in between
040060             0046   ; code blocks if there is any program-dependent or asethetic reason to do so
040060             0047   	include "nurples/src/asm/images2.asm"
040060             0001*  ; Bitmap indices:
040060             0002*  BUF_0TILE_EMPTY: equ $0100
040060             0003*  BUF_1TILE_CROSS: equ $0101
040060             0004*  BUF_2TILE_HORIZ: equ $0102
040060             0005*  BUF_3TILE_VERT: equ $0103
040060             0006*  BUF_4TILE_SQUARE: equ $0104
040060             0007*  BUF_5TILE_CIRCLE: equ $0105
040060             0008*  BUF_6TILE_PAD: equ $0106
040060             0009*  BUF_7TILE_TURRET: equ $0107
040060             0010*  BUF_CIRCLE: equ $0108
040060             0011*  BUF_CRATER: equ $0109
040060             0012*  BUF_EXPLOSION_A: equ $010A
040060             0013*  BUF_EXPLOSION_B: equ $010B
040060             0014*  BUF_EXPLOSION_C: equ $010C
040060             0015*  BUF_EXPLOSION_D: equ $010D
040060             0016*  BUF_EXPLOSION_E: equ $010E
040060             0017*  BUF_FIREBALL_A: equ $010F
040060             0018*  BUF_FIREBALL_B: equ $0110
040060             0019*  BUF_LASER_A: equ $0111
040060             0020*  BUF_LASER_B: equ $0112
040060             0021*  BUF_PAD: equ $0113
040060             0022*  BUF_SEEKER_000: equ $0114
040060             0023*  BUF_SEEKER_001: equ $0115
040060             0024*  BUF_SEEKER_002: equ $0116
040060             0025*  BUF_SEEKER_003: equ $0117
040060             0026*  BUF_SEEKER_004: equ $0118
040060             0027*  BUF_SEEKER_005: equ $0119
040060             0028*  BUF_SEEKER_006: equ $011A
040060             0029*  BUF_SEEKER_007: equ $011B
040060             0030*  BUF_SEEKER_008: equ $011C
040060             0031*  BUF_SEEKER_009: equ $011D
040060             0032*  BUF_SEEKER_010: equ $011E
040060             0033*  BUF_SEEKER_011: equ $011F
040060             0034*  BUF_SEEKER_012: equ $0120
040060             0035*  BUF_SEEKER_013: equ $0121
040060             0036*  BUF_SEEKER_014: equ $0122
040060             0037*  BUF_SEEKER_015: equ $0123
040060             0038*  BUF_SEEKER_016: equ $0124
040060             0039*  BUF_SEEKER_017: equ $0125
040060             0040*  BUF_SEEKER_018: equ $0126
040060             0041*  BUF_SEEKER_019: equ $0127
040060             0042*  BUF_SEEKER_020: equ $0128
040060             0043*  BUF_SEEKER_021: equ $0129
040060             0044*  BUF_SEEKER_022: equ $012A
040060             0045*  BUF_SEEKER_023: equ $012B
040060             0046*  BUF_SEEKER_024: equ $012C
040060             0047*  BUF_SEEKER_025: equ $012D
040060             0048*  BUF_SEEKER_026: equ $012E
040060             0049*  BUF_SEEKER_027: equ $012F
040060             0050*  BUF_SEEKER_028: equ $0130
040060             0051*  BUF_SEEKER_029: equ $0131
040060             0052*  BUF_SEEKER_030: equ $0132
040060             0053*  BUF_SEEKER_031: equ $0133
040060             0054*  BUF_SHIP_0L: equ $0134
040060             0055*  BUF_SHIP_1C: equ $0135
040060             0056*  BUF_SHIP_2R: equ $0136
040060             0057*  BUF_SHIP_SMALL: equ $0137
040060             0058*  BUF_STAR: equ $0138
040060             0059*  BUF_TURRET: equ $0139
040060             0060*  BUF_TURRET_ROT: equ $013A
040060             0061*  
040060             0062*  ; import .rgba bitmap files and load them into VDP buffers
040060             0063*  bmp2_init:
040060 21 6B 00 04 0064*  	ld hl, @cmd
040064 01 76 3C 00 0065*  	ld bc, @end-@cmd
040068 5B DF       0066*  	rst.lil $18
04006A C9          0067*  	ret
04006B             0068*  @cmd:
04006B             0069*  	LOADBMPBUFFER2 BUF_0TILE_EMPTY,16,16,"nurples/src/rgba2/0tile_empty.rgba2"
04006B             0001*M 
04006B             0002*M     ; Clear buffer
04006B 17 00 A0    0003*M     db 23,0,0xA0
04006E 00 01       0004*M     dw bufferId
040070 02          0005*M     db 2
040071             0006*M 
040071 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040074 00 01       0008*M     dw bufferId
040076             0009*M 
040076             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040076 17 00 A0    0011*M     db 23,0,0xA0
040079 00 01       0012*M     dw bufferId
04007B 00          0013*M     db 0
04007C 00 01       0014*M 	dw width * height ; length of data in bytes
04007E 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04017E             0016*M 
04017E             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04017E 17 1B 21    0018*M     db 23,27,0x21
040181 10 00       0019*M     dw width ; in pixels
040183 10 00       0020*M     dw height ; in pixels
040185 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040186             0070*  	LOADBMPBUFFER2 BUF_1TILE_CROSS,16,16,"nurples/src/rgba2/1tile_cross.rgba2"
040186             0001*M 
040186             0002*M     ; Clear buffer
040186 17 00 A0    0003*M     db 23,0,0xA0
040189 01 01       0004*M     dw bufferId
04018B 02          0005*M     db 2
04018C             0006*M 
04018C 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04018F 01 01       0008*M     dw bufferId
040191             0009*M 
040191             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040191 17 00 A0    0011*M     db 23,0,0xA0
040194 01 01       0012*M     dw bufferId
040196 00          0013*M     db 0
040197 00 01       0014*M 	dw width * height ; length of data in bytes
040199 00 00 D0 F5 0015*M     incbin file ; bitmap data
       FA FF FF FF 
       FF FF FF EA 
       F5 D0 00 00 
       00 00 D0 F5 
       FA EA FF FF 
       FF FF EA EA 
       F5 D0 00 00 
       D0 D0 D0 F5 
       FA FF FF FF 
       FF FF EA EA 
       F5 D0 D0 D0 
       F5 F5 F5 F5 
       FB FA EA EA 
       EA EA EA E5 
       F5 F5 F5 F5 
       D1 E5 E5 D0 
       FA FB E5 FA 
       FA FA FA FA 
       C0 D0 D0 D0 
       E1 E1 D0 D0 
       FA D1 D0 D1 
       D0 D0 D0 EA 
       D1 D1 D1 D1 
       FA FF E5 E5 
       E5 D0 F8 FD 
       FE F8 D0 E5 
       D1 E5 E5 E5 
       FA FF FA E5 
       E5 D0 F8 FD 
       FE F8 D0 FA 
       E5 E5 E5 E5 
       E5 FB FA E5 
       E5 D0 F8 FD 
       FE F8 E1 FA 
       E5 E5 E5 E5 
       FA FA FA E5 
       E5 D0 F8 FD 
       FD F8 D0 FA 
       E5 E5 E5 E5 
       E5 E5 E5 E5 
       E5 D0 F8 F8 
       F8 F8 D0 FA 
       D1 D1 D1 D1 
       E1 E1 E1 E1 
       D1 D0 D0 D0 
       D0 D0 D0 E5 
       D0 D1 D0 D0 
       F5 F5 F5 F5 
       E5 D1 E1 E5 
       E5 E5 E5 E5 
       F5 F5 F5 F5 
       D0 D0 D0 F5 
       E5 E5 E5 E5 
       E6 E5 E5 E5 
       F5 D0 D0 D0 
       00 00 D0 F5 
       E5 E6 D6 E6 
       D7 E6 E6 E5 
       F5 D0 00 00 
       00 00 D0 F5 
       E5 E6 E6 D6 
       D6 D6 E6 E5 
       F5 D0 00 00 
040299             0016*M 
040299             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040299 17 1B 21    0018*M     db 23,27,0x21
04029C 10 00       0019*M     dw width ; in pixels
04029E 10 00       0020*M     dw height ; in pixels
0402A0 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0402A1             0071*  	LOADBMPBUFFER2 BUF_2TILE_HORIZ,16,16,"nurples/src/rgba2/2tile_horiz.rgba2"
0402A1             0001*M 
0402A1             0002*M     ; Clear buffer
0402A1 17 00 A0    0003*M     db 23,0,0xA0
0402A4 02 01       0004*M     dw bufferId
0402A6 02          0005*M     db 2
0402A7             0006*M 
0402A7 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0402AA 02 01       0008*M     dw bufferId
0402AC             0009*M 
0402AC             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0402AC 17 00 A0    0011*M     db 23,0,0xA0
0402AF 02 01       0012*M     dw bufferId
0402B1 00          0013*M     db 0
0402B2 00 01       0014*M 	dw width * height ; length of data in bytes
0402B4 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       EA EA EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA FF F8 
       F8 F8 F8 EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA FF FF 
       EA EA FA FA 
       F8 F8 EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA FA E5 
       F8 F8 EA EA 
       D0 E6 E6 D1 
       D1 D1 D1 EA 
       EA F8 F5 F5 
       EA F8 EA D0 
       C0 D1 D1 D1 
       D1 D2 D1 D0 
       D0 EA F5 E5 
       EA EA F8 E5 
       E5 E6 E6 E6 
       E6 E6 D1 F8 
       E5 EA E5 E5 
       EA E5 D1 D1 
       D1 D1 D1 D1 
       D1 D1 C0 D1 
       EA D1 EA D0 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0403B4             0016*M 
0403B4             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0403B4 17 1B 21    0018*M     db 23,27,0x21
0403B7 10 00       0019*M     dw width ; in pixels
0403B9 10 00       0020*M     dw height ; in pixels
0403BB 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0403BC             0072*  	LOADBMPBUFFER2 BUF_3TILE_VERT,16,16,"nurples/src/rgba2/3tile_vert.rgba2"
0403BC             0001*M 
0403BC             0002*M     ; Clear buffer
0403BC 17 00 A0    0003*M     db 23,0,0xA0
0403BF 03 01       0004*M     dw bufferId
0403C1 02          0005*M     db 2
0403C2             0006*M 
0403C2 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0403C5 03 01       0008*M     dw bufferId
0403C7             0009*M 
0403C7             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0403C7 17 00 A0    0011*M     db 23,0,0xA0
0403CA 03 01       0012*M     dw bufferId
0403CC 00          0013*M     db 0
0403CD 00 01       0014*M 	dw width * height ; length of data in bytes
0403CF 00 00 D0 F5 0015*M     incbin file ; bitmap data
       D0 D0 D0 D0 
       E5 E5 EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 E5 E5 
       E5 F8 EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 D0 E5 E5 
       FA F8 FD F8 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 D0 E1 E5 
       E5 E5 FA F8 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 D0 D0 D1 
       E6 E6 FA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       C0 D1 D1 D1 
       FB EA FB D1 
       F5 D0 00 00 
       00 00 D0 F5 
       C0 D0 EA C0 
       EA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 EA EA 
       EA FF EA FF 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E1 EA EA 
       EA FF EA FF 
       F5 D0 00 00 
       00 00 D0 F5 
       C0 D0 C0 EA 
       EA EA EA FF 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 EA EA 
       EA EA EA FF 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 EA EA 
       EA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 EA EA 
       EA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 F8 F8 
       FA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       EA EA F8 F8 
       EA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       C0 E5 F8 F8 
       EA EA EA EA 
       F5 D0 00 00 
0404CF             0016*M 
0404CF             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0404CF 17 1B 21    0018*M     db 23,27,0x21
0404D2 10 00       0019*M     dw width ; in pixels
0404D4 10 00       0020*M     dw height ; in pixels
0404D6 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0404D7             0073*  	LOADBMPBUFFER2 BUF_4TILE_SQUARE,16,16,"nurples/src/rgba2/4tile_square.rgba2"
0404D7             0001*M 
0404D7             0002*M     ; Clear buffer
0404D7 17 00 A0    0003*M     db 23,0,0xA0
0404DA 04 01       0004*M     dw bufferId
0404DC 02          0005*M     db 2
0404DD             0006*M 
0404DD 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0404E0 04 01       0008*M     dw bufferId
0404E2             0009*M 
0404E2             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0404E2 17 00 A0    0011*M     db 23,0,0xA0
0404E5 04 01       0012*M     dw bufferId
0404E7 00          0013*M     db 0
0404E8 00 01       0014*M 	dw width * height ; length of data in bytes
0404EA D0 D1 E5 D1 0015*M     incbin file ; bitmap data
       E5 E5 D0 D5 
       D0 D0 D0 D0 
       D0 D5 D0 D1 
       D5 EA EA EA 
       EA E5 E5 E5 
       E5 E5 E5 D5 
       D1 FF E9 D5 
       D0 EA EA D5 
       D5 D5 D1 D5 
       D4 D4 FE FE 
       D1 EA E5 D5 
       D0 C0 D1 D1 
       D2 D2 E6 E9 
       FE FE FE FE 
       C0 C0 C0 D1 
       D0 D1 D1 D2 
       D2 D2 E6 D4 
       E9 E9 FE FE 
       D1 D0 D0 D0 
       D0 D1 D2 D2 
       D2 D2 D5 C0 
       D1 D1 D4 E9 
       D1 C0 E5 D0 
       D0 D1 C0 D5 
       D5 D5 E6 E6 
       E6 E6 D1 E5 
       E5 C0 E5 E5 
       D0 D1 D1 E9 
       FE D5 D1 D2 
       D2 D1 D1 E9 
       E9 C0 D1 D0 
       E5 D1 C0 D0 
       E5 D0 D1 D2 
       D2 D1 D1 E5 
       E5 C0 EA D0 
       E5 E5 C0 C0 
       D5 C1 D5 D1 
       D1 C1 D1 D0 
       D4 D5 EA D0 
       E5 E5 D5 D2 
       D2 D2 D0 D0 
       D5 D5 D5 E9 
       E9 C0 EA E5 
       E5 E5 D5 D2 
       D2 D2 EA E9 
       FA FA D4 E6 
       E5 D5 E5 D1 
       D0 EA D5 D2 
       D1 C1 D5 E5 
       E9 E9 D0 E5 
       D0 E5 E5 E5 
       D0 D4 E9 D4 
       C0 C0 D5 C0 
       D0 D0 C0 D0 
       D0 EA EA D0 
       D0 D4 D4 D5 
       C0 D0 D5 C0 
       C0 C0 D0 C0 
       D0 D0 D0 D0 
       D0 D0 D0 C0 
       C0 D0 D0 D0 
       D5 D0 D0 C0 
       D0 D5 D0 D0 
0405EA             0016*M 
0405EA             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0405EA 17 1B 21    0018*M     db 23,27,0x21
0405ED 10 00       0019*M     dw width ; in pixels
0405EF 10 00       0020*M     dw height ; in pixels
0405F1 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0405F2             0074*  	LOADBMPBUFFER2 BUF_5TILE_CIRCLE,16,16,"nurples/src/rgba2/5tile_circle.rgba2"
0405F2             0001*M 
0405F2             0002*M     ; Clear buffer
0405F2 17 00 A0    0003*M     db 23,0,0xA0
0405F5 05 01       0004*M     dw bufferId
0405F7 02          0005*M     db 2
0405F8             0006*M 
0405F8 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0405FB 05 01       0008*M     dw bufferId
0405FD             0009*M 
0405FD             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0405FD 17 00 A0    0011*M     db 23,0,0xA0
040600 05 01       0012*M     dw bufferId
040602 00          0013*M     db 0
040603 00 01       0014*M 	dw width * height ; length of data in bytes
040605 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 D0 D0 D1 
       EA D1 D1 D0 
       D0 00 00 00 
       00 00 D0 D0 
       D0 D1 D1 EA 
       FB EA D1 D1 
       D0 D0 00 00 
       00 D0 D0 D1 
       D1 D0 D0 D1 
       D1 EA D1 E5 
       EA D0 D0 00 
       00 D0 E1 D1 
       D0 D0 CA EA 
       EA D7 EA E6 
       D1 D1 D0 00 
       D0 D1 E1 FA 
       D1 CA EF FF 
       FF EF D7 D0 
       D1 D1 D1 D0 
       D0 D0 D0 E5 
       FB EA EF FF 
       FF EF EA D0 
       E5 D0 D0 D0 
       D0 E1 D0 EA 
       EA EF EF EF 
       EF EF EA E5 
       EA D0 D0 D0 
       D0 D0 D0 D1 
       EA F8 EA EA 
       EA EA F8 D0 
       EA D0 D1 D0 
       D0 D0 D1 D1 
       E5 EA F8 F8 
       F8 F8 E5 E1 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D1 E5 E5 E1 
       E1 E1 E1 D0 
       D0 D1 D0 D0 
       00 D0 D0 D0 
       D0 D0 C0 D0 
       D0 C0 D0 D0 
       D0 C0 D0 00 
       00 D0 D0 D0 
       C0 C0 EA E6 
       E6 D1 C0 C0 
       D0 D0 D0 00 
       00 00 D0 D0 
       C0 D1 D1 D1 
       D1 D1 D1 D0 
       D0 D0 00 00 
       00 00 00 D0 
       D0 D1 D1 D1 
       D1 D1 D1 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
040705             0016*M 
040705             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040705 17 1B 21    0018*M     db 23,27,0x21
040708 10 00       0019*M     dw width ; in pixels
04070A 10 00       0020*M     dw height ; in pixels
04070C 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04070D             0075*  	LOADBMPBUFFER2 BUF_6TILE_PAD,16,16,"nurples/src/rgba2/6tile_pad.rgba2"
04070D             0001*M 
04070D             0002*M     ; Clear buffer
04070D 17 00 A0    0003*M     db 23,0,0xA0
040710 06 01       0004*M     dw bufferId
040712 02          0005*M     db 2
040713             0006*M 
040713 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040716 06 01       0008*M     dw bufferId
040718             0009*M 
040718             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040718 17 00 A0    0011*M     db 23,0,0xA0
04071B 06 01       0012*M     dw bufferId
04071D 00          0013*M     db 0
04071E 00 01       0014*M 	dw width * height ; length of data in bytes
040720 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
       00 C3 C3 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 C3 C3 00 
       00 C3 C3 D0 
       F5 F5 D0 D0 
       D0 D0 F5 F5 
       D0 C3 C3 00 
       00 D0 D0 F5 
       FA FA D0 DF 
       DF D0 FA FA 
       F5 D0 D0 00 
       00 D0 F5 FA 
       D9 D9 D0 D0 
       D0 D0 D9 D9 
       FA F5 D0 00 
       D0 F5 F5 FA 
       D9 D9 D0 DF 
       DF D0 D9 D9 
       FA F5 F5 D0 
       D0 F5 D0 D0 
       D0 D0 D0 DF 
       DF D0 D0 D0 
       D0 D0 F5 D0 
       DF DF D0 DF 
       D0 DF DF D0 
       D0 DF DF D0 
       DF D0 DF DF 
       DF DF D0 DF 
       D0 DF DF D0 
       D0 DF DF D0 
       DF D0 DF DF 
       D0 F5 D0 D0 
       D0 D0 D0 DF 
       DF D0 D0 D0 
       D0 D0 F5 D0 
       D0 F5 F5 FA 
       D9 D9 D0 DF 
       DF D0 D9 D9 
       FA F5 F5 D0 
       00 D0 F5 FA 
       D9 D9 D0 D0 
       D0 D0 D9 D9 
       FA F5 D0 00 
       00 D0 D0 F5 
       FA FA D0 DF 
       DF D0 FA FA 
       F5 D0 D0 00 
       00 C3 C3 D0 
       F5 F5 D0 D0 
       D0 D0 F5 F5 
       D0 C3 C3 00 
       00 C3 C3 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 C3 C3 00 
       00 00 00 00 
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
040820             0016*M 
040820             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040820 17 1B 21    0018*M     db 23,27,0x21
040823 10 00       0019*M     dw width ; in pixels
040825 10 00       0020*M     dw height ; in pixels
040827 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040828             0076*  	LOADBMPBUFFER2 BUF_7TILE_TURRET,16,16,"nurples/src/rgba2/7tile_turret.rgba2"
040828             0001*M 
040828             0002*M     ; Clear buffer
040828 17 00 A0    0003*M     db 23,0,0xA0
04082B 07 01       0004*M     dw bufferId
04082D 02          0005*M     db 2
04082E             0006*M 
04082E 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040831 07 01       0008*M     dw bufferId
040833             0009*M 
040833             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040833 17 00 A0    0011*M     db 23,0,0xA0
040836 07 01       0012*M     dw bufferId
040838 00          0013*M     db 0
040839 00 01       0014*M 	dw width * height ; length of data in bytes
04083B 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 00 00 00 
       00 00 D0 F5 
       F5 F5 C3 C3 
       C3 C3 F5 F5 
       F5 D0 00 00 
       00 D0 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       F5 C3 C3 C3 
       C3 C3 C3 F5 
       F5 F5 D0 00 
       D0 F5 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       C3 C3 C3 C3 
       C3 C3 C3 C3 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 D0 DF 
       DF D0 D0 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 C3 DF 
       DF C3 D0 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 C3 DF 
       DF C3 D0 F5 
       F5 F5 F5 D0 
       00 D0 F5 F5 
       F5 D0 D0 E5 
       E5 D0 D0 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       D0 D0 E5 FA 
       FA E5 D0 D0 
       F5 F5 D0 00 
       00 00 D0 F5 
       D0 E5 FA FA 
       FA FA E5 D0 
       F5 D0 00 00 
       00 00 00 D0 
       D0 D0 E5 FA 
       FA E5 D0 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
04093B             0016*M 
04093B             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04093B 17 1B 21    0018*M     db 23,27,0x21
04093E 10 00       0019*M     dw width ; in pixels
040940 10 00       0020*M     dw height ; in pixels
040942 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040943             0077*  	LOADBMPBUFFER2 BUF_CIRCLE,16,16,"nurples/src/rgba2/circle.rgba2"
040943             0001*M 
040943             0002*M     ; Clear buffer
040943 17 00 A0    0003*M     db 23,0,0xA0
040946 08 01       0004*M     dw bufferId
040948 02          0005*M     db 2
040949             0006*M 
040949 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04094C 08 01       0008*M     dw bufferId
04094E             0009*M 
04094E             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04094E 17 00 A0    0011*M     db 23,0,0xA0
040951 08 01       0012*M     dw bufferId
040953 00          0013*M     db 0
040954 00 01       0014*M 	dw width * height ; length of data in bytes
040956 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 F5 F5 F5 
       F5 F5 F5 D0 
       D0 00 00 00 
       00 00 D0 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 D0 00 00 
       00 D0 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       00 D0 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       00 00 D0 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 D0 00 00 
       00 00 00 D0 
       D0 F5 F5 F5 
       F5 F5 F5 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
040A56             0016*M 
040A56             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040A56 17 1B 21    0018*M     db 23,27,0x21
040A59 10 00       0019*M     dw width ; in pixels
040A5B 10 00       0020*M     dw height ; in pixels
040A5D 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040A5E             0078*  	LOADBMPBUFFER2 BUF_CRATER,16,16,"nurples/src/rgba2/crater.rgba2"
040A5E             0001*M 
040A5E             0002*M     ; Clear buffer
040A5E 17 00 A0    0003*M     db 23,0,0xA0
040A61 09 01       0004*M     dw bufferId
040A63 02          0005*M     db 2
040A64             0006*M 
040A64 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040A67 09 01       0008*M     dw bufferId
040A69             0009*M 
040A69             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040A69 17 00 A0    0011*M     db 23,0,0xA0
040A6C 09 01       0012*M     dw bufferId
040A6E 00          0013*M     db 0
040A6F 00 01       0014*M 	dw width * height ; length of data in bytes
040A71 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E2 C0 F2 
       C0 D1 E2 00 
       00 00 00 00 
       00 00 D2 D5 
       C0 D2 C0 C6 
       D1 C6 D1 C1 
       C0 E2 00 00 
       00 F2 EA D5 
       DF C0 D1 D2 
       DF D2 D1 C1 
       C0 EA C0 00 
       00 F2 D5 C0 
       C0 C0 CB D1 
       D6 DF D5 C0 
       C0 C0 D5 00 
       F2 D5 C0 C6 
       C0 CB D1 D6 
       D6 D7 D6 C0 
       D5 C1 C0 C0 
       D5 C0 C0 D5 
       C1 D1 C1 D6 
       C2 D7 C2 C1 
       C0 CB C1 C1 
       C1 C6 C0 C1 
       DF C2 D6 D7 
       D7 DB D6 CB 
       C1 D6 D6 D5 
       C0 C0 C0 D5 
       F7 D6 D7 DB 
       EB EF D7 D6 
       D6 CB C1 C1 
       C1 D6 C0 C1 
       D6 EB EB FF 
       CB FF FF EB 
       D6 C1 C1 D5 
       EA D5 C0 DF 
       C2 EA EA FF 
       FF FF EA C0 
       D6 D2 D5 C0 
       00 FA C2 D5 
       D5 C1 C0 CB 
       EA C0 D6 C1 
       C1 D5 E2 00 
       00 F2 FA C1 
       D5 D6 D5 C2 
       C0 D2 D2 D5 
       D6 C1 D5 00 
       00 00 FA F2 
       EB D6 C0 C0 
       C1 D5 D6 D6 
       EA D5 00 00 
       00 00 00 00 
       00 FA F6 F2 
       FA F6 F6 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B71             0016*M 
040B71             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040B71 17 1B 21    0018*M     db 23,27,0x21
040B74 10 00       0019*M     dw width ; in pixels
040B76 10 00       0020*M     dw height ; in pixels
040B78 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040B79             0079*  	LOADBMPBUFFER2 BUF_EXPLOSION_A,16,16,"nurples/src/rgba2/explosion_a.rgba2"
040B79             0001*M 
040B79             0002*M     ; Clear buffer
040B79 17 00 A0    0003*M     db 23,0,0xA0
040B7C 0A 01       0004*M     dw bufferId
040B7E 02          0005*M     db 2
040B7F             0006*M 
040B7F 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040B82 0A 01       0008*M     dw bufferId
040B84             0009*M 
040B84             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040B84 17 00 A0    0011*M     db 23,0,0xA0
040B87 0A 01       0012*M     dw bufferId
040B89 00          0013*M     db 0
040B8A 00 01       0014*M 	dw width * height ; length of data in bytes
040B8C 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 C7 
       C7 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 C7 
       EF C7 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 EF 
       EF EF C7 00 
       00 00 00 00 
       00 00 00 C7 
       C7 00 C7 C7 
       EF C7 C7 00 
       00 00 00 00 
       00 00 00 C7 
       C7 00 00 C7 
       C7 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040C8C             0016*M 
040C8C             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040C8C 17 1B 21    0018*M     db 23,27,0x21
040C8F 10 00       0019*M     dw width ; in pixels
040C91 10 00       0020*M     dw height ; in pixels
040C93 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040C94             0080*  	LOADBMPBUFFER2 BUF_EXPLOSION_B,16,16,"nurples/src/rgba2/explosion_b.rgba2"
040C94             0001*M 
040C94             0002*M     ; Clear buffer
040C94 17 00 A0    0003*M     db 23,0,0xA0
040C97 0B 01       0004*M     dw bufferId
040C99 02          0005*M     db 2
040C9A             0006*M 
040C9A 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040C9D 0B 01       0008*M     dw bufferId
040C9F             0009*M 
040C9F             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040C9F 17 00 A0    0011*M     db 23,0,0xA0
040CA2 0B 01       0012*M     dw bufferId
040CA4 00          0013*M     db 0
040CA5 00 01       0014*M 	dw width * height ; length of data in bytes
040CA7 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 C7 C7 00 
       00 00 00 00 
       00 00 00 C7 
       C7 C7 00 00 
       00 C7 C7 00 
       00 00 00 00 
       00 C7 C7 EF 
       EF EF C7 C7 
       00 00 00 00 
       00 00 00 00 
       00 C7 EF EF 
       EF EF EF C7 
       00 00 00 00 
       00 00 00 00 
       C7 EF EF EF 
       EF EF EF EF 
       C7 00 00 00 
       00 00 00 C7 
       C7 EF EF EF 
       EF EF EF EF 
       C7 00 00 00 
       00 00 C7 C7 
       C7 C7 EF EF 
       EF EF EF EF 
       C7 00 00 00 
       00 00 C7 C7 
       C7 C7 EF EF 
       EF EF EF C7 
       00 00 00 00 
       00 00 00 C7 
       C7 C7 C7 EF 
       EF EF C7 C7 
       00 00 00 00 
       00 00 00 00 
       00 00 00 C7 
       C7 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040DA7             0016*M 
040DA7             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040DA7 17 1B 21    0018*M     db 23,27,0x21
040DAA 10 00       0019*M     dw width ; in pixels
040DAC 10 00       0020*M     dw height ; in pixels
040DAE 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040DAF             0081*  	LOADBMPBUFFER2 BUF_EXPLOSION_C,16,16,"nurples/src/rgba2/explosion_c.rgba2"
040DAF             0001*M 
040DAF             0002*M     ; Clear buffer
040DAF 17 00 A0    0003*M     db 23,0,0xA0
040DB2 0C 01       0004*M     dw bufferId
040DB4 02          0005*M     db 2
040DB5             0006*M 
040DB5 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040DB8 0C 01       0008*M     dw bufferId
040DBA             0009*M 
040DBA             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040DBA 17 00 A0    0011*M     db 23,0,0xA0
040DBD 0C 01       0012*M     dw bufferId
040DBF 00          0013*M     db 0
040DC0 00 01       0014*M 	dw width * height ; length of data in bytes
040DC2 00 C7 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       C6 C6 00 00 
       00 00 00 00 
       00 00 C7 C7 
       C7 C7 00 C6 
       C7 C7 C6 00 
       00 00 00 00 
       C7 C7 EF EF 
       EF EF C7 C6 
       C7 C7 C6 00 
       00 00 00 C7 
       EF EF EF EF 
       EF EF EF EF 
       C6 C6 00 00 
       00 00 00 C7 
       EF EF EF EF 
       EF EF EF EF 
       C7 00 00 00 
       00 00 C7 EF 
       EF EF EF EF 
       EF EF EF EF 
       EF C7 00 00 
       00 C6 C6 C6 
       C6 EF EF EF 
       EF EF EF EF 
       EF C7 00 00 
       C6 C6 C7 C7 
       C6 C6 EF EF 
       EF EF EF EF 
       EF C7 00 00 
       C6 C7 C7 EF 
       C7 C6 EF EF 
       EF EF EF EF 
       EF C7 00 00 
       C6 C7 00 C7 
       C7 C6 EF EF 
       EF EF EF EF 
       C7 00 00 00 
       C6 C6 C7 C7 
       C6 C6 EF EF 
       EF EF EF EF 
       C7 00 00 00 
       00 C6 C6 C6 
       C6 C7 EF EF 
       EF EF C7 C7 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 C7 
       C7 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040EC2             0016*M 
040EC2             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040EC2 17 1B 21    0018*M     db 23,27,0x21
040EC5 10 00       0019*M     dw width ; in pixels
040EC7 10 00       0020*M     dw height ; in pixels
040EC9 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040ECA             0082*  	LOADBMPBUFFER2 BUF_EXPLOSION_D,16,16,"nurples/src/rgba2/explosion_d.rgba2"
040ECA             0001*M 
040ECA             0002*M     ; Clear buffer
040ECA 17 00 A0    0003*M     db 23,0,0xA0
040ECD 0D 01       0004*M     dw bufferId
040ECF 02          0005*M     db 2
040ED0             0006*M 
040ED0 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040ED3 0D 01       0008*M     dw bufferId
040ED5             0009*M 
040ED5             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040ED5 17 00 A0    0011*M     db 23,0,0xA0
040ED8 0D 01       0012*M     dw bufferId
040EDA 00          0013*M     db 0
040EDB 00 01       0014*M 	dw width * height ; length of data in bytes
040EDD 00 C7 C7 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 C6 00 00 
       00 C7 C7 00 
       00 00 C6 C6 
       C6 C6 00 C6 
       00 00 00 00 
       00 00 00 00 
       C6 C6 C7 C7 
       C7 C7 C6 C6 
       C6 C6 00 00 
       00 00 00 C6 
       C7 C7 EF EF 
       EF EF EF EF 
       C6 C6 00 C6 
       00 00 C6 C7 
       EF EF EF EF 
       EF EF EF C6 
       C7 C6 00 00 
       00 00 C6 C7 
       EF EF EF 00 
       00 EF EF EF 
       C7 C6 C6 00 
       00 C6 C7 EF 
       EF EF 00 00 
       00 00 EF EF 
       EF C7 C6 00 
       00 C6 C7 EF 
       EF 00 00 00 
       00 00 00 EF 
       EF C7 C6 00 
       00 C7 C7 C7 
       C7 00 00 00 
       00 00 00 EF 
       EF C7 C6 00 
       C7 C6 C7 EF 
       EF C7 00 00 
       00 00 EF EF 
       EF C7 C6 00 
       C6 00 C6 C7 
       EF C7 EF 00 
       00 EF EF EF 
       C7 C6 00 00 
       C6 00 C6 C7 
       EF EF EF EF 
       EF EF EF EF 
       C7 C6 00 00 
       C6 00 00 C6 
       C7 C7 EF EF 
       EF EF C7 C7 
       C6 00 00 00 
       00 C6 C6 C6 
       C7 C6 C7 C7 
       C7 C7 C6 C6 
       00 00 00 00 
       00 00 00 00 
       00 00 C6 C6 
       C6 C6 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FDD             0016*M 
040FDD             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040FDD 17 1B 21    0018*M     db 23,27,0x21
040FE0 10 00       0019*M     dw width ; in pixels
040FE2 10 00       0020*M     dw height ; in pixels
040FE4 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040FE5             0083*  	LOADBMPBUFFER2 BUF_EXPLOSION_E,16,16,"nurples/src/rgba2/explosion_e.rgba2"
040FE5             0001*M 
040FE5             0002*M     ; Clear buffer
040FE5 17 00 A0    0003*M     db 23,0,0xA0
040FE8 0E 01       0004*M     dw bufferId
040FEA 02          0005*M     db 2
040FEB             0006*M 
040FEB 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040FEE 0E 01       0008*M     dw bufferId
040FF0             0009*M 
040FF0             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040FF0 17 00 A0    0011*M     db 23,0,0xA0
040FF3 0E 01       0012*M     dw bufferId
040FF5 00          0013*M     db 0
040FF6 00 01       0014*M 	dw width * height ; length of data in bytes
040FF8 00 00 00 C6 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 C6 00 00 
       C6 00 C6 C6 
       C6 C6 00 00 
       00 00 00 00 
       00 C6 00 00 
       C6 C6 C7 C7 
       C7 C7 C7 C6 
       00 00 00 00 
       00 00 C6 C6 
       C7 C7 00 00 
       00 00 00 00 
       C7 00 00 00 
       00 00 C6 C7 
       00 00 00 00 
       00 00 00 00 
       00 C6 00 00 
       00 00 C6 C7 
       00 00 00 00 
       00 00 00 00 
       00 C6 00 00 
       00 C6 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C6 00 
       00 C6 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
       00 C6 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
       00 C6 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
       00 00 C6 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C6 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 C7 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       C6 C6 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 C7 
       C7 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0410F8             0016*M 
0410F8             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0410F8 17 1B 21    0018*M     db 23,27,0x21
0410FB 10 00       0019*M     dw width ; in pixels
0410FD 10 00       0020*M     dw height ; in pixels
0410FF 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041100             0084*  	LOADBMPBUFFER2 BUF_FIREBALL_A,7,7,"nurples/src/rgba2/fireball_a.rgba2"
041100             0001*M 
041100             0002*M     ; Clear buffer
041100 17 00 A0    0003*M     db 23,0,0xA0
041103 0F 01       0004*M     dw bufferId
041105 02          0005*M     db 2
041106             0006*M 
041106 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041109 0F 01       0008*M     dw bufferId
04110B             0009*M 
04110B             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04110B 17 00 A0    0011*M     db 23,0,0xA0
04110E 0F 01       0012*M     dw bufferId
041110 00          0013*M     db 0
041111 31 00       0014*M 	dw width * height ; length of data in bytes
041113 00 00 D2 D2 0015*M     incbin file ; bitmap data
       D2 00 00 00 
       D2 C3 D2 CB 
       D1 00 D2 CB 
       D6 D7 DB D7 
       D2 D7 D2 D6 
       DB D2 D2 D2 
       D2 D2 D6 D6 
       D6 C3 D1 00 
       D1 C3 D2 CB 
       C1 00 00 00 
       D1 D2 D1 00 
       00          
041144             0016*M 
041144             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041144 17 1B 21    0018*M     db 23,27,0x21
041147 07 00       0019*M     dw width ; in pixels
041149 07 00       0020*M     dw height ; in pixels
04114B 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04114C             0085*  	LOADBMPBUFFER2 BUF_FIREBALL_B,7,7,"nurples/src/rgba2/fireball_b.rgba2"
04114C             0001*M 
04114C             0002*M     ; Clear buffer
04114C 17 00 A0    0003*M     db 23,0,0xA0
04114F 10 01       0004*M     dw bufferId
041151 02          0005*M     db 2
041152             0006*M 
041152 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041155 10 01       0008*M     dw bufferId
041157             0009*M 
041157             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041157 17 00 A0    0011*M     db 23,0,0xA0
04115A 10 01       0012*M     dw bufferId
04115C 00          0013*M     db 0
04115D 31 00       0014*M 	dw width * height ; length of data in bytes
04115F 00 00 D2 D2 0015*M     incbin file ; bitmap data
       D2 00 00 00 
       D2 C3 DF CB 
       D1 00 D2 D2 
       C7 C3 D7 D2 
       D1 D7 C3 DF 
       CB CB C3 D2 
       D2 D2 C7 CB 
       C7 C3 D1 00 
       D1 C3 C3 D2 
       C1 00 00 00 
       D1 D2 D1 00 
       00          
041190             0016*M 
041190             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041190 17 1B 21    0018*M     db 23,27,0x21
041193 07 00       0019*M     dw width ; in pixels
041195 07 00       0020*M     dw height ; in pixels
041197 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041198             0086*  	LOADBMPBUFFER2 BUF_LASER_A,5,13,"nurples/src/rgba2/laser_a.rgba2"
041198             0001*M 
041198             0002*M     ; Clear buffer
041198 17 00 A0    0003*M     db 23,0,0xA0
04119B 11 01       0004*M     dw bufferId
04119D 02          0005*M     db 2
04119E             0006*M 
04119E 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0411A1 11 01       0008*M     dw bufferId
0411A3             0009*M 
0411A3             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0411A3 17 00 A0    0011*M     db 23,0,0xA0
0411A6 11 01       0012*M     dw bufferId
0411A8 00          0013*M     db 0
0411A9 41 00       0014*M 	dw width * height ; length of data in bytes
0411AB 00 FF FF FF 0015*M     incbin file ; bitmap data
       00 FA FF FF 
       FF FA FA FF 
       FF FF FA FA 
       FF FF FF FA 
       00 FA FF FA 
       00 00 FA FF 
       FA 00 00 E5 
       FF E5 00 00 
       00 FF E5 00 
       00 00 FF E5 
       00 00 00 FA 
       00 00 00 00 
       E5 00 00 00 
       00 E5 00 00 
       00 00 00 00 
       00          
0411EC             0016*M 
0411EC             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0411EC 17 1B 21    0018*M     db 23,27,0x21
0411EF 05 00       0019*M     dw width ; in pixels
0411F1 0D 00       0020*M     dw height ; in pixels
0411F3 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0411F4             0087*  	LOADBMPBUFFER2 BUF_LASER_B,5,13,"nurples/src/rgba2/laser_b.rgba2"
0411F4             0001*M 
0411F4             0002*M     ; Clear buffer
0411F4 17 00 A0    0003*M     db 23,0,0xA0
0411F7 12 01       0004*M     dw bufferId
0411F9 02          0005*M     db 2
0411FA             0006*M 
0411FA 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0411FD 12 01       0008*M     dw bufferId
0411FF             0009*M 
0411FF             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0411FF 17 00 A0    0011*M     db 23,0,0xA0
041202 12 01       0012*M     dw bufferId
041204 00          0013*M     db 0
041205 41 00       0014*M 	dw width * height ; length of data in bytes
041207 00 FF FF FF 0015*M     incbin file ; bitmap data
       00 FA FF FF 
       FF FA FA FF 
       FF FF FA FA 
       FF FF FF FA 
       00 FA FF FA 
       00 00 FA FF 
       FA 00 00 FA 
       FF E5 00 00 
       E5 E5 00 00 
       00 00 E5 00 
       00 00 00 E5 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 E5 00 
       00          
041248             0016*M 
041248             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041248 17 1B 21    0018*M     db 23,27,0x21
04124B 05 00       0019*M     dw width ; in pixels
04124D 0D 00       0020*M     dw height ; in pixels
04124F 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041250             0088*  	LOADBMPBUFFER2 BUF_PAD,16,16,"nurples/src/rgba2/pad.rgba2"
041250             0001*M 
041250             0002*M     ; Clear buffer
041250 17 00 A0    0003*M     db 23,0,0xA0
041253 13 01       0004*M     dw bufferId
041255 02          0005*M     db 2
041256             0006*M 
041256 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041259 13 01       0008*M     dw bufferId
04125B             0009*M 
04125B             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04125B 17 00 A0    0011*M     db 23,0,0xA0
04125E 13 01       0012*M     dw bufferId
041260 00          0013*M     db 0
041261 00 01       0014*M 	dw width * height ; length of data in bytes
041263 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
       00 C3 C3 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 C3 C3 00 
       00 C3 C3 D0 
       F5 F5 D0 D0 
       D0 D0 F5 F5 
       D0 C3 C3 00 
       00 D0 D0 F5 
       FA FA D0 DF 
       DF D0 FA FA 
       F5 D0 D0 00 
       00 D0 F5 FA 
       D9 D9 D0 D0 
       D0 D0 D9 D9 
       FA F5 D0 00 
       D0 F5 F5 FA 
       D9 D9 D0 DF 
       DF D0 D9 D9 
       FA F5 F5 D0 
       D0 F5 D0 D0 
       D0 D0 D0 DF 
       DF D0 D0 D0 
       D0 D0 F5 D0 
       DF DF D0 DF 
       D0 DF DF D0 
       D0 DF DF D0 
       DF D0 DF DF 
       DF DF D0 DF 
       D0 DF DF D0 
       D0 DF DF D0 
       DF D0 DF DF 
       D0 F5 D0 D0 
       D0 D0 D0 DF 
       DF D0 D0 D0 
       D0 D0 F5 D0 
       D0 F5 F5 FA 
       D9 D9 D0 DF 
       DF D0 D9 D9 
       FA F5 F5 D0 
       00 D0 F5 FA 
       D9 D9 D0 D0 
       D0 D0 D9 D9 
       FA F5 D0 00 
       00 D0 D0 F5 
       FA FA D0 DF 
       DF D0 FA FA 
       F5 D0 D0 00 
       00 C3 C3 D0 
       F5 F5 D0 D0 
       D0 D0 F5 F5 
       D0 C3 C3 00 
       00 C3 C3 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 C3 C3 00 
       00 00 00 00 
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
041363             0016*M 
041363             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041363 17 1B 21    0018*M     db 23,27,0x21
041366 10 00       0019*M     dw width ; in pixels
041368 10 00       0020*M     dw height ; in pixels
04136A 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04136B             0089*  	LOADBMPBUFFER2 BUF_SEEKER_000,16,16,"nurples/src/rgba2/seeker_000.rgba2"
04136B             0001*M 
04136B             0002*M     ; Clear buffer
04136B 17 00 A0    0003*M     db 23,0,0xA0
04136E 14 01       0004*M     dw bufferId
041370 02          0005*M     db 2
041371             0006*M 
041371 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041374 14 01       0008*M     dw bufferId
041376             0009*M 
041376             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041376 17 00 A0    0011*M     db 23,0,0xA0
041379 14 01       0012*M     dw bufferId
04137B 00          0013*M     db 0
04137C 00 01       0014*M 	dw width * height ; length of data in bytes
04137E 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 F5 
       E1 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 F5 
       E1 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 FA F5 
       E1 E5 00 00 
       00 00 00 00 
       00 FA 00 00 
       EA 00 FF FF 
       EE EA 00 EA 
       00 00 EA 00 
       F6 E2 E5 00 
       E1 F6 FB FF 
       EB E5 E2 E1 
       00 E5 E1 E2 
       F6 E1 F6 E2 
       E1 EB FB FA 
       F6 E6 D7 E1 
       F7 F6 E1 E1 
       F5 E1 E1 00 
       F6 EA FA F5 
       F5 E5 D5 F6 
       00 E1 E1 E1 
       00 E1 E1 E2 
       E1 F6 F8 FC 
       F8 F4 E1 E1 
       E2 E1 E1 00 
       00 E1 00 00 
       E1 E1 FC FE 
       FD F8 E1 E1 
       00 00 E1 00 
       00 E1 00 00 
       E1 E1 FD FE 
       FD F9 D0 E1 
       00 00 E1 00 
       00 FA 00 00 
       E1 E1 F5 FD 
       F9 E1 D0 E1 
       00 00 EA 00 
       EF DB DB 00 
       E5 E1 E2 F5 
       F5 D1 D0 E5 
       00 DB DB DB 
       00 DF 00 00 
       00 E1 E2 F5 
       E1 D1 D0 00 
       00 00 DF 00 
       EF DB DB 00 
       00 E1 E2 00 
       00 D1 D0 00 
       00 DB DB DB 
       00 EB 00 00 
       00 E2 FB 00 
       00 E6 D1 00 
       00 00 D7 00 
       00 C3 00 00 
       00 F3 00 00 
       00 00 F3 00 
       00 00 C3 00 
04147E             0016*M 
04147E             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04147E 17 1B 21    0018*M     db 23,27,0x21
041481 10 00       0019*M     dw width ; in pixels
041483 10 00       0020*M     dw height ; in pixels
041485 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041486             0090*  	LOADBMPBUFFER2 BUF_SEEKER_001,16,16,"nurples/src/rgba2/seeker_001.rgba2"
041486             0001*M 
041486             0002*M     ; Clear buffer
041486 17 00 A0    0003*M     db 23,0,0xA0
041489 15 01       0004*M     dw bufferId
04148B 02          0005*M     db 2
04148C             0006*M 
04148C 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04148F 15 01       0008*M     dw bufferId
041491             0009*M 
041491             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041491 17 00 A0    0011*M     db 23,0,0xA0
041494 15 01       0012*M     dw bufferId
041496 00          0013*M     db 0
041497 00 01       0014*M 	dw width * height ; length of data in bytes
041499 00 FA 00 00 0015*M     incbin file ; bitmap data
       00 00 FA 00 
       F5 F5 E0 00 
       00 00 00 00 
       00 00 FA 00 
       EA 00 00 FF 
       F5 E5 D0 00 
       00 00 00 00 
       00 E6 FA 00 
       00 EA 00 FA 
       F5 E0 E5 E5 
       00 00 00 00 
       00 F2 E1 E5 
       00 E6 F6 FF 
       FF EA E5 00 
       EA 00 00 00 
       00 E1 E1 E2 
       E1 E2 FB FB 
       FF EA E5 E2 
       EA 00 FF EA 
       F5 E4 E1 E1 
       F1 E6 EB FB 
       FA E6 E6 E2 
       E1 E9 E5 E6 
       00 E0 E1 E2 
       E1 F6 FA F9 
       F5 E5 D6 E2 
       F6 F6 E1 E1 
       D0 E0 00 E2 
       E1 E5 F8 FC 
       F8 F4 E5 E5 
       F2 E1 E1 E1 
       F5 E5 00 E0 
       E1 E1 FD FE 
       FD F4 E1 E1 
       E2 E1 E1 E0 
       EB EB 00 E1 
       E0 E5 FD FE 
       FD E4 D1 E1 
       00 E0 E1 00 
       DF DB DB E5 
       E5 E1 F5 FD 
       E5 D0 D0 E0 
       00 E0 E0 00 
       DF DF 00 FF 
       E4 E2 F6 F5 
       E1 D0 E5 E1 
       00 F5 F5 00 
       DB DB D6 00 
       E0 E2 E1 E1 
       D1 D0 E5 F0 
       EB DB DB 00 
       E7 00 00 E1 
       E2 E7 00 D1 
       D1 D0 00 00 
       00 DF DB 00 
       C3 00 00 F2 
       F3 FF 00 E6 
       E6 C0 00 DB 
       DB DB EB 00 
       00 00 00 00 
       00 00 E6 00 
       E2 E2 00 00 
       D7 DB DB 00 
041599             0016*M 
041599             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041599 17 1B 21    0018*M     db 23,27,0x21
04159C 10 00       0019*M     dw width ; in pixels
04159E 10 00       0020*M     dw height ; in pixels
0415A0 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0415A1             0091*  	LOADBMPBUFFER2 BUF_SEEKER_002,16,16,"nurples/src/rgba2/seeker_002.rgba2"
0415A1             0001*M 
0415A1             0002*M     ; Clear buffer
0415A1 17 00 A0    0003*M     db 23,0,0xA0
0415A4 16 01       0004*M     dw bufferId
0415A6 02          0005*M     db 2
0415A7             0006*M 
0415A7 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0415AA 16 01       0008*M     dw bufferId
0415AC             0009*M 
0415AC             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0415AC 17 00 A0    0011*M     db 23,0,0xA0
0415AF 16 01       0012*M     dw bufferId
0415B1 00          0013*M     db 0
0415B2 00 01       0014*M 	dw width * height ; length of data in bytes
0415B4 00 00 00 FE 0015*M     incbin file ; bitmap data
       00 FA 00 00 
       00 E1 F5 00 
       00 00 00 00 
       00 00 F6 FA 
       FF 00 FA 00 
       FF F1 F5 E0 
       00 00 00 00 
       00 00 E2 E1 
       E5 00 EA 00 
       FA F5 E0 E1 
       00 D0 00 00 
       00 F5 E1 E1 
       E6 E1 E2 F6 
       FF FA E5 E5 
       E5 00 00 00 
       00 E1 E0 E1 
       E2 E1 E7 FB 
       FF FF EA D5 
       00 EA E5 00 
       00 E0 E1 E2 
       E2 F6 EB FB 
       FA FA E5 E2 
       E6 EA 00 FA 
       00 E0 E0 F3 
       E1 E5 F9 F9 
       F5 E5 E6 E2 
       E1 F7 E5 EA 
       FA F5 00 E4 
       E1 E1 F8 FC 
       F8 F4 E5 E6 
       F6 F6 E5 E1 
       DB EB 00 E0 
       E0 E5 FD FE 
       FD F4 E1 E5 
       E2 E1 E1 E1 
       DF DB 00 E5 
       E1 E5 FE FE 
       FD E4 E1 E1 
       E2 E1 E0 E1 
       DB F1 00 E5 
       E1 E2 F9 F9 
       E5 D0 E1 E4 
       00 E0 E1 00 
       DB DB 00 E0 
       E2 F2 F5 E1 
       D1 D0 E0 00 
       00 E0 E0 00 
       00 00 E1 E1 
       E2 E1 E0 D1 
       D0 E5 E5 00 
       EA E5 00 00 
       00 00 F2 F7 
       FB 00 D2 D1 
       D0 00 F0 EB 
       DB DA 00 00 
       00 00 00 F2 
       00 00 E6 E5 
       D0 00 E7 DF 
       DF DB 00 00 
       00 00 00 00 
       00 00 00 E2 
       D1 00 EB DB 
       DB E7 00 00 
0416B4             0016*M 
0416B4             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0416B4 17 1B 21    0018*M     db 23,27,0x21
0416B7 10 00       0019*M     dw width ; in pixels
0416B9 10 00       0020*M     dw height ; in pixels
0416BB 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0416BC             0092*  	LOADBMPBUFFER2 BUF_SEEKER_003,16,16,"nurples/src/rgba2/seeker_003.rgba2"
0416BC             0001*M 
0416BC             0002*M     ; Clear buffer
0416BC 17 00 A0    0003*M     db 23,0,0xA0
0416BF 17 01       0004*M     dw bufferId
0416C1 02          0005*M     db 2
0416C2             0006*M 
0416C2 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0416C5 17 01       0008*M     dw bufferId
0416C7             0009*M 
0416C7             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0416C7 17 00 A0    0011*M     db 23,0,0xA0
0416CA 17 01       0012*M     dw bufferId
0416CC 00          0013*M     db 0
0416CD 00 01       0014*M 	dw width * height ; length of data in bytes
0416CF 00 00 00 F7 0015*M     incbin file ; bitmap data
       FA FF 00 F5 
       00 FA 00 00 
       00 00 00 00 
       00 00 00 F6 
       E2 E5 00 EA 
       00 FF 00 F5 
       F5 00 00 00 
       00 00 F5 E1 
       E1 E5 00 FA 
       00 FA F5 F5 
       E0 00 00 00 
       00 00 E0 E1 
       E1 E2 E1 E2 
       F6 FF F5 E0 
       E5 00 00 00 
       00 E0 E1 E1 
       E2 F1 E6 EB 
       FB FF FF EA 
       E5 00 00 00 
       00 E1 E0 00 
       E2 E1 E6 FB 
       FB FA EA E5 
       00 FE 00 F5 
       EB FA 00 00 
       E1 E1 F9 F9 
       F5 F5 E6 E2 
       E2 EA 00 00 
       CB DB 00 E0 
       E1 E1 FC FC 
       F8 E5 E6 D6 
       E1 D1 C4 EA 
       DF E7 F0 E5 
       E0 F9 FE FE 
       F8 F4 E5 F6 
       F6 F6 F5 E5 
       DB D6 FF E5 
       E1 F5 FD FD 
       FD E4 E1 E1 
       E1 E1 E1 E1 
       C6 00 E0 E1 
       E2 F6 F9 E5 
       E4 D0 E1 E2 
       E1 E1 E0 E1 
       00 E2 E1 E2 
       E2 F5 E1 D1 
       D0 E0 E1 00 
       E0 E1 E0 00 
       00 F3 F7 FB 
       00 E0 D1 D1 
       E5 E5 00 00 
       E0 E0 00 00 
       00 00 00 FF 
       00 E6 D1 D0 
       E5 F0 DB EA 
       E5 00 00 00 
       00 00 00 F7 
       00 E6 D1 D0 
       00 00 DB DA 
       DB 00 00 00 
       00 00 00 00 
       00 F3 E2 00 
       DB DB DF DF 
       EB 00 00 00 
0417CF             0016*M 
0417CF             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0417CF 17 1B 21    0018*M     db 23,27,0x21
0417D2 10 00       0019*M     dw width ; in pixels
0417D4 10 00       0020*M     dw height ; in pixels
0417D6 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0417D7             0093*  	LOADBMPBUFFER2 BUF_SEEKER_004,16,16,"nurples/src/rgba2/seeker_004.rgba2"
0417D7             0001*M 
0417D7             0002*M     ; Clear buffer
0417D7 17 00 A0    0003*M     db 23,0,0xA0
0417DA 18 01       0004*M     dw bufferId
0417DC 02          0005*M     db 2
0417DD             0006*M 
0417DD 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0417E0 18 01       0008*M     dw bufferId
0417E2             0009*M 
0417E2             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0417E2 17 00 A0    0011*M     db 23,0,0xA0
0417E5 18 01       0012*M     dw bufferId
0417E7 00          0013*M     db 0
0417E8 00 01       0014*M 	dw width * height ; length of data in bytes
0417EA 00 00 00 00 0015*M     incbin file ; bitmap data
       F6 E2 FA 00 
       FA 00 00 00 
       00 00 00 00 
       00 00 00 F5 
       E1 E1 E5 00 
       EA 00 00 00 
       F5 00 00 00 
       00 00 00 E0 
       E1 F1 E6 D0 
       EA 00 FA F6 
       F5 F5 00 00 
       00 00 E0 E1 
       E1 E1 E2 E1 
       E2 FB FF F5 
       F1 E0 E0 00 
       EF F5 E0 E0 
       E2 E2 F6 EA 
       FB FB FF EA 
       E0 E5 00 00 
       DB EB F0 00 
       D4 E1 F6 FA 
       FB FB FF EE 
       EA E5 00 00 
       DF DB 00 E1 
       E1 E1 F5 F8 
       F5 F5 EA E5 
       D1 00 00 00 
       DB 00 F0 E5 
       E0 E5 FC FD 
       F8 E5 E6 E7 
       E2 EA EA EA 
       EB 00 E5 E5 
       E1 F9 FE FE 
       F8 F4 E5 E2 
       E1 D0 00 00 
       00 00 E0 E1 
       E2 F9 FD FD 
       F8 E4 E1 F6 
       F6 F6 E5 EA 
       00 E1 F2 E2 
       F5 F5 E5 E5 
       D4 E1 E1 E2 
       E1 E1 E1 E1 
       F3 F7 FB E3 
       E4 E1 D1 D0 
       D0 E1 E4 E2 
       E1 E1 E1 E1 
       00 00 FF 00 
       D2 D1 D1 D5 
       E5 E1 00 E1 
       E1 E0 E0 00 
       00 00 E6 EA 
       E6 D1 D0 E5 
       F0 00 F0 E0 
       E0 00 00 00 
       00 00 00 00 
       E2 C0 00 00 
       00 DB EA F5 
       00 00 00 00 
       00 00 00 00 
       F3 00 00 EB 
       DB DF DB DB 
       00 00 00 00 
0418EA             0016*M 
0418EA             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0418EA 17 1B 21    0018*M     db 23,27,0x21
0418ED 10 00       0019*M     dw width ; in pixels
0418EF 10 00       0020*M     dw height ; in pixels
0418F1 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0418F2             0094*  	LOADBMPBUFFER2 BUF_SEEKER_005,16,16,"nurples/src/rgba2/seeker_005.rgba2"
0418F2             0001*M 
0418F2             0002*M     ; Clear buffer
0418F2 17 00 A0    0003*M     db 23,0,0xA0
0418F5 19 01       0004*M     dw bufferId
0418F7 02          0005*M     db 2
0418F8             0006*M 
0418F8 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0418FB 19 01       0008*M     dw bufferId
0418FD             0009*M 
0418FD             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0418FD 17 00 A0    0011*M     db 23,0,0xA0
041900 19 01       0012*M     dw bufferId
041902 00          0013*M     db 0
041903 00 01       0014*M 	dw width * height ; length of data in bytes
041905 00 00 00 00 0015*M     incbin file ; bitmap data
       00 F5 E2 E6 
       FA 00 F5 00 
       00 00 00 00 
       00 00 00 00 
       E1 E1 E1 F6 
       C8 00 00 00 
       00 00 00 00 
       00 00 00 E0 
       E1 E1 E1 E2 
       D1 EA EA 00 
       00 00 00 00 
       FF EF F5 E0 
       E1 E2 E2 E1 
       E1 E2 00 FA 
       F5 F5 F5 00 
       DF DA EA 00 
       00 E2 E1 F6 
       EB FB FB FF 
       E0 F5 E0 00 
       DF DB DB 00 
       E1 E1 E1 FA 
       FB FB FF FF 
       E5 E1 00 00 
       DB 00 F0 E5 
       E0 E1 F4 F8 
       F9 F6 FA EA 
       EA E5 E6 E5 
       DB 00 E5 E5 
       E1 E9 FD FD 
       F8 F5 E5 E5 
       E1 00 00 00 
       00 E0 E0 E1 
       E2 F9 FE FE 
       F8 F4 E6 D7 
       E2 FA EA F5 
       F2 E2 E2 E2 
       F6 F9 FD FD 
       F8 E0 E5 E2 
       E1 00 00 00 
       F3 FB F7 E4 
       F5 E1 E1 E4 
       E4 E1 E1 F6 
       F7 E6 E5 EA 
       00 00 00 00 
       D1 D1 D0 D0 
       E0 E1 E2 E1 
       E1 E1 E1 E6 
       00 E6 EA E6 
       D1 D0 D5 E5 
       E0 00 00 E0 
       E1 E1 E1 E2 
       00 00 00 E6 
       D0 D0 FF F0 
       00 00 E0 E1 
       E0 E1 00 00 
       00 00 00 F2 
       D1 00 D6 E7 
       DB E6 E1 E0 
       00 00 00 00 
       00 00 00 00 
       00 DB DB DF 
       CB EA 00 00 
       00 00 00 00 
041A05             0016*M 
041A05             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041A05 17 1B 21    0018*M     db 23,27,0x21
041A08 10 00       0019*M     dw width ; in pixels
041A0A 10 00       0020*M     dw height ; in pixels
041A0C 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041A0D             0095*  	LOADBMPBUFFER2 BUF_SEEKER_006,16,16,"nurples/src/rgba2/seeker_006.rgba2"
041A0D             0001*M 
041A0D             0002*M     ; Clear buffer
041A0D 17 00 A0    0003*M     db 23,0,0xA0
041A10 1A 01       0004*M     dw bufferId
041A12 02          0005*M     db 2
041A13             0006*M 
041A13 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041A16 1A 01       0008*M     dw bufferId
041A18             0009*M 
041A18             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041A18 17 00 A0    0011*M     db 23,0,0xA0
041A1B 1A 01       0012*M     dw bufferId
041A1D 00          0013*M     db 0
041A1E 00 01       0014*M 	dw width * height ; length of data in bytes
041A20 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 F5 E1 
       E2 FA FF 00 
       00 00 00 00 
       00 00 00 00 
       E0 E0 E0 E1 
       E5 E5 00 E5 
       00 00 00 00 
       FF EF EB F5 
       E0 E1 E1 E1 
       E2 D1 EA EA 
       00 F5 00 00 
       DF DF DB FA 
       00 00 E2 F2 
       E1 E1 E6 00 
       FA 00 00 00 
       DB DF EB 00 
       00 D4 E1 E1 
       F6 E7 F6 FF 
       FA F5 F5 00 
       DB E7 F0 E5 
       E0 E1 E1 F6 
       FA FB FB FF 
       FA E0 F5 E0 
       00 00 00 E5 
       E1 E5 F8 F8 
       F9 FA FA FF 
       EA E0 E0 D0 
       E2 E1 E0 E1 
       E1 F9 FE FD 
       FC F5 F6 EA 
       EA E5 FA 00 
       F3 F7 E2 E2 
       F6 FD FE FE 
       F8 F4 E6 E6 
       E1 00 00 00 
       00 FF E3 E5 
       F5 F5 F9 FD 
       F4 E4 D6 E2 
       E2 EA EA 00 
       00 00 00 D0 
       E1 D1 E0 D4 
       E1 E1 F6 E1 
       E1 00 00 EA 
       00 00 E6 D1 
       D1 D0 D0 D0 
       E1 E1 E2 FB 
       F6 E5 FE 00 
       00 F3 E6 D0 
       D0 E5 E5 E0 
       E0 F3 E1 E1 
       E1 E1 EA FA 
       00 00 E2 D0 
       00 00 00 00 
       00 E1 E0 E0 
       E1 E1 E2 00 
       00 00 00 00 
       DB F1 DB DA 
       E5 E0 E1 E0 
       E1 00 00 00 
       00 00 00 00 
       DB DB DF DA 
       FA 00 00 00 
       00 00 00 00 
041B20             0016*M 
041B20             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041B20 17 1B 21    0018*M     db 23,27,0x21
041B23 10 00       0019*M     dw width ; in pixels
041B25 10 00       0020*M     dw height ; in pixels
041B27 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041B28             0096*  	LOADBMPBUFFER2 BUF_SEEKER_007,16,16,"nurples/src/rgba2/seeker_007.rgba2"
041B28             0001*M 
041B28             0002*M     ; Clear buffer
041B28 17 00 A0    0003*M     db 23,0,0xA0
041B2B 1B 01       0004*M     dw bufferId
041B2D 02          0005*M     db 2
041B2E             0006*M 
041B2E 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041B31 1B 01       0008*M     dw bufferId
041B33             0009*M 
041B33             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041B33 17 00 A0    0011*M     db 23,0,0xA0
041B36 1B 01       0012*M     dw bufferId
041B38 00          0013*M     db 0
041B39 00 01       0014*M 	dw width * height ; length of data in bytes
041B3B 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 E5 
       F5 E2 E6 FE 
       00 00 00 00 
       EF EF EF EF 
       F5 E0 E0 E1 
       E1 E1 E5 FF 
       00 00 00 00 
       EB DB DF DB 
       FA E0 E1 E1 
       E1 E2 E9 00 
       00 00 00 00 
       EB DB 00 EB 
       00 00 00 E2 
       F6 E1 E1 EA 
       EA 00 00 00 
       00 DB 00 F0 
       E1 E0 E5 E1 
       F6 E6 E6 E2 
       00 FA 00 00 
       00 00 00 E5 
       E5 E0 E1 E5 
       FA EB FB FA 
       FA FA E0 F5 
       F2 E1 E0 E1 
       E1 E5 FD F8 
       F8 FA FB FF 
       FA E0 F5 F5 
       F7 FB E2 E2 
       F2 F9 FE FE 
       FC F5 FA FF 
       EE E1 E0 E0 
       00 FB E2 E5 
       F5 FD FD FD 
       F8 E5 E5 EA 
       EA E5 FF 00 
       E6 00 00 E1 
       E1 E5 F9 F8 
       F4 E5 D6 E2 
       E2 00 00 E5 
       00 EA D5 D1 
       D1 D0 D0 E4 
       E1 E5 E2 E1 
       E6 EA 00 00 
       00 E2 D1 D0 
       D0 E5 E0 E1 
       E1 E1 F6 E6 
       00 00 E6 00 
       00 F2 D0 00 
       FF E5 E1 E0 
       E2 E2 E1 F6 
       E5 00 00 00 
       00 00 00 D6 
       00 DB 00 00 
       00 E0 E1 E1 
       E1 FA EA 00 
       00 00 00 DB 
       DF DB EA E5 
       E0 E1 E0 E1 
       E1 E2 00 EA 
       00 C3 D7 DB 
       DF DB EA F4 
       E0 00 E0 00 
       00 00 00 00 
041C3B             0016*M 
041C3B             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041C3B 17 1B 21    0018*M     db 23,27,0x21
041C3E 10 00       0019*M     dw width ; in pixels
041C40 10 00       0020*M     dw height ; in pixels
041C42 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041C43             0097*  	LOADBMPBUFFER2 BUF_SEEKER_008,16,16,"nurples/src/rgba2/seeker_008.rgba2"
041C43             0001*M 
041C43             0002*M     ; Clear buffer
041C43 17 00 A0    0003*M     db 23,0,0xA0
041C46 1C 01       0004*M     dw bufferId
041C48 02          0005*M     db 2
041C49             0006*M 
041C49 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041C4C 1C 01       0008*M     dw bufferId
041C4E             0009*M 
041C4E             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041C4E 17 00 A0    0011*M     db 23,0,0xA0
041C51 1C 01       0012*M     dw bufferId
041C53 00          0013*M     db 0
041C54 00 01       0014*M 	dw width * height ; length of data in bytes
041C56 00 00 EF 00 0015*M     incbin file ; bitmap data
       EF 00 00 00 
       00 F5 F6 F6 
       00 00 00 00 
       C3 EB DB DF 
       DB FA E1 E1 
       E1 E1 E1 E2 
       FA 00 00 00 
       00 00 DB 00 
       DB 00 00 00 
       E1 E1 F6 E5 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E2 00 E2 00 
       00 00 00 00 
       00 00 00 00 
       E5 E1 E1 E1 
       E1 F6 E1 E1 
       EA 00 00 00 
       F3 E2 E1 E1 
       E1 E1 E1 E1 
       F6 EA EB F6 
       00 00 00 00 
       00 FB E2 E2 
       E2 F5 FD FC 
       F8 FA FB FB 
       FF FA 00 00 
       00 00 00 F5 
       F5 FD FE FE 
       FC F5 FA FF 
       FF F5 F5 F5 
       00 00 00 E1 
       F5 F9 FD FD 
       F8 F5 F6 EB 
       EE E1 E1 E1 
       00 E6 D1 D1 
       D1 E1 F9 F8 
       F4 E5 E6 E5 
       EA E5 00 00 
       F3 D1 D0 D0 
       D0 D0 D0 E1 
       E1 D5 D7 E2 
       00 00 00 00 
       00 00 00 00 
       E5 E1 E1 E1 
       E1 F6 E1 E1 
       EA 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E2 00 F7 00 
       00 00 00 00 
       00 00 DB 00 
       DB 00 00 00 
       E1 E1 F6 E5 
       00 00 00 00 
       C3 D7 DB DF 
       DB EA E1 E1 
       E1 E1 E1 E1 
       EA 00 00 00 
       00 00 DB 00 
       DB 00 00 00 
       00 E1 E1 E2 
       00 00 00 00 
041D56             0016*M 
041D56             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041D56 17 1B 21    0018*M     db 23,27,0x21
041D59 10 00       0019*M     dw width ; in pixels
041D5B 10 00       0020*M     dw height ; in pixels
041D5D 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041D5E             0098*  	LOADBMPBUFFER2 BUF_SEEKER_009,16,16,"nurples/src/rgba2/seeker_009.rgba2"
041D5E             0001*M 
041D5E             0002*M     ; Clear buffer
041D5E 17 00 A0    0003*M     db 23,0,0xA0
041D61 1D 01       0004*M     dw bufferId
041D63 02          0005*M     db 2
041D64             0006*M 
041D64 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041D67 1D 01       0008*M     dw bufferId
041D69             0009*M 
041D69             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041D69 17 00 A0    0011*M     db 23,0,0xA0
041D6C 1D 01       0012*M     dw bufferId
041D6E 00          0013*M     db 0
041D6F 00 01       0014*M 	dw width * height ; length of data in bytes
041D71 00 C3 E7 DB 0015*M     incbin file ; bitmap data
       DF DF EB F5 
       D0 00 F5 00 
       00 00 00 00 
       00 00 00 DB 
       DF DB EB E5 
       E0 E0 E4 E1 
       F2 E6 00 FA 
       00 00 00 D6 
       00 DB 00 00 
       00 E1 E1 E1 
       E1 FA FA 00 
       00 F2 E1 00 
       FF E5 E1 E0 
       E2 E2 E1 E2 
       E5 00 00 00 
       00 F3 E2 E0 
       E4 E5 E0 E1 
       E1 E1 F1 E1 
       00 00 EA 00 
       00 FF E7 E2 
       E2 E1 E5 E1 
       E5 F6 E6 E2 
       E6 EA 00 00 
       E6 00 00 E1 
       F6 F5 FD FD 
       F8 FA EB FB 
       F6 00 00 FA 
       00 E6 D1 E1 
       F5 FD FE FE 
       FC F9 FB FB 
       FF FA FF 00 
       E2 E6 D1 D1 
       E1 E5 FD FD 
       F8 F5 FA FF 
       FF F5 F5 F5 
       E2 C0 D0 D0 
       D0 D0 E4 F4 
       F4 E5 E6 EA 
       EA E0 E5 F5 
       00 00 00 E5 
       E5 D0 D1 E1 
       E5 D6 E6 E5 
       E5 E5 D0 E0 
       00 DB 00 F0 
       E1 E0 E1 E1 
       E5 E2 E2 E2 
       00 E5 00 00 
       D7 DB 00 EB 
       00 00 00 E2 
       F2 F6 E1 EA 
       EA 00 00 00 
       DB DB DF DB 
       F5 E0 E0 E1 
       E1 F6 E9 00 
       00 00 00 00 
       DB EB DB DB 
       F5 E0 E1 E1 
       E1 E1 E5 FF 
       00 00 00 00 
       00 00 00 00 
       00 00 00 E0 
       E1 E1 E6 EA 
       00 00 00 00 
041E71             0016*M 
041E71             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041E71 17 1B 21    0018*M     db 23,27,0x21
041E74 10 00       0019*M     dw width ; in pixels
041E76 10 00       0020*M     dw height ; in pixels
041E78 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041E79             0099*  	LOADBMPBUFFER2 BUF_SEEKER_010,16,16,"nurples/src/rgba2/seeker_010.rgba2"
041E79             0001*M 
041E79             0002*M     ; Clear buffer
041E79 17 00 A0    0003*M     db 23,0,0xA0
041E7C 1E 01       0004*M     dw bufferId
041E7E 02          0005*M     db 2
041E7F             0006*M 
041E7F 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041E82 1E 01       0008*M     dw bufferId
041E84             0009*M 
041E84             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041E84 17 00 A0    0011*M     db 23,0,0xA0
041E87 1E 01       0012*M     dw bufferId
041E89 00          0013*M     db 0
041E8A 00 01       0014*M 	dw width * height ; length of data in bytes
041E8C 00 00 00 00 0015*M     incbin file ; bitmap data
       DB DB DF DB 
       FA 00 00 00 
       00 00 00 00 
       00 00 00 00 
       DB F1 DB EB 
       F5 E0 E0 E1 
       F5 00 00 00 
       00 00 F2 E1 
       00 00 00 00 
       00 E0 E1 E0 
       E1 E2 F6 00 
       00 F2 F7 E1 
       E0 E5 E5 E0 
       E4 F3 E2 E1 
       E1 E1 FA FE 
       00 00 FB E2 
       E2 E1 E1 E0 
       E1 E1 E2 E2 
       E6 E5 FF 00 
       00 00 00 E1 
       F2 E2 E5 E5 
       E1 E5 F6 E1 
       E1 00 00 FA 
       00 E6 D2 E0 
       F5 F9 FE FD 
       F8 F9 EB E7 
       E2 EA FA 00 
       E2 E5 D1 D1 
       E1 F9 FE FE 
       FC F9 FB FB 
       F6 00 00 00 
       D1 D0 D0 D0 
       D1 E5 FD FD 
       F8 F5 FA FF 
       FF FA FF 00 
       00 00 00 E5 
       D0 D0 E4 F4 
       F4 E5 FA FF 
       FA F5 F1 E1 
       EB E7 F0 E5 
       E0 E1 E1 E1 
       E5 E6 E5 EA 
       E5 E0 F5 F5 
       DB DF EB 00 
       00 E4 E1 E5 
       E6 E2 E2 D5 
       E5 E1 E0 00 
       DB DF DB EA 
       00 00 E2 E2 
       F6 E1 E6 00 
       E5 00 00 00 
       E7 DB DA E5 
       E0 E0 E1 E1 
       F6 F7 EA EA 
       00 D0 00 00 
       00 00 00 00 
       E0 E1 E0 E1 
       E5 E5 00 E5 
       00 00 00 00 
       00 00 00 00 
       00 00 E1 E1 
       E1 EA FA 00 
       00 00 00 00 
041F8C             0016*M 
041F8C             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041F8C 17 1B 21    0018*M     db 23,27,0x21
041F8F 10 00       0019*M     dw width ; in pixels
041F91 10 00       0020*M     dw height ; in pixels
041F93 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041F94             0100*  	LOADBMPBUFFER2 BUF_SEEKER_011,16,16,"nurples/src/rgba2/seeker_011.rgba2"
041F94             0001*M 
041F94             0002*M     ; Clear buffer
041F94 17 00 A0    0003*M     db 23,0,0xA0
041F97 1F 01       0004*M     dw bufferId
041F99 02          0005*M     db 2
041F9A             0006*M 
041F9A 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041F9D 1F 01       0008*M     dw bufferId
041F9F             0009*M 
041F9F             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041F9F 17 00 A0    0011*M     db 23,0,0xA0
041FA2 1F 01       0012*M     dw bufferId
041FA4 00          0013*M     db 0
041FA5 00 01       0014*M 	dw width * height ; length of data in bytes
041FA7 00 00 00 00 0015*M     incbin file ; bitmap data
       00 C6 DB DF 
       CB EB 00 00 
       00 00 00 00 
       00 00 00 F3 
       E2 00 D6 E7 
       DB FA E1 E0 
       00 00 00 00 
       00 00 00 F7 
       E1 E0 FF F0 
       00 00 E0 E1 
       E0 F5 00 00 
       00 F7 FF FB 
       E2 E1 E5 E5 
       E0 00 00 E1 
       E1 E1 F6 F7 
       00 00 00 00 
       E2 E2 E1 E0 
       E1 E1 E2 E2 
       E1 E1 E2 FA 
       F3 E6 E6 E0 
       F5 F6 F5 F9 
       E1 E1 E1 F1 
       E2 E5 E5 FF 
       E2 D1 D1 D1 
       E1 F9 FD FE 
       FC F9 E6 E6 
       E1 00 00 00 
       00 D0 D0 D1 
       D1 E5 FD FE 
       FC F9 FB EB 
       E2 FA EA F5 
       DB 00 E5 E5 
       D0 E4 FD F8 
       F8 F5 FB FB 
       F6 00 00 00 
       DB 00 F0 E5 
       E0 D0 E4 F4 
       E5 F5 FA FF 
       FF FA FF FA 
       DF DB DB 00 
       E1 E1 E1 E5 
       E6 E6 EA FF 
       F5 F5 00 00 
       DF DA EA 00 
       00 E2 E1 F6 
       D6 E2 E5 EA 
       E0 F5 F5 00 
       EB DB E5 E0 
       E0 E1 E1 F6 
       E1 E2 00 E5 
       E5 E0 F5 00 
       00 00 00 E0 
       E1 E1 E1 F6 
       D1 EA FE 00 
       00 00 00 00 
       00 00 00 00 
       E0 E0 E1 F5 
       C4 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E1 E1 E5 
       EA 00 F5 00 
       00 00 00 00 
0420A7             0016*M 
0420A7             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0420A7 17 1B 21    0018*M     db 23,27,0x21
0420AA 10 00       0019*M     dw width ; in pixels
0420AC 10 00       0020*M     dw height ; in pixels
0420AE 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0420AF             0101*  	LOADBMPBUFFER2 BUF_SEEKER_012,16,16,"nurples/src/rgba2/seeker_012.rgba2"
0420AF             0001*M 
0420AF             0002*M     ; Clear buffer
0420AF 17 00 A0    0003*M     db 23,0,0xA0
0420B2 20 01       0004*M     dw bufferId
0420B4 02          0005*M     db 2
0420B5             0006*M 
0420B5 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0420B8 20 01       0008*M     dw bufferId
0420BA             0009*M 
0420BA             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0420BA 17 00 A0    0011*M     db 23,0,0xA0
0420BD 20 01       0012*M     dw bufferId
0420BF 00          0013*M     db 0
0420C0 00 01       0014*M 	dw width * height ; length of data in bytes
0420C2 00 00 00 00 0015*M     incbin file ; bitmap data
       F3 00 00 EB 
       DB DF DB EF 
       00 00 00 00 
       00 00 00 00 
       F7 E1 00 00 
       00 DB EB F5 
       00 00 00 00 
       00 00 E6 FF 
       FB F2 E0 E5 
       F0 00 F0 E0 
       E0 00 00 00 
       00 00 EA 00 
       E3 E2 E1 E5 
       E5 E1 00 E0 
       E1 E0 F5 00 
       F3 E2 E6 D2 
       E4 F5 E2 E1 
       E0 E1 D4 E2 
       E1 E1 E1 F6 
       00 C0 D1 D1 
       E1 F5 F9 F9 
       E5 E1 E1 E2 
       E1 F1 E1 E2 
       00 00 D0 D1 
       D1 E5 FD FE 
       FC F5 F6 F6 
       E2 E6 E5 FA 
       EB 00 E5 D5 
       D0 E5 FD FE 
       FD F8 FA EA 
       E1 D0 00 00 
       DB 00 F0 E5 
       D0 D4 F8 F8 
       F8 F5 FB FB 
       E2 EA EA FA 
       DF DB 00 E1 
       E1 E1 E4 F4 
       E5 F5 FB FB 
       FB 00 00 00 
       DB EA F0 00 
       E4 E1 E1 E5 
       E6 EA FF FF 
       FF FA 00 00 
       DB F5 E0 E1 
       E2 E2 F6 E2 
       E7 E5 EE EA 
       F5 F6 00 00 
       00 00 E0 E1 
       E1 E1 F6 E1 
       E2 D1 EA E0 
       F1 F5 F5 00 
       00 00 00 E0 
       E1 E1 F6 D0 
       EA 00 E5 E5 
       E0 F5 00 00 
       00 00 00 E0 
       E1 E1 E5 00 
       EA 00 00 00 
       E0 00 00 00 
       00 00 00 00 
       E1 E1 EA 00 
       EA 00 00 00 
       00 00 00 00 
0421C2             0016*M 
0421C2             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0421C2 17 1B 21    0018*M     db 23,27,0x21
0421C5 10 00       0019*M     dw width ; in pixels
0421C7 10 00       0020*M     dw height ; in pixels
0421C9 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0421CA             0102*  	LOADBMPBUFFER2 BUF_SEEKER_013,16,16,"nurples/src/rgba2/seeker_013.rgba2"
0421CA             0001*M 
0421CA             0002*M     ; Clear buffer
0421CA 17 00 A0    0003*M     db 23,0,0xA0
0421CD 21 01       0004*M     dw bufferId
0421CF 02          0005*M     db 2
0421D0             0006*M 
0421D0 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0421D3 21 01       0008*M     dw bufferId
0421D5             0009*M 
0421D5             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0421D5 17 00 A0    0011*M     db 23,0,0xA0
0421D8 21 01       0012*M     dw bufferId
0421DA 00          0013*M     db 0
0421DB 00 01       0014*M 	dw width * height ; length of data in bytes
0421DD 00 00 00 00 0015*M     incbin file ; bitmap data
       00 F3 F2 00 
       DB DB DF DF 
       FF 00 00 00 
       00 00 00 E6 
       00 FB E2 E0 
       00 00 DB DA 
       EF 00 00 00 
       00 00 00 EA 
       00 F7 E2 E0 
       E5 F0 DB EA 
       F5 00 00 00 
       00 F2 E6 E6 
       00 E4 E2 E1 
       E5 E5 00 00 
       E0 E0 00 00 
       00 D1 D0 D1 
       D1 F5 F6 E2 
       E1 E0 E1 00 
       E1 E1 E1 00 
       DB 00 D0 D0 
       D1 E1 F9 F9 
       E9 E1 E1 E2 
       E2 E1 E1 F5 
       DB D6 FF D5 
       D0 E1 FD FE 
       FD F4 E1 E1 
       E2 E1 E1 E2 
       DF E7 F0 E5 
       D0 E4 FD FE 
       FD F8 FA F6 
       E1 E2 F6 E6 
       CB DB 00 E0 
       E0 E4 F8 F8 
       F8 F9 FB EB 
       E1 D1 C8 FA 
       EA E6 00 00 
       E1 E1 E0 F4 
       F5 F6 FB FB 
       E2 EA 00 00 
       00 E1 E0 00 
       E2 E1 E5 E6 
       E5 FA FF FB 
       00 EA 00 F5 
       00 E0 E1 E0 
       E1 F6 E2 D7 
       E5 EA FF FF 
       FA 00 00 00 
       00 00 E0 E1 
       E1 F7 E1 E2 
       E1 EA E5 E0 
       F5 00 00 00 
       00 00 E1 E1 
       E1 E6 00 FA 
       00 E5 E1 F5 
       F5 00 00 00 
       00 00 00 E1 
       E1 E5 00 EA 
       00 E6 00 E0 
       F5 00 00 00 
       00 00 00 E2 
       E6 EA 00 F5 
       00 E5 00 00 
       00 00 00 00 
0422DD             0016*M 
0422DD             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0422DD 17 1B 21    0018*M     db 23,27,0x21
0422E0 10 00       0019*M     dw width ; in pixels
0422E2 10 00       0020*M     dw height ; in pixels
0422E4 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0422E5             0103*  	LOADBMPBUFFER2 BUF_SEEKER_014,16,16,"nurples/src/rgba2/seeker_014.rgba2"
0422E5             0001*M 
0422E5             0002*M     ; Clear buffer
0422E5 17 00 A0    0003*M     db 23,0,0xA0
0422E8 22 01       0004*M     dw bufferId
0422EA 02          0005*M     db 2
0422EB             0006*M 
0422EB 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0422EE 22 01       0008*M     dw bufferId
0422F0             0009*M 
0422F0             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0422F0 17 00 A0    0011*M     db 23,0,0xA0
0422F3 22 01       0012*M     dw bufferId
0422F5 00          0013*M     db 0
0422F6 00 01       0014*M 	dw width * height ; length of data in bytes
0422F8 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 F3 
       E2 00 DB DB 
       DF FF 00 00 
       00 00 00 F3 
       00 00 FF F7 
       E1 00 E7 DF 
       DF EF 00 00 
       00 00 E2 E6 
       E6 00 E3 E2 
       E0 00 F0 EB 
       DB EB 00 00 
       00 00 D0 D0 
       D1 D0 E5 E2 
       E1 E5 E5 00 
       FA F5 00 00 
       DB DB 00 D0 
       D1 E1 F5 F6 
       E1 E1 E0 00 
       00 E0 E0 00 
       DB F1 00 E5 
       D0 D1 F5 FD 
       F9 E5 E1 D4 
       00 E1 E0 00 
       DF DB 00 E5 
       D0 E0 F9 FE 
       FE F8 E1 E1 
       E2 E1 E0 F5 
       DA DA 00 E0 
       D0 D4 FD FE 
       FD F8 F6 E1 
       F2 E1 E1 E1 
       FA E5 00 E0 
       E1 E1 F4 F8 
       FC F9 FA F6 
       E1 E2 E5 E2 
       00 E0 E1 F3 
       E1 E1 E4 F4 
       F5 FA FB E7 
       E1 D1 E5 FA 
       00 E1 E0 E1 
       E2 F6 D6 E6 
       F6 FA FB F6 
       E6 EA 00 FF 
       00 E0 E0 E1 
       FB E1 E2 E6 
       EA FF FF FF 
       00 EA E5 00 
       00 E1 E1 E1 
       F6 E1 E2 E1 
       EA EA FA FA 
       FA 00 00 00 
       00 00 E1 E1 
       E5 00 EA 00 
       E5 E0 E0 F5 
       00 F5 00 00 
       00 00 E2 EA 
       FE 00 EA 00 
       FA E0 F5 F5 
       00 00 00 00 
       00 00 00 FA 
       00 EA 00 00 
       00 D0 E0 00 
       00 00 00 00 
0423F8             0016*M 
0423F8             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0423F8 17 1B 21    0018*M     db 23,27,0x21
0423FB 10 00       0019*M     dw width ; in pixels
0423FD 10 00       0020*M     dw height ; in pixels
0423FF 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042400             0104*  	LOADBMPBUFFER2 BUF_SEEKER_015,16,16,"nurples/src/rgba2/seeker_015.rgba2"
042400             0001*M 
042400             0002*M     ; Clear buffer
042400 17 00 A0    0003*M     db 23,0,0xA0
042403 23 01       0004*M     dw bufferId
042405 02          0005*M     db 2
042406             0006*M 
042406 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042409 23 01       0008*M     dw bufferId
04240B             0009*M 
04240B             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04240B 17 00 A0    0011*M     db 23,0,0xA0
04240E 23 01       0012*M     dw bufferId
042410 00          0013*M     db 0
042411 00 01       0014*M 	dw width * height ; length of data in bytes
042413 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 E6 00 
       F7 F2 00 00 
       EB EB EF 00 
       C3 00 00 F2 
       E2 EA 00 FB 
       FB E1 00 DB 
       DB DB EF 00 
       D7 00 00 D0 
       D1 D5 00 E2 
       E2 E0 00 00 
       00 DF EF 00 
       DB DB D6 00 
       D0 D1 E1 E5 
       E2 E1 E5 F0 
       EB DB EF 00 
       DF DF 00 FF 
       D0 D1 E1 F5 
       F2 E1 E5 E1 
       00 FA F5 00 
       DB DB DB E5 
       E5 D0 E5 FD 
       F9 E5 E0 E0 
       00 E0 E0 00 
       EA EA 00 E1 
       E0 D0 F9 FD 
       FE FD E1 E5 
       00 E1 E0 00 
       F4 E5 00 E0 
       E1 E4 F8 FD 
       FE F8 E5 E1 
       E2 E1 E1 E5 
       E0 E0 00 E2 
       E1 E1 F4 F8 
       FC F8 FA F6 
       F6 E1 E1 F5 
       00 E1 E0 E2 
       E1 E5 E5 E5 
       F5 FA EB E6 
       E1 E2 E1 E2 
       E0 E0 E1 E1 
       F6 E2 D6 E5 
       FA FB FB E6 
       E1 E9 E5 E6 
       00 E1 E1 F6 
       E6 E1 E2 EA 
       FF FF FA E2 
       EA 00 FF FE 
       00 E1 E1 E5 
       00 E6 E2 EA 
       EE FA FA 00 
       EA 00 00 00 
       00 E2 FA 00 
       00 EA 00 E5 
       E1 E0 FA FA 
       00 00 00 00 
       00 00 EA 00 
       E6 00 00 FF 
       E0 F5 E0 00 
       00 00 00 00 
       00 EA 00 00 
       00 00 E5 00 
       E0 F5 F5 00 
       00 00 00 00 
042513             0016*M 
042513             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042513 17 1B 21    0018*M     db 23,27,0x21
042516 10 00       0019*M     dw width ; in pixels
042518 10 00       0020*M     dw height ; in pixels
04251A 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04251B             0105*  	LOADBMPBUFFER2 BUF_SEEKER_016,16,16,"nurples/src/rgba2/seeker_016.rgba2"
04251B             0001*M 
04251B             0002*M     ; Clear buffer
04251B 17 00 A0    0003*M     db 23,0,0xA0
04251E 24 01       0004*M     dw bufferId
042520 02          0005*M     db 2
042521             0006*M 
042521 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042524 24 01       0008*M     dw bufferId
042526             0009*M 
042526             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042526 17 00 A0    0011*M     db 23,0,0xA0
042529 24 01       0012*M     dw bufferId
04252B 00          0013*M     db 0
04252C 00 01       0014*M 	dw width * height ; length of data in bytes
04252E 00 C3 00 00 0015*M     incbin file ; bitmap data
       00 F3 00 00 
       00 00 F3 00 
       00 00 C3 00 
       00 D7 00 00 
       00 D1 E6 00 
       00 FB E2 00 
       00 00 EB 00 
       DB DB DB 00 
       00 D0 D1 00 
       00 E2 E1 00 
       00 DB DB EF 
       00 DF 00 00 
       00 D0 D1 E1 
       F5 E2 E1 00 
       00 00 DF 00 
       DB DB DB 00 
       E5 D0 D1 F5 
       F5 E2 E1 E5 
       00 DB DB EF 
       00 EA 00 00 
       E1 D0 E1 F9 
       FD F5 E1 E1 
       00 00 FA 00 
       00 E1 00 00 
       E1 D0 F9 FD 
       FE FD E1 E1 
       00 00 E1 00 
       00 E1 00 00 
       E1 E1 F8 FD 
       FE FC E1 E1 
       00 00 E1 00 
       00 E1 E1 E2 
       E1 E1 F4 F8 
       FC F8 F6 E1 
       E2 E1 E1 00 
       E1 E1 E1 00 
       F6 D5 E5 F5 
       F5 FA EA F6 
       00 E1 E1 F5 
       E1 E1 F6 F7 
       E1 D7 E6 F6 
       FA FB EB E1 
       E2 F6 E1 F6 
       E2 E1 E5 00 
       E1 E2 E5 EB 
       FF FB F6 E1 
       00 E5 E2 F6 
       00 EA 00 00 
       EA 00 EA EE 
       FF FF 00 EA 
       00 00 FA 00 
       00 00 00 00 
       00 00 E5 E1 
       F5 FA 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 E1 
       F5 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 E1 
       F5 00 00 00 
       00 00 00 00 
04262E             0016*M 
04262E             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04262E 17 1B 21    0018*M     db 23,27,0x21
042631 10 00       0019*M     dw width ; in pixels
042633 10 00       0020*M     dw height ; in pixels
042635 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042636             0106*  	LOADBMPBUFFER2 BUF_SEEKER_017,16,16,"nurples/src/rgba2/seeker_017.rgba2"
042636             0001*M 
042636             0002*M     ; Clear buffer
042636 17 00 A0    0003*M     db 23,0,0xA0
042639 25 01       0004*M     dw bufferId
04263B 02          0005*M     db 2
04263C             0006*M 
04263C 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04263F 25 01       0008*M     dw bufferId
042641             0009*M 
042641             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042641 17 00 A0    0011*M     db 23,0,0xA0
042644 25 01       0012*M     dw bufferId
042646 00          0013*M     db 0
042647 00 01       0014*M 	dw width * height ; length of data in bytes
042649 00 DB DB D7 0015*M     incbin file ; bitmap data
       00 00 E2 E2 
       00 E6 00 00 
       00 00 00 00 
       00 EB DB DB 
       DB 00 C0 E6 
       E6 00 FF F3 
       F2 00 00 C3 
       00 DB DF 00 
       00 00 D0 D1 
       D1 00 E7 E2 
       E1 00 00 E7 
       00 DB DB EB 
       F0 E5 D0 D1 
       E1 E1 E2 E0 
       00 D6 DB DB 
       00 F5 F5 00 
       E1 E5 D0 E1 
       F5 F6 E2 E4 
       FF 00 DF DF 
       00 E0 E0 00 
       E0 D0 D0 E5 
       FD F5 E1 E5 
       E5 DB DB DF 
       00 E1 E0 00 
       E1 D1 E4 FD 
       FE FD E5 E0 
       E1 00 EB EB 
       E0 E1 E1 E2 
       E1 E1 F4 FD 
       FE FD E1 E1 
       E0 00 E5 F5 
       E1 E1 E1 F2 
       E5 E5 F4 F8 
       FC F8 E5 E1 
       E2 00 E0 D0 
       E1 E1 F6 F6 
       E2 D6 E5 F5 
       F9 FA F6 E1 
       E2 E1 E0 00 
       E6 E5 E9 E1 
       E2 E6 E6 FA 
       FB EB E6 F1 
       E1 E1 E4 F5 
       EA FF 00 EA 
       E2 E5 EA FF 
       FB FB E2 E1 
       E2 E1 E1 00 
       00 00 00 EA 
       00 E5 EA FF 
       FF F6 E6 00 
       E5 E1 F2 00 
       00 00 00 00 
       E5 E5 E0 F5 
       FA 00 EA 00 
       00 FA E6 00 
       00 00 00 00 
       00 D0 E5 F5 
       FF 00 00 EA 
       00 FA 00 00 
       00 00 00 00 
       00 E0 F5 F5 
       00 FA 00 00 
       00 00 FA 00 
042749             0016*M 
042749             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042749 17 1B 21    0018*M     db 23,27,0x21
04274C 10 00       0019*M     dw width ; in pixels
04274E 10 00       0020*M     dw height ; in pixels
042750 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042751             0107*  	LOADBMPBUFFER2 BUF_SEEKER_018,16,16,"nurples/src/rgba2/seeker_018.rgba2"
042751             0001*M 
042751             0002*M     ; Clear buffer
042751 17 00 A0    0003*M     db 23,0,0xA0
042754 26 01       0004*M     dw bufferId
042756 02          0005*M     db 2
042757             0006*M 
042757 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04275A 26 01       0008*M     dw bufferId
04275C             0009*M 
04275C             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04275C 17 00 A0    0011*M     db 23,0,0xA0
04275F 26 01       0012*M     dw bufferId
042761 00          0013*M     db 0
042762 00 01       0014*M 	dw width * height ; length of data in bytes
042764 00 00 E7 DB 0015*M     incbin file ; bitmap data
       DB EB 00 D1 
       E2 00 00 00 
       00 00 00 00 
       00 00 DB DF 
       DF E7 00 D0 
       E5 E6 00 00 
       F2 00 00 00 
       00 00 DA DB 
       EB F0 00 D0 
       D1 D2 00 FB 
       F7 F2 00 00 
       00 00 E5 EA 
       00 E5 E5 D0 
       D1 E0 E1 E2 
       E1 E1 00 00 
       00 E0 E0 00 
       00 E0 D0 D1 
       E1 F5 F2 E2 
       E0 00 DB DB 
       00 E1 E0 00 
       E4 E1 D0 E5 
       F9 F9 E2 E1 
       E5 00 F1 DB 
       E1 E0 E1 E2 
       E1 E1 E4 FD 
       FE FE E5 E1 
       E5 00 DB DF 
       E1 E1 E1 E2 
       E5 E1 F4 FD 
       FE FD E5 E0 
       E0 00 EB DB 
       E1 E5 F6 F6 
       E6 E5 F4 F8 
       FC F8 E1 E1 
       E4 00 F5 FA 
       EA E5 F7 E1 
       E2 E6 E5 F5 
       F9 F9 E5 E1 
       F3 E0 E0 00 
       FA 00 EA E6 
       E2 E5 FA FA 
       FB EB F6 E2 
       E2 E1 E0 00 
       00 E5 EA 00 
       D5 EA FF FF 
       FB E7 E1 E2 
       E1 E0 E1 00 
       00 00 00 E5 
       E5 E5 FA FF 
       F6 E2 E1 E6 
       E1 E1 F5 00 
       00 00 D0 00 
       E1 E0 F5 FA 
       00 EA 00 E5 
       E1 E2 00 00 
       00 00 00 00 
       E0 F5 F1 FF 
       00 FA 00 FF 
       FA F6 00 00 
       00 00 00 00 
       00 F5 E1 00 
       00 00 FA 00 
       FE 00 00 00 
042864             0016*M 
042864             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042864 17 1B 21    0018*M     db 23,27,0x21
042867 10 00       0019*M     dw width ; in pixels
042869 10 00       0020*M     dw height ; in pixels
04286B 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04286C             0108*  	LOADBMPBUFFER2 BUF_SEEKER_019,16,16,"nurples/src/rgba2/seeker_019.rgba2"
04286C             0001*M 
04286C             0002*M     ; Clear buffer
04286C 17 00 A0    0003*M     db 23,0,0xA0
04286F 27 01       0004*M     dw bufferId
042871 02          0005*M     db 2
042872             0006*M 
042872 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042875 27 01       0008*M     dw bufferId
042877             0009*M 
042877             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042877 17 00 A0    0011*M     db 23,0,0xA0
04287A 27 01       0012*M     dw bufferId
04287C 00          0013*M     db 0
04287D 00 01       0014*M 	dw width * height ; length of data in bytes
04287F 00 00 00 EB 0015*M     incbin file ; bitmap data
       DF DF DB DB 
       00 E2 F3 00 
       00 00 00 00 
       00 00 00 DB 
       DA DB 00 00 
       D0 D1 E6 00 
       F7 00 00 00 
       00 00 00 E5 
       EA DB F0 E5 
       D0 D1 E6 00 
       FF 00 00 00 
       00 00 E0 E0 
       00 00 E5 E5 
       D1 D1 E0 00 
       FB F7 F3 00 
       00 E0 E1 E0 
       00 E1 E0 D0 
       D1 E1 F5 E2 
       E2 E1 E2 00 
       E1 E0 E1 E1 
       E2 E1 D0 E4 
       E5 F9 F6 E2 
       E1 E0 00 C6 
       E1 E1 E1 E1 
       E1 E1 E4 FD 
       FD FD F5 E1 
       E5 FF D6 DB 
       E5 F5 F6 F6 
       F6 E5 F4 F8 
       FE FE F9 E0 
       E5 F0 E7 DF 
       EA C4 D1 E1 
       D6 E6 E5 F8 
       FC FC E1 E1 
       E0 00 DB CB 
       00 00 EA E2 
       E2 E6 F5 F5 
       F9 F9 E1 E1 
       00 00 FA EB 
       F5 00 FE 00 
       E5 EA FA FB 
       FB E6 E1 E2 
       00 E0 E1 00 
       00 00 00 E5 
       EA FF FF FB 
       EB E6 F1 E2 
       E1 E1 E0 00 
       00 00 00 E5 
       E0 F5 FF F6 
       E2 E1 E2 E1 
       E1 E0 00 00 
       00 00 00 E0 
       F5 F5 FA 00 
       FA 00 E5 E1 
       E1 F5 00 00 
       00 00 00 F5 
       F5 00 FF 00 
       EA 00 E5 E2 
       F6 00 00 00 
       00 00 00 00 
       00 00 FA 00 
       F5 00 FF FA 
       F7 00 00 00 
04297F             0016*M 
04297F             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04297F 17 1B 21    0018*M     db 23,27,0x21
042982 10 00       0019*M     dw width ; in pixels
042984 10 00       0020*M     dw height ; in pixels
042986 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042987             0109*  	LOADBMPBUFFER2 BUF_SEEKER_020,16,16,"nurples/src/rgba2/seeker_020.rgba2"
042987             0001*M 
042987             0002*M     ; Clear buffer
042987 17 00 A0    0003*M     db 23,0,0xA0
04298A 28 01       0004*M     dw bufferId
04298C 02          0005*M     db 2
04298D             0006*M 
04298D 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042990 28 01       0008*M     dw bufferId
042992             0009*M 
042992             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042992 17 00 A0    0011*M     db 23,0,0xA0
042995 28 01       0012*M     dw bufferId
042997 00          0013*M     db 0
042998 00 01       0014*M 	dw width * height ; length of data in bytes
04299A 00 00 00 00 0015*M     incbin file ; bitmap data
       DB DB DF DB 
       EB 00 00 F3 
       00 00 00 00 
       00 00 00 00 
       F5 EA DB 00 
       00 00 C0 E2 
       00 00 00 00 
       00 00 00 E0 
       E0 F0 00 F0 
       E5 D0 D1 E6 
       EA E6 00 00 
       00 E0 E0 E1 
       E1 00 E1 E5 
       D5 D1 D1 D2 
       00 FF 00 00 
       E1 E1 E1 E1 
       E2 E4 E1 D0 
       D0 D1 E1 E4 
       E3 FB F7 F3 
       E1 E1 E1 E1 
       E2 E1 E1 D4 
       E5 E5 F5 F5 
       E2 F2 E1 00 
       EA E5 F6 F6 
       F6 E1 E4 F8 
       FD FD F9 E2 
       E1 E0 00 00 
       00 00 D0 E1 
       E2 E5 F4 F8 
       FE FE F9 E1 
       E5 E5 00 EB 
       EA EA EA E2 
       E7 E6 E5 F8 
       FD FC E5 E0 
       E5 F0 00 DB 
       00 00 00 D1 
       E5 EA F5 F5 
       F8 F5 E1 E1 
       E1 00 DB DF 
       00 00 E5 EA 
       EE FF FB FB 
       FA F6 E1 D4 
       00 F0 EB DB 
       00 00 E5 E0 
       EA FF FB FB 
       EA F6 E2 E2 
       E0 E0 F5 EF 
       00 E0 E0 F1 
       F5 FF FB E2 
       E1 E2 E1 E1 
       E1 E0 00 00 
       00 00 F5 F5 
       F6 FA 00 EA 
       D0 E6 F1 E1 
       E0 00 00 00 
       00 00 00 F5 
       00 00 00 EA 
       00 E5 E1 E1 
       F5 00 00 00 
       00 00 00 00 
       00 00 00 FA 
       00 FA E2 F6 
       00 00 00 00 
042A9A             0016*M 
042A9A             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042A9A 17 1B 21    0018*M     db 23,27,0x21
042A9D 10 00       0019*M     dw width ; in pixels
042A9F 10 00       0020*M     dw height ; in pixels
042AA1 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042AA2             0110*  	LOADBMPBUFFER2 BUF_SEEKER_021,16,16,"nurples/src/rgba2/seeker_021.rgba2"
042AA2             0001*M 
042AA2             0002*M     ; Clear buffer
042AA2 17 00 A0    0003*M     db 23,0,0xA0
042AA5 29 01       0004*M     dw bufferId
042AA7 02          0005*M     db 2
042AA8             0006*M 
042AA8 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042AAB 29 01       0008*M     dw bufferId
042AAD             0009*M 
042AAD             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042AAD 17 00 A0    0011*M     db 23,0,0xA0
042AB0 29 01       0012*M     dw bufferId
042AB2 00          0013*M     db 0
042AB3 00 01       0014*M 	dw width * height ; length of data in bytes
042AB5 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 EA CB 
       DF DB DB 00 
       00 00 00 00 
       00 00 00 00 
       E0 E1 E6 DB 
       E7 D6 00 D1 
       F2 00 00 00 
       00 00 E1 E0 
       E1 E0 00 00 
       F0 FF D0 D0 
       E6 00 00 00 
       E2 E1 E1 E1 
       E0 00 00 E0 
       E5 D5 D0 D1 
       E6 EA E6 00 
       E6 E1 E1 E1 
       E1 E2 E1 E0 
       D0 D0 D1 D1 
       00 00 00 00 
       EA E5 E6 F7 
       F6 E1 E1 E4 
       E4 E1 E1 F5 
       E4 F7 FB F3 
       00 00 00 E1 
       E2 E5 E0 F8 
       FD FD F9 F6 
       E2 E2 E2 F2 
       F5 EA FA E2 
       D7 E6 F4 F8 
       FE FE F9 E2 
       E1 E0 E0 00 
       00 00 00 E1 
       E5 E5 F5 F8 
       FD FD E9 E1 
       E5 E5 00 DB 
       E5 E6 E5 EA 
       EA FA F6 F9 
       F8 F4 E1 E0 
       E5 F0 00 DB 
       00 00 E1 E5 
       FF FF FB FB 
       FA E1 E1 E1 
       00 DB DB DF 
       00 E0 F5 E0 
       FF FB FB EB 
       F6 E1 E2 00 
       00 EA DA DF 
       00 F5 F5 F5 
       FA 00 E2 E1 
       E1 E2 E2 E1 
       E0 F5 EF FF 
       00 00 00 00 
       00 EA EA D1 
       E2 E1 E1 E1 
       E0 00 00 00 
       00 00 00 00 
       00 00 00 C8 
       F6 E1 E1 E1 
       00 00 00 00 
       00 00 00 00 
       00 F5 00 FA 
       E6 E2 F5 00 
       00 00 00 00 
042BB5             0016*M 
042BB5             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042BB5 17 1B 21    0018*M     db 23,27,0x21
042BB8 10 00       0019*M     dw width ; in pixels
042BBA 10 00       0020*M     dw height ; in pixels
042BBC 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042BBD             0111*  	LOADBMPBUFFER2 BUF_SEEKER_022,16,16,"nurples/src/rgba2/seeker_022.rgba2"
042BBD             0001*M 
042BBD             0002*M     ; Clear buffer
042BBD 17 00 A0    0003*M     db 23,0,0xA0
042BC0 2A 01       0004*M     dw bufferId
042BC2 02          0005*M     db 2
042BC3             0006*M 
042BC3 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042BC6 2A 01       0008*M     dw bufferId
042BC8             0009*M 
042BC8             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042BC8 17 00 A0    0011*M     db 23,0,0xA0
042BCB 2A 01       0012*M     dw bufferId
042BCD 00          0013*M     db 0
042BCE 00 01       0014*M 	dw width * height ; length of data in bytes
042BD0 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 FA 
       DA DF DB DB 
       00 00 00 00 
       00 00 00 E1 
       E0 E1 E0 E5 
       DA DB F1 DB 
       00 00 00 00 
       00 E2 E1 E1 
       E0 E0 E1 00 
       00 00 00 00 
       D0 E2 00 00 
       FA EA E1 E1 
       E1 E1 F3 E0 
       E0 E5 E5 D0 
       D0 E6 F3 00 
       00 FE E5 F6 
       FB E2 E1 E1 
       D0 D0 D0 D1 
       D1 E6 00 00 
       EA 00 00 E1 
       E1 F6 E1 E1 
       D4 E0 D1 E1 
       D0 00 00 00 
       00 EA EA E2 
       E2 D6 E4 F4 
       FD F9 F5 F5 
       E5 E3 FF 00 
       00 00 00 E1 
       E6 E6 F4 F8 
       FE FE FD F6 
       E2 E2 F7 F3 
       00 FA E5 EA 
       EA F6 F5 FC 
       FD FE F9 E1 
       E1 E0 E1 E2 
       D0 E0 E0 EA 
       FF FA FA F9 
       F8 F8 E5 E1 
       E5 00 00 00 
       E0 F5 E0 FA 
       FF FB FB FA 
       F6 E1 E1 E0 
       E5 F0 E7 DB 
       00 F5 F5 FA 
       FF F6 E7 F6 
       E1 E1 D4 00 
       00 EB DF DB 
       00 00 00 FA 
       00 E6 E1 E1 
       F2 E2 00 00 
       FA DB DF DF 
       00 00 F5 00 
       EA EA D1 E2 
       E1 E1 E1 E0 
       F5 EB EF FF 
       00 00 00 00 
       E5 00 E5 E5 
       E1 E0 E0 E0 
       00 00 00 00 
       00 00 00 00 
       00 FF FA E2 
       E1 F5 00 00 
       00 00 00 00 
042CD0             0016*M 
042CD0             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042CD0 17 1B 21    0018*M     db 23,27,0x21
042CD3 10 00       0019*M     dw width ; in pixels
042CD5 10 00       0020*M     dw height ; in pixels
042CD7 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042CD8             0112*  	LOADBMPBUFFER2 BUF_SEEKER_023,16,16,"nurples/src/rgba2/seeker_023.rgba2"
042CD8             0001*M 
042CD8             0002*M     ; Clear buffer
042CD8 17 00 A0    0003*M     db 23,0,0xA0
042CDB 2B 01       0004*M     dw bufferId
042CDD 02          0005*M     db 2
042CDE             0006*M 
042CDE 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042CE1 2B 01       0008*M     dw bufferId
042CE3             0009*M 
042CE3             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042CE3 17 00 A0    0011*M     db 23,0,0xA0
042CE6 2B 01       0012*M     dw bufferId
042CE8 00          0013*M     db 0
042CE9 00 01       0014*M 	dw width * height ; length of data in bytes
042CEB 00 00 00 00 0015*M     incbin file ; bitmap data
       00 E0 00 E0 
       F4 EA DB DF 
       DB D7 C3 00 
       EA 00 E2 E1 
       E1 E0 E1 E0 
       E5 EA DB DF 
       DB 00 00 00 
       00 EA FA E1 
       E1 E1 E0 00 
       00 00 DB 00 
       D6 00 00 00 
       00 00 00 E5 
       F6 E1 E2 E2 
       E0 E1 E5 FF 
       00 D0 F2 00 
       00 E6 00 00 
       E6 F6 E1 E1 
       E1 E0 E5 D0 
       D0 D1 E2 00 
       00 00 EA E6 
       E1 E2 E5 E1 
       E4 D0 D0 D1 
       D1 D5 EA 00 
       E5 00 00 E2 
       E2 D6 E5 F4 
       F8 F9 E5 E1 
       E1 00 00 E6 
       00 FF E5 EA 
       EA E5 E5 F8 
       FD FD FD F5 
       E5 E2 FB 00 
       E0 E0 E1 EE 
       FF FA F5 FC 
       FE FE F9 F2 
       E2 E2 FB F7 
       F5 F5 E0 FA 
       FF FB FA F8 
       F8 FD E5 E1 
       E1 E0 E1 F2 
       F5 E0 FA FA 
       FA FB EB FA 
       E5 E1 E0 E5 
       E5 00 00 00 
       00 00 FA 00 
       E2 E6 E6 F6 
       E1 E5 E0 E1 
       F0 00 DB 00 
       00 00 00 EA 
       EA E1 E1 F6 
       E2 00 00 00 
       EB 00 DB EB 
       00 00 00 00 
       00 E9 E2 E1 
       E1 E1 E0 FA 
       DB DF DB EB 
       00 00 00 00 
       FF E5 E1 E1 
       E1 E0 E0 F5 
       EF EF EF EF 
       00 00 00 00 
       FE E6 E2 F5 
       E5 00 00 00 
       00 00 00 00 
042DEB             0016*M 
042DEB             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042DEB 17 1B 21    0018*M     db 23,27,0x21
042DEE 10 00       0019*M     dw width ; in pixels
042DF0 10 00       0020*M     dw height ; in pixels
042DF2 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042DF3             0113*  	LOADBMPBUFFER2 BUF_SEEKER_024,16,16,"nurples/src/rgba2/seeker_024.rgba2"
042DF3             0001*M 
042DF3             0002*M     ; Clear buffer
042DF3 17 00 A0    0003*M     db 23,0,0xA0
042DF6 2C 01       0004*M     dw bufferId
042DF8 02          0005*M     db 2
042DF9             0006*M 
042DF9 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042DFC 2C 01       0008*M     dw bufferId
042DFE             0009*M 
042DFE             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042DFE 17 00 A0    0011*M     db 23,0,0xA0
042E01 2C 01       0012*M     dw bufferId
042E03 00          0013*M     db 0
042E04 00 01       0014*M 	dw width * height ; length of data in bytes
042E06 00 00 00 00 0015*M     incbin file ; bitmap data
       E2 E1 E1 00 
       00 00 00 DB 
       00 DB 00 00 
       00 00 00 EA 
       E1 E1 E1 E1 
       E1 E1 EA DB 
       DF DB D7 C3 
       00 00 00 00 
       E5 F6 E1 E1 
       00 00 00 DB 
       00 DB 00 00 
       00 00 00 00 
       00 F7 00 E2 
       00 00 00 00 
       00 00 00 00 
       00 00 00 EA 
       E1 E1 F6 E1 
       E1 E1 E1 E5 
       00 00 00 00 
       00 00 00 00 
       E2 D7 D5 E1 
       E1 D0 D0 D0 
       D0 D0 D1 F3 
       00 00 E5 EA 
       E5 E6 E5 F4 
       F8 F9 E1 D1 
       D1 D1 E6 00 
       E1 E1 E1 EE 
       EB F6 F5 F8 
       FD FD F9 F5 
       E1 00 00 00 
       F5 F5 F5 FF 
       FF FA F5 FC 
       FE FE FD F5 
       F5 00 00 00 
       00 00 FA FF 
       FB FB FA F8 
       FC FD F5 E2 
       E2 E2 FB 00 
       00 00 00 00 
       F6 EB EA F6 
       E1 E1 E1 E1 
       E1 E1 E2 F3 
       00 00 00 EA 
       E1 E1 F6 E1 
       E1 E1 E1 E5 
       00 00 00 00 
       00 00 00 00 
       00 E2 00 E2 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E5 F6 E1 E1 
       00 00 00 DB 
       00 DB 00 00 
       00 00 00 FA 
       E2 E1 E1 E1 
       E1 E1 FA DB 
       DF DB EB C3 
       00 00 00 00 
       F6 F6 F5 00 
       00 00 00 EF 
       00 EF 00 00 
042F06             0016*M 
042F06             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042F06 17 1B 21    0018*M     db 23,27,0x21
042F09 10 00       0019*M     dw width ; in pixels
042F0B 10 00       0020*M     dw height ; in pixels
042F0D 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042F0E             0114*  	LOADBMPBUFFER2 BUF_SEEKER_025,16,16,"nurples/src/rgba2/seeker_025.rgba2"
042F0E             0001*M 
042F0E             0002*M     ; Clear buffer
042F0E 17 00 A0    0003*M     db 23,0,0xA0
042F11 2D 01       0004*M     dw bufferId
042F13 02          0005*M     db 2
042F14             0006*M 
042F14 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042F17 2D 01       0008*M     dw bufferId
042F19             0009*M 
042F19             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042F19 17 00 A0    0011*M     db 23,0,0xA0
042F1C 2D 01       0012*M     dw bufferId
042F1E 00          0013*M     db 0
042F1F 00 01       0014*M 	dw width * height ; length of data in bytes
042F21 00 00 00 00 0015*M     incbin file ; bitmap data
       EA E6 E1 E1 
       E0 00 00 00 
       00 00 00 00 
       00 00 00 00 
       FF E5 E1 E1 
       E1 E1 E0 F5 
       DB DB EB DB 
       00 00 00 00 
       00 E9 F6 E1 
       E1 E0 E0 F5 
       DB DF DB DB 
       00 00 00 EA 
       EA E1 F6 F2 
       E2 00 00 00 
       EB 00 DB D7 
       00 00 E5 00 
       E2 E2 E2 E5 
       E1 E1 E0 E1 
       F0 00 DB 00 
       E0 D0 E5 E5 
       E5 E6 D6 E5 
       E1 D1 D0 E5 
       E5 00 00 00 
       F5 E5 E0 EA 
       EA E6 E5 F4 
       F4 E4 D0 D0 
       D0 D0 C0 E2 
       F5 F5 F5 FF 
       FF FA F5 F8 
       FD FD E5 E1 
       D1 D1 E6 E2 
       00 FF FA FF 
       FB FB F9 FC 
       FE FE FD F5 
       E1 D1 E6 00 
       FA 00 00 F6 
       FB EB FA F8 
       FD FD F5 F6 
       E1 00 00 E6 
       00 00 EA E6 
       E2 E6 F6 E5 
       E1 E5 E1 E2 
       E2 E7 FF 00 
       00 EA 00 00 
       E1 F1 E1 E1 
       E1 E0 E5 E4 
       E0 E2 F3 00 
       00 00 00 E5 
       E2 E1 E2 E2 
       E0 E1 E5 FF 
       00 E1 F2 00 
       00 FA FA E1 
       E1 E1 E1 00 
       00 00 DB 00 
       D6 00 00 00 
       FA 00 E6 F2 
       E1 E4 E0 E0 
       E5 EB DB DF 
       DB 00 00 00 
       00 00 00 00 
       00 F5 00 D0 
       F5 EB DF DF 
       DB E7 C3 00 
043021             0016*M 
043021             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043021 17 1B 21    0018*M     db 23,27,0x21
043024 10 00       0019*M     dw width ; in pixels
043026 10 00       0020*M     dw height ; in pixels
043028 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043029             0115*  	LOADBMPBUFFER2 BUF_SEEKER_026,16,16,"nurples/src/rgba2/seeker_026.rgba2"
043029             0001*M 
043029             0002*M     ; Clear buffer
043029 17 00 A0    0003*M     db 23,0,0xA0
04302C 2E 01       0004*M     dw bufferId
04302E 02          0005*M     db 2
04302F             0006*M 
04302F 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043032 2E 01       0008*M     dw bufferId
043034             0009*M 
043034             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043034 17 00 A0    0011*M     db 23,0,0xA0
043037 2E 01       0012*M     dw bufferId
043039 00          0013*M     db 0
04303A 00 01       0014*M 	dw width * height ; length of data in bytes
04303C 00 00 00 00 0015*M     incbin file ; bitmap data
       00 FA EA E1 
       E1 E1 00 00 
       00 00 00 00 
       00 00 00 00 
       E5 00 E5 E5 
       E1 E0 E1 E0 
       00 00 00 00 
       00 00 D0 00 
       EA EA F7 F6 
       E1 E1 E0 E0 
       E5 DA DB E7 
       00 00 00 E5 
       00 E6 E1 F6 
       E2 E2 00 00 
       EA DB DF DB 
       00 E0 E1 E5 
       D5 E2 E2 E6 
       E5 E1 E4 00 
       00 EB DF DB 
       F5 F5 E0 E5 
       EA E5 E6 E5 
       E1 E1 E1 E0 
       E5 F0 E7 EB 
       E1 F1 F5 FA 
       FF FA E5 F4 
       F4 E4 D0 D0 
       E5 00 00 00 
       00 FF FA FF 
       FF FA F5 F8 
       FD FD E5 D1 
       D0 D0 D0 D1 
       00 00 00 F6 
       FB FB F9 FC 
       FE FE F9 E1 
       D1 D1 E5 E2 
       00 FA EA E2 
       E7 EB F9 F8 
       FD FE F9 F5 
       E0 D2 E6 00 
       FA 00 00 E1 
       E1 F6 E5 E1 
       E5 E5 E2 F2 
       E1 00 00 00 
       00 FF E5 E6 
       E2 E2 E1 E1 
       E0 E1 E1 E2 
       E2 FB 00 00 
       FE FA E1 E1 
       E1 E2 F3 E4 
       E0 E5 E5 E0 
       E1 F7 F2 00 
       00 F6 E2 E1 
       E0 E1 E0 00 
       00 00 00 00 
       E1 F2 00 00 
       00 00 00 F5 
       E1 E0 E0 F5 
       EB DB F1 DB 
       00 00 00 00 
       00 00 00 00 
       00 00 00 FA 
       DB DF DB DB 
       00 00 00 00 
04313C             0016*M 
04313C             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04313C 17 1B 21    0018*M     db 23,27,0x21
04313F 10 00       0019*M     dw width ; in pixels
043141 10 00       0020*M     dw height ; in pixels
043143 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043144             0116*  	LOADBMPBUFFER2 BUF_SEEKER_027,16,16,"nurples/src/rgba2/seeker_027.rgba2"
043144             0001*M 
043144             0002*M     ; Clear buffer
043144 17 00 A0    0003*M     db 23,0,0xA0
043147 2F 01       0004*M     dw bufferId
043149 02          0005*M     db 2
04314A             0006*M 
04314A 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04314D 2F 01       0008*M     dw bufferId
04314F             0009*M 
04314F             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04314F 17 00 A0    0011*M     db 23,0,0xA0
043152 2F 01       0012*M     dw bufferId
043154 00          0013*M     db 0
043155 00 01       0014*M 	dw width * height ; length of data in bytes
043157 00 00 00 00 0015*M     incbin file ; bitmap data
       00 F5 00 EA 
       E5 E1 E1 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 C4 
       F5 E1 E0 E0 
       00 00 00 00 
       00 00 00 00 
       00 FE EA D1 
       F6 E1 E1 E1 
       E0 00 00 00 
       00 F5 E0 E5 
       E5 00 E2 E1 
       F6 E1 E1 E0 
       E0 E5 DB EB 
       00 F5 F5 E0 
       EA E5 E2 D6 
       F6 E1 E2 00 
       00 EA DA DF 
       00 00 F5 F5 
       FF EA E6 E6 
       E5 E1 E1 E1 
       00 DB DB DF 
       FA FF FA FF 
       FF FA F5 E5 
       F4 E4 D0 E0 
       E5 F0 00 DB 
       00 00 00 F6 
       FB FB F5 F8 
       F8 FD E4 D0 
       E5 E5 00 DB 
       F5 EA FA E2 
       EB FB F9 FC 
       FE FD E5 D1 
       D1 D0 D0 00 
       00 00 00 E1 
       E6 E6 F9 FC 
       FE FD F9 E1 
       D1 D1 D1 E2 
       FF E5 E5 E2 
       F1 E1 E1 E1 
       F9 F5 F6 F5 
       E0 E6 E6 F3 
       FA E2 E1 E1 
       E2 E2 E1 E1 
       E0 E1 E2 E2 
       00 00 00 00 
       F7 F6 E1 E1 
       E1 00 00 E0 
       E5 E5 E1 E2 
       FB FF F7 00 
       00 00 F5 E0 
       E1 E0 00 00 
       F0 FF E0 E1 
       F7 00 00 00 
       00 00 00 00 
       E0 E1 FA DB 
       E7 D6 00 E2 
       F3 00 00 00 
       00 00 00 00 
       00 00 EB CB 
       DF DB C6 00 
       00 00 00 00 
043257             0016*M 
043257             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043257 17 1B 21    0018*M     db 23,27,0x21
04325A 10 00       0019*M     dw width ; in pixels
04325C 10 00       0020*M     dw height ; in pixels
04325E 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04325F             0117*  	LOADBMPBUFFER2 BUF_SEEKER_028,16,16,"nurples/src/rgba2/seeker_028.rgba2"
04325F             0001*M 
04325F             0002*M     ; Clear buffer
04325F 17 00 A0    0003*M     db 23,0,0xA0
043262 30 01       0004*M     dw bufferId
043264 02          0005*M     db 2
043265             0006*M 
043265 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043268 30 01       0008*M     dw bufferId
04326A             0009*M 
04326A             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04326A 17 00 A0    0011*M     db 23,0,0xA0
04326D 30 01       0012*M     dw bufferId
04326F 00          0013*M     db 0
043270 00 01       0014*M 	dw width * height ; length of data in bytes
043272 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 EA 
       00 EA E1 E1 
       00 00 00 00 
       00 00 00 E0 
       00 00 00 EA 
       00 E5 E1 E1 
       E0 00 00 00 
       00 00 F5 E0 
       E5 E5 00 EA 
       D0 F6 E1 E1 
       E0 00 00 00 
       00 F5 F5 F1 
       E0 EA D1 E2 
       E1 F6 E1 E1 
       E1 E0 00 00 
       00 00 F6 F5 
       EA EE E5 E7 
       E2 F6 E2 E2 
       E1 E0 F5 DB 
       00 00 FA FF 
       FF FF EA E6 
       E5 E1 E1 E4 
       00 F0 EA DB 
       00 00 00 FB 
       FB FB F5 E5 
       F4 E4 E1 E1 
       E1 00 DB DF 
       FA EA EA E2 
       FB FB F5 F8 
       F8 F8 D4 D0 
       E5 F0 00 DB 
       00 00 D0 E1 
       EA FA F8 FD 
       FE FD E5 D0 
       D5 E5 00 EB 
       FA E5 E6 E2 
       F6 F6 F5 FC 
       FE FD E5 D1 
       D1 D0 00 00 
       E2 E1 F1 E1 
       E2 E1 E1 E5 
       F9 F9 F5 E1 
       D1 D1 C0 00 
       F6 E1 E1 E1 
       E2 D4 E1 E0 
       E1 E2 F5 E4 
       D2 E6 E2 F3 
       00 F5 E0 E1 
       E0 00 E1 E5 
       E5 E1 E2 E3 
       00 EA 00 00 
       00 00 00 E0 
       E0 F0 00 F0 
       E5 E0 F2 FB 
       FF E6 00 00 
       00 00 00 00 
       F5 EB DB 00 
       00 00 E1 F7 
       00 00 00 00 
       00 00 00 00 
       EF DB DF DB 
       EB 00 00 F3 
       00 00 00 00 
043372             0016*M 
043372             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043372 17 1B 21    0018*M     db 23,27,0x21
043375 10 00       0019*M     dw width ; in pixels
043377 10 00       0020*M     dw height ; in pixels
043379 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04337A             0118*  	LOADBMPBUFFER2 BUF_SEEKER_029,16,16,"nurples/src/rgba2/seeker_029.rgba2"
04337A             0001*M 
04337A             0002*M     ; Clear buffer
04337A 17 00 A0    0003*M     db 23,0,0xA0
04337D 31 01       0004*M     dw bufferId
04337F 02          0005*M     db 2
043380             0006*M 
043380 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043383 31 01       0008*M     dw bufferId
043385             0009*M 
043385             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043385 17 00 A0    0011*M     db 23,0,0xA0
043388 31 01       0012*M     dw bufferId
04338A 00          0013*M     db 0
04338B 00 01       0014*M 	dw width * height ; length of data in bytes
04338D 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 E5 00 
       F5 00 EA E6 
       E2 00 00 00 
       00 00 00 F5 
       E0 00 E6 00 
       EA 00 E5 E1 
       E1 00 00 00 
       00 00 00 F5 
       F5 E1 E5 00 
       FA 00 E6 E1 
       E1 E1 00 00 
       00 00 00 F5 
       E0 E5 EA E1 
       E2 E1 F7 E1 
       E1 E0 00 00 
       00 00 00 FA 
       FF FF EA E5 
       D7 E2 F6 E1 
       E0 E1 E0 00 
       F5 00 EA 00 
       FB FF FA E5 
       E6 E5 E1 E2 
       00 E0 E1 00 
       00 00 EA E2 
       FB FB F6 F5 
       F4 E0 E1 E1 
       00 00 E6 EA 
       FA C8 D1 E1 
       EB FB F9 F8 
       F8 F8 E4 E0 
       E0 00 DB CB 
       E6 F6 E2 E1 
       F6 FA F8 FD 
       FE FD E4 D0 
       E5 F0 E7 DF 
       E2 E1 E1 E2 
       E1 E1 F4 FD 
       FE FD E1 D0 
       D5 FF D6 DB 
       F5 E1 E1 E2 
       E2 E1 E1 E9 
       F9 F9 E1 D1 
       D0 D0 00 DB 
       00 E1 E1 E1 
       00 E1 E0 E1 
       E2 F6 F5 D1 
       D1 D0 D1 00 
       00 00 E0 E0 
       00 00 E5 E5 
       E1 E2 E4 00 
       E6 E6 F2 00 
       00 00 00 F5 
       EA DB F0 E5 
       E0 E2 F7 00 
       EA 00 00 00 
       00 00 00 EF 
       DA DB 00 00 
       E0 E2 FB 00 
       E6 00 00 00 
       00 00 00 FF 
       DF DF DB DB 
       00 F2 F3 00 
       00 00 00 00 
04348D             0016*M 
04348D             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04348D 17 1B 21    0018*M     db 23,27,0x21
043490 10 00       0019*M     dw width ; in pixels
043492 10 00       0020*M     dw height ; in pixels
043494 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043495             0119*  	LOADBMPBUFFER2 BUF_SEEKER_030,16,16,"nurples/src/rgba2/seeker_030.rgba2"
043495             0001*M 
043495             0002*M     ; Clear buffer
043495 17 00 A0    0003*M     db 23,0,0xA0
043498 32 01       0004*M     dw bufferId
04349A 02          0005*M     db 2
04349B             0006*M 
04349B 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04349E 32 01       0008*M     dw bufferId
0434A0             0009*M 
0434A0             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0434A0 17 00 A0    0011*M     db 23,0,0xA0
0434A3 32 01       0012*M     dw bufferId
0434A5 00          0013*M     db 0
0434A6 00 01       0014*M 	dw width * height ; length of data in bytes
0434A8 00 00 00 00 0015*M     incbin file ; bitmap data
       00 E0 D0 00 
       00 00 EA 00 
       FA 00 00 00 
       00 00 00 00 
       F5 F5 E0 FA 
       00 EA 00 FE 
       EA E2 00 00 
       00 00 F5 00 
       F5 E0 E0 E5 
       00 EA 00 E5 
       E1 E1 00 00 
       00 00 00 FA 
       FA FA EA EA 
       E1 E2 E1 F6 
       E1 E1 E1 00 
       00 E5 EA 00 
       FF FF FF EA 
       E6 E2 E1 FB 
       E1 E0 E0 00 
       FF 00 EA E6 
       F6 FB FA F6 
       E6 D6 F6 E2 
       E1 E0 E1 00 
       FA E5 D1 E1 
       E7 FB FA F5 
       F4 E4 E1 E1 
       F3 E1 E0 00 
       E2 E5 E2 E1 
       F6 FA F9 FC 
       F8 F4 E1 E1 
       E0 00 E5 FA 
       E1 E1 E1 F2 
       E1 F6 F8 FD 
       FE FD D4 D0 
       E0 00 DA DA 
       F5 E0 E1 E2 
       E1 E1 F8 FE 
       FE F9 E0 D0 
       E5 00 DB DF 
       00 E0 E1 00 
       D4 E1 E5 F9 
       FD F5 D1 D0 
       E5 00 F1 DB 
       00 E0 E0 00 
       00 E0 E1 E1 
       F6 F5 E1 D1 
       D0 00 DB DB 
       00 00 F5 FA 
       00 E5 E5 E1 
       E2 E5 D0 D1 
       D0 D0 00 00 
       00 00 EB DB 
       EB F0 00 E0 
       E2 E3 00 E6 
       E6 E2 00 00 
       00 00 EF DF 
       DF E7 00 E1 
       F7 FF 00 00 
       F3 00 00 00 
       00 00 FF DF 
       DB DB 00 E2 
       F3 00 00 00 
       00 00 00 00 
0435A8             0016*M 
0435A8             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0435A8 17 1B 21    0018*M     db 23,27,0x21
0435AB 10 00       0019*M     dw width ; in pixels
0435AD 10 00       0020*M     dw height ; in pixels
0435AF 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0435B0             0120*  	LOADBMPBUFFER2 BUF_SEEKER_031,16,16,"nurples/src/rgba2/seeker_031.rgba2"
0435B0             0001*M 
0435B0             0002*M     ; Clear buffer
0435B0 17 00 A0    0003*M     db 23,0,0xA0
0435B3 33 01       0004*M     dw bufferId
0435B5 02          0005*M     db 2
0435B6             0006*M 
0435B6 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0435B9 33 01       0008*M     dw bufferId
0435BB             0009*M 
0435BB             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0435BB 17 00 A0    0011*M     db 23,0,0xA0
0435BE 33 01       0012*M     dw bufferId
0435C0 00          0013*M     db 0
0435C1 00 01       0014*M 	dw width * height ; length of data in bytes
0435C3 00 00 00 00 0015*M     incbin file ; bitmap data
       00 F5 F5 E0 
       00 E5 00 00 
       00 00 EA 00 
       00 00 00 00 
       00 E0 F5 E0 
       FF 00 00 E6 
       00 EA 00 00 
       00 00 00 00 
       FA FA E0 E1 
       E5 00 EA 00 
       00 FA E2 00 
       00 00 00 EA 
       00 FA FA EE 
       EA E2 E6 00 
       E5 E1 E1 00 
       FE FF 00 EA 
       E2 FA FF FF 
       EA E2 E1 E6 
       F6 E1 E1 00 
       E6 E5 E9 E1 
       E6 FB FB FA 
       E5 D6 E2 F6 
       E1 E1 E0 E0 
       E2 E1 E2 E1 
       E6 EB FA F5 
       E5 E5 E5 E1 
       E2 E0 E1 00 
       F5 E1 E1 F6 
       F6 FA F8 FC 
       F8 F4 E1 E1 
       E2 00 E0 E0 
       E5 E1 E1 E2 
       E1 E5 F8 FE 
       FD F8 E4 E1 
       E0 00 E5 F4 
       00 E0 E1 00 
       E5 E1 FD FE 
       FD F9 D0 E0 
       E1 00 EA EA 
       00 E0 E0 00 
       E0 E0 E5 F9 
       FD E5 D0 E5 
       E5 DB DB DB 
       00 F5 FA 00 
       E1 E5 E1 F2 
       F5 E1 D1 D0 
       FF 00 DF DF 
       00 EF DB EB 
       F0 E5 E1 E2 
       E5 E1 D1 D0 
       00 D6 DB DB 
       00 EF DF 00 
       00 00 E0 E2 
       E2 00 D5 D1 
       D0 00 00 D7 
       00 EF DB DB 
       DB 00 E1 FB 
       FB 00 EA E2 
       F2 00 00 C3 
       00 EF EB EB 
       00 00 F2 F7 
       00 E6 00 00 
       00 00 00 00 
0436C3             0016*M 
0436C3             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0436C3 17 1B 21    0018*M     db 23,27,0x21
0436C6 10 00       0019*M     dw width ; in pixels
0436C8 10 00       0020*M     dw height ; in pixels
0436CA 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0436CB             0121*  	LOADBMPBUFFER2 BUF_SHIP_0L,16,16,"nurples/src/rgba2/ship_0l.rgba2"
0436CB             0001*M 
0436CB             0002*M     ; Clear buffer
0436CB 17 00 A0    0003*M     db 23,0,0xA0
0436CE 34 01       0004*M     dw bufferId
0436D0 02          0005*M     db 2
0436D1             0006*M 
0436D1 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0436D4 34 01       0008*M     dw bufferId
0436D6             0009*M 
0436D6             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0436D6 17 00 A0    0011*M     db 23,0,0xA0
0436D9 34 01       0012*M     dw bufferId
0436DB 00          0013*M     db 0
0436DC 00 01       0014*M 	dw width * height ; length of data in bytes
0436DE 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 C6 
       C7 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C6 CA 
       CB C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 D5 E5 
       CB C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 D5 FD FE 
       E5 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 D5 FD FE 
       E5 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 D5 E5 
       CB C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 C7 C6 CA 
       CB C7 DB 00 
       00 00 00 00 
       00 00 C7 00 
       C7 CA C6 CA 
       CB C7 CB DB 
       00 00 C7 00 
       00 00 C7 00 
       CA CA C6 CA 
       CB C7 CB CB 
       DB 00 C7 00 
       00 00 C7 C7 
       CA C6 C6 CA 
       CB C7 C7 CB 
       CB DB C7 00 
       00 00 C7 CA 
       C6 C6 C6 CA 
       CB C7 C7 C7 
       CB CB C7 00 
       00 00 C7 CA 
       C6 CA C6 CA 
       CB C7 CB C7 
       C7 CB C7 00 
       00 00 C7 CA 
       C7 C7 C6 CA 
       CB C7 DB DB 
       C7 CB C7 00 
       00 00 C7 00 
       00 00 C6 00 
       00 C7 00 00 
       DB CB C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       DB DB C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
0437DE             0016*M 
0437DE             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0437DE 17 1B 21    0018*M     db 23,27,0x21
0437E1 10 00       0019*M     dw width ; in pixels
0437E3 10 00       0020*M     dw height ; in pixels
0437E5 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0437E6             0122*  	LOADBMPBUFFER2 BUF_SHIP_1C,16,16,"nurples/src/rgba2/ship_1c.rgba2"
0437E6             0001*M 
0437E6             0002*M     ; Clear buffer
0437E6 17 00 A0    0003*M     db 23,0,0xA0
0437E9 35 01       0004*M     dw bufferId
0437EB 02          0005*M     db 2
0437EC             0006*M 
0437EC 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0437EF 35 01       0008*M     dw bufferId
0437F1             0009*M 
0437F1             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0437F1 17 00 A0    0011*M     db 23,0,0xA0
0437F4 35 01       0012*M     dw bufferId
0437F6 00          0013*M     db 0
0437F7 00 01       0014*M 	dw width * height ; length of data in bytes
0437F9 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 DB 
       C7 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB CB 
       CB C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB E9 
       E5 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 E9 FE 
       FE E5 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 E9 FE 
       FE E5 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB E9 
       E5 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 DB DB CB 
       CB C7 DB 00 
       00 00 00 00 
       00 DB 00 00 
       DB CB DB CB 
       CB C7 CB DB 
       00 00 C7 00 
       00 DB 00 DB 
       CB CB DB CB 
       CB C7 CB CB 
       DB 00 C7 00 
       00 DB DB CB 
       CB C7 DB CB 
       CB C7 C7 CB 
       CB DB C7 00 
       00 DB CB CB 
       C7 C7 DB CB 
       CB C7 C7 C7 
       CB CB C7 00 
       00 DB CB C7 
       C7 CB DB CB 
       CB C7 CB C7 
       C7 CB C7 00 
       00 DB CB C7 
       DB DB DB CB 
       CB C7 DB DB 
       C7 CB C7 00 
       00 DB DB DB 
       00 00 DB 00 
       00 C7 00 00 
       DB DB C7 00 
       00 DB 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0438F9             0016*M 
0438F9             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0438F9 17 1B 21    0018*M     db 23,27,0x21
0438FC 10 00       0019*M     dw width ; in pixels
0438FE 10 00       0020*M     dw height ; in pixels
043900 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043901             0123*  	LOADBMPBUFFER2 BUF_SHIP_2R,16,16,"nurples/src/rgba2/ship_2r.rgba2"
043901             0001*M 
043901             0002*M     ; Clear buffer
043901 17 00 A0    0003*M     db 23,0,0xA0
043904 36 01       0004*M     dw bufferId
043906 02          0005*M     db 2
043907             0006*M 
043907 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04390A 36 01       0008*M     dw bufferId
04390C             0009*M 
04390C             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04390C 17 00 A0    0011*M     db 23,0,0xA0
04390F 36 01       0012*M     dw bufferId
043911 00          0013*M     db 0
043912 00 01       0014*M 	dw width * height ; length of data in bytes
043914 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 DB 
       C6 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB CB 
       CB C6 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB CB 
       E5 D5 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB E5 
       FE FD D5 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB E5 
       FE FD D5 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB CB 
       E5 D5 00 00 
       00 00 00 00 
       00 00 00 00 
       00 DB DB CB 
       CB C6 C7 00 
       00 00 00 00 
       00 DB 00 00 
       DB CB DB CB 
       CB C6 CA C7 
       00 C6 00 00 
       00 DB 00 DB 
       CB CB DB CB 
       CB C6 CA CA 
       00 C6 00 00 
       00 DB DB CB 
       CB C7 DB CB 
       CB C6 C6 CA 
       C7 C6 00 00 
       00 DB CB CB 
       C7 C7 DB CB 
       CB C6 C6 C6 
       CA C6 00 00 
       00 DB CB C7 
       C7 CB DB CB 
       CB C6 CA C6 
       CA C6 00 00 
       00 DB CB C7 
       DB DB DB CB 
       CB C6 C7 C7 
       CA C6 00 00 
       00 DB CB DB 
       00 00 DB 00 
       00 C6 00 00 
       00 C6 00 00 
       00 DB DB DB 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 DB 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043A14             0016*M 
043A14             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043A14 17 1B 21    0018*M     db 23,27,0x21
043A17 10 00       0019*M     dw width ; in pixels
043A19 10 00       0020*M     dw height ; in pixels
043A1B 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043A1C             0124*  	LOADBMPBUFFER2 BUF_SHIP_SMALL,8,8,"nurples/src/rgba2/ship_small.rgba2"
043A1C             0001*M 
043A1C             0002*M     ; Clear buffer
043A1C 17 00 A0    0003*M     db 23,0,0xA0
043A1F 37 01       0004*M     dw bufferId
043A21 02          0005*M     db 2
043A22             0006*M 
043A22 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043A25 37 01       0008*M     dw bufferId
043A27             0009*M 
043A27             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043A27 17 00 A0    0011*M     db 23,0,0xA0
043A2A 37 01       0012*M     dw bufferId
043A2C 00          0013*M     db 0
043A2D 40 00       0014*M 	dw width * height ; length of data in bytes
043A2F 00 00 00 CB 0015*M     incbin file ; bitmap data
       CA 00 00 00 
       00 00 00 FE 
       FD 00 00 00 
       00 00 00 FE 
       FD 00 00 00 
       CB 00 00 CB 
       CA 00 00 CA 
       CB 00 CB C7 
       C6 CB 00 CA 
       CB CB C7 CB 
       CA C6 CB CA 
       CB C7 CB CB 
       CA CB C6 CA 
       CB 00 00 00 
       00 00 00 CA 
043A6F             0016*M 
043A6F             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043A6F 17 1B 21    0018*M     db 23,27,0x21
043A72 08 00       0019*M     dw width ; in pixels
043A74 08 00       0020*M     dw height ; in pixels
043A76 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043A77             0125*  	LOADBMPBUFFER2 BUF_STAR,5,5,"nurples/src/rgba2/star.rgba2"
043A77             0001*M 
043A77             0002*M     ; Clear buffer
043A77 17 00 A0    0003*M     db 23,0,0xA0
043A7A 38 01       0004*M     dw bufferId
043A7C 02          0005*M     db 2
043A7D             0006*M 
043A7D 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043A80 38 01       0008*M     dw bufferId
043A82             0009*M 
043A82             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043A82 17 00 A0    0011*M     db 23,0,0xA0
043A85 38 01       0012*M     dw bufferId
043A87 00          0013*M     db 0
043A88 19 00       0014*M 	dw width * height ; length of data in bytes
043A8A 00 00 D1 00 0015*M     incbin file ; bitmap data
       00 00 00 E6 
       00 00 D1 E6 
       FF E6 D1 00 
       00 E6 00 00 
       00 00 D1 00 
       00          
043AA3             0016*M 
043AA3             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043AA3 17 1B 21    0018*M     db 23,27,0x21
043AA6 05 00       0019*M     dw width ; in pixels
043AA8 05 00       0020*M     dw height ; in pixels
043AAA 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043AAB             0126*  	LOADBMPBUFFER2 BUF_TURRET,16,16,"nurples/src/rgba2/turret.rgba2"
043AAB             0001*M 
043AAB             0002*M     ; Clear buffer
043AAB 17 00 A0    0003*M     db 23,0,0xA0
043AAE 39 01       0004*M     dw bufferId
043AB0 02          0005*M     db 2
043AB1             0006*M 
043AB1 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043AB4 39 01       0008*M     dw bufferId
043AB6             0009*M 
043AB6             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043AB6 17 00 A0    0011*M     db 23,0,0xA0
043AB9 39 01       0012*M     dw bufferId
043ABB 00          0013*M     db 0
043ABC 00 01       0014*M 	dw width * height ; length of data in bytes
043ABE 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 00 00 00 
       00 00 D0 F5 
       F5 F5 C3 C3 
       C3 C3 F5 F5 
       F5 D0 00 00 
       00 D0 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       F5 C3 C3 C3 
       C3 C3 C3 F5 
       F5 F5 D0 00 
       D0 F5 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       C3 C3 C3 C3 
       C3 C3 C3 C3 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 D0 DF 
       DF D0 D0 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 C3 DF 
       DF C3 D0 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 C3 DF 
       DF C3 D0 F5 
       F5 F5 F5 D0 
       00 D0 F5 F5 
       F5 D0 D0 E5 
       E5 D0 D0 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       D0 D0 E5 FA 
       FA E5 D0 D0 
       F5 F5 D0 00 
       00 00 D0 F5 
       D0 E5 FA FA 
       FA FA E5 D0 
       F5 D0 00 00 
       00 00 00 D0 
       D0 D0 E5 FA 
       FA E5 D0 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
043BBE             0016*M 
043BBE             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043BBE 17 1B 21    0018*M     db 23,27,0x21
043BC1 10 00       0019*M     dw width ; in pixels
043BC3 10 00       0020*M     dw height ; in pixels
043BC5 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043BC6             0127*  	LOADBMPBUFFER2 BUF_TURRET_ROT,16,16,"nurples/src/rgba2/turret_rot.rgba2"
043BC6             0001*M 
043BC6             0002*M     ; Clear buffer
043BC6 17 00 A0    0003*M     db 23,0,0xA0
043BC9 3A 01       0004*M     dw bufferId
043BCB 02          0005*M     db 2
043BCC             0006*M 
043BCC 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043BCF 3A 01       0008*M     dw bufferId
043BD1             0009*M 
043BD1             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043BD1 17 00 A0    0011*M     db 23,0,0xA0
043BD4 3A 01       0012*M     dw bufferId
043BD6 00          0013*M     db 0
043BD7 00 01       0014*M 	dw width * height ; length of data in bytes
043BD9 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 F5 F5 F5 
       F5 F5 F5 D0 
       D0 00 00 00 
       00 00 DF DF 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 D0 00 00 
       00 D0 DF DF 
       DF D0 F5 C3 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 DF 
       DF DF C3 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       D0 F5 F5 D0 
       DF C3 DF D0 
       F5 C3 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       C3 DF DF DF 
       C3 F5 F5 F5 
       C3 F5 F5 D0 
       D0 F5 F5 C3 
       F5 D0 DF C3 
       DF D0 F5 C3 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 C3 DF 
       DF DF D0 D0 
       D0 D0 F5 D0 
       D0 F5 F5 F5 
       F5 C3 F5 D0 
       DF DF DF C3 
       D0 D0 D0 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       D0 DF C3 FA 
       E5 E5 D0 D0 
       00 D0 F5 F5 
       F5 F5 F5 C3 
       D0 C3 FA FA 
       FA E5 D0 00 
       00 D0 F5 F5 
       F5 F5 C3 F5 
       D0 D0 E5 FA 
       E5 E5 D0 00 
       00 00 D0 F5 
       F5 F5 F5 F5 
       D0 D0 E5 E5 
       E5 D0 00 00 
       00 00 00 D0 
       D0 F5 F5 F5 
       F5 D0 D0 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
043CD9             0016*M 
043CD9             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043CD9 17 1B 21    0018*M     db 23,27,0x21
043CDC 10 00       0019*M     dw width ; in pixels
043CDE 10 00       0020*M     dw height ; in pixels
043CE0 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043CE1             0128*  @end:
043CE1             0048   	include "nurples/src/asm/fonts.asm"
043CE1             0001*  font_nurples:
043CE1 00 00 00 00 0002*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ;   #20 32
       00 00 00 00 
043CE9 20 20 20 20 0003*      db 0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x00 ; ! #21 33
       00 00 20 00 
043CF1 50 50 00 00 0004*      db 0x50,0x50,0x00,0x00,0x00,0x00,0x00,0x00 ; " #22 34
       00 00 00 00 
043CF9 00 50 F8 50 0005*      db 0x00,0x50,0xF8,0x50,0x50,0xF8,0x50,0x00 ; # #23 35
       50 F8 50 00 
043D01 20 70 A0 70 0006*      db 0x20,0x70,0xA0,0x70,0x28,0x70,0x20,0x00 ; $ #24 36
       28 70 20 00 
043D09 00 88 10 20 0007*      db 0x00,0x88,0x10,0x20,0x40,0x88,0x00,0x00 ; % #25 37
       40 88 00 00 
043D11 60 90 80 40 0008*      db 0x60,0x90,0x80,0x40,0xA8,0x90,0x68,0x00 ; & #26 38
       A8 90 68 00 
043D19 20 20 00 00 0009*      db 0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ' #27 39
       00 00 00 00 
043D21 10 20 40 40 0010*      db 0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00 ; ( #28 40
       40 20 10 00 
043D29 40 20 10 10 0011*      db 0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00 ; ) #29 41
       10 20 40 00 
043D31 20 A8 70 20 0012*      db 0x20,0xA8,0x70,0x20,0x70,0xA8,0x20,0x00 ; * #2A 42
       70 A8 20 00 
043D39 00 20 20 70 0013*      db 0x00,0x20,0x20,0x70,0x20,0x20,0x00,0x00 ; + #2B 43
       20 20 00 00 
043D41 00 00 00 00 0014*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x40 ; ,0x2C 44
       00 00 20 40 
043D49 00 00 00 70 0015*      db 0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00 ; - #2D 45
       00 00 00 00 
043D51 00 00 00 00 0016*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00 ; . #2E 46
       00 00 20 00 
043D59 10 10 20 20 0017*      db 0x10,0x10,0x20,0x20,0x40,0x40,0x80,0x80 ; / #2F 47
       40 40 80 80 
043D61 70 88 C8 A8 0018*      db 0x70,0x88,0xC8,0xA8,0x98,0x88,0x70,0x00 ; 0 #30 48
       98 88 70 00 
043D69 20 60 20 20 0019*      db 0x20,0x60,0x20,0x20,0x20,0x20,0x70,0x00 ; 1 #31 49
       20 20 70 00 
043D71 60 90 10 20 0020*      db 0x60,0x90,0x10,0x20,0x40,0x80,0xF0,0x00 ; 2 #32 50
       40 80 F0 00 
043D79 60 90 10 60 0021*      db 0x60,0x90,0x10,0x60,0x10,0x90,0x60,0x00 ; 3 #33 51
       10 90 60 00 
043D81 10 30 50 90 0022*      db 0x10,0x30,0x50,0x90,0xF8,0x10,0x10,0x00 ; 4 #34 52
       F8 10 10 00 
043D89 F0 80 E0 10 0023*      db 0xF0,0x80,0xE0,0x10,0x10,0x90,0x60,0x00 ; 5 #35 53
       10 90 60 00 
043D91 60 90 80 E0 0024*      db 0x60,0x90,0x80,0xE0,0x90,0x90,0x60,0x00 ; 6 #36 54
       90 90 60 00 
043D99 F0 10 20 20 0025*      db 0xF0,0x10,0x20,0x20,0x40,0x40,0x40,0x00 ; 7 #37 55
       40 40 40 00 
043DA1 60 90 90 60 0026*      db 0x60,0x90,0x90,0x60,0x90,0x90,0x60,0x00 ; 8 #38 56
       90 90 60 00 
043DA9 60 90 90 70 0027*      db 0x60,0x90,0x90,0x70,0x10,0x10,0x60,0x00 ; 9 #39 57
       10 10 60 00 
043DB1 00 00 00 20 0028*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x00 ; : #3A 58
       00 00 20 00 
043DB9 00 00 00 20 0029*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x40 ; ; #3B 59
       00 00 20 40 
043DC1 08 10 20 40 0030*      db 0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00 ; < #3C 60
       20 10 08 00 
043DC9 00 00 70 00 0031*      db 0x00,0x00,0x70,0x00,0x70,0x00,0x00,0x00 ; = #3D 61
       70 00 00 00 
043DD1 80 40 20 10 0032*      db 0x80,0x40,0x20,0x10,0x20,0x40,0x80,0x00 ; > #3E 62
       20 40 80 00 
043DD9 70 88 08 10 0033*      db 0x70,0x88,0x08,0x10,0x20,0x00,0x20,0x00 ; ? #3F 63
       20 00 20 00 
043DE1 30 48 98 A8 0034*      db 0x30,0x48,0x98,0xA8,0xA8,0x90,0x40,0x30 ; @ #40 64
       A8 90 40 30 
043DE9 70 88 88 F8 0035*      db 0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; A #41 65
       88 88 88 00 
043DF1 F0 88 88 F0 0036*      db 0xF0,0x88,0x88,0xF0,0x88,0x88,0xF0,0x00 ; B #42 66
       88 88 F0 00 
043DF9 70 88 80 80 0037*      db 0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x00 ; C #43 67
       80 88 70 00 
043E01 E0 90 88 88 0038*      db 0xE0,0x90,0x88,0x88,0x88,0x90,0xE0,0x00 ; D #44 68
       88 90 E0 00 
043E09 F8 80 80 E0 0039*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0xF8,0x00 ; E #45 69
       80 80 F8 00 
043E11 F8 80 80 E0 0040*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0x80,0x00 ; F #46 70
       80 80 80 00 
043E19 70 88 80 B8 0041*      db 0x70,0x88,0x80,0xB8,0x88,0x88,0x70,0x00 ; G #47 71
       88 88 70 00 
043E21 88 88 88 F8 0042*      db 0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; H #48 72
       88 88 88 00 
043E29 70 20 20 20 0043*      db 0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00 ; I #49 73
       20 20 70 00 
043E31 78 10 10 10 0044*      db 0x78,0x10,0x10,0x10,0x10,0x50,0x20,0x00 ; J #4A 74
       10 50 20 00 
043E39 88 90 A0 D0 0045*      db 0x88,0x90,0xA0,0xD0,0x88,0x88,0x88,0x00 ; K #4B 75
       88 88 88 00 
043E41 40 40 40 40 0046*      db 0x40,0x40,0x40,0x40,0x40,0x40,0x78,0x00 ; L #4C 76
       40 40 78 00 
043E49 88 88 D8 A8 0047*      db 0x88,0x88,0xD8,0xA8,0x88,0x88,0x88,0x00 ; M #4D 77
       88 88 88 00 
043E51 88 88 C8 A8 0048*      db 0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x00 ; N #4E 78
       98 88 88 00 
043E59 70 88 88 88 0049*      db 0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; O #4F 79
       88 88 70 00 
043E61 F0 88 88 F0 0050*      db 0xF0,0x88,0x88,0xF0,0x80,0x80,0x80,0x00 ; P #50 80
       80 80 80 00 
043E69 70 88 88 88 0051*      db 0x70,0x88,0x88,0x88,0xA8,0x90,0x68,0x00 ; Q #51 81
       A8 90 68 00 
043E71 F0 88 88 F0 0052*      db 0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,0x00 ; R #52 82
       A0 90 88 00 
043E79 70 88 80 70 0053*      db 0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00 ; S #53 83
       08 88 70 00 
043E81 F8 20 20 20 0054*      db 0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; T #54 84
       20 20 20 00 
043E89 88 88 88 88 0055*      db 0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; U #55 85
       88 88 70 00 
043E91 88 88 88 88 0056*      db 0x88,0x88,0x88,0x88,0x88,0x50,0x20,0x00 ; V #56 86
       88 50 20 00 
043E99 88 88 88 88 0057*      db 0x88,0x88,0x88,0x88,0xA8,0xA8,0x50,0x00 ; W #57 87
       A8 A8 50 00 
043EA1 88 88 50 20 0058*      db 0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00 ; X #58 88
       50 88 88 00 
043EA9 88 88 50 20 0059*      db 0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x00 ; Y #59 89
       20 20 20 00 
043EB1 F8 08 10 20 0060*      db 0xF8,0x08,0x10,0x20,0x40,0x80,0xF8,0x00 ; Z #5A 90
       40 80 F8 00 
043EB9 38 20 20 20 0061*      db 0x38,0x20,0x20,0x20,0x20,0x20,0x38,0x00 ; [ #5B 91
       20 20 38 00 
043EC1 80 80 40 40 0062*      db 0x80,0x80,0x40,0x40,0x20,0x20,0x10,0x10 ; \ #5C 92
       20 20 10 10 
043EC9 E0 20 20 20 0063*      db 0xE0,0x20,0x20,0x20,0x20,0x20,0xE0,0x00 ; ] #5D 93
       20 20 E0 00 
043ED1 20 50 88 00 0064*      db 0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00 ; ^ #5E 94
       00 00 00 00 
043ED9 00 00 00 00 0065*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8 ; _ #5F 95
       00 00 00 F8 
043EE1 40 20 00 00 0066*      db 0x40,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ` #60 96
       00 00 00 00 
043EE9 00 00 60 10 0067*      db 0x00,0x00,0x60,0x10,0x70,0x90,0x70,0x00 ; a #61 97
       70 90 70 00 
043EF1 80 80 E0 90 0068*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0xE0,0x00 ; b #62 98
       90 90 E0 00 
043EF9 00 00 60 90 0069*      db 0x00,0x00,0x60,0x90,0x80,0x90,0x60,0x00 ; c #63 99
       80 90 60 00 
043F01 10 10 70 90 0070*      db 0x10,0x10,0x70,0x90,0x90,0x90,0x70,0x00 ; d #64 100
       90 90 70 00 
043F09 00 00 60 90 0071*      db 0x00,0x00,0x60,0x90,0xF0,0x80,0x70,0x00 ; e #65 101
       F0 80 70 00 
043F11 60 90 80 C0 0072*      db 0x60,0x90,0x80,0xC0,0x80,0x80,0x80,0x00 ; f #66 102
       80 80 80 00 
043F19 00 00 70 90 0073*      db 0x00,0x00,0x70,0x90,0x90,0x70,0x10,0x60 ; g #67 103
       90 70 10 60 
043F21 80 80 E0 90 0074*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0x90,0x00 ; h #68 104
       90 90 90 00 
043F29 00 20 00 20 0075*      db 0x00,0x20,0x00,0x20,0x20,0x20,0x20,0x00 ; i #69 105
       20 20 20 00 
043F31 00 10 00 10 0076*      db 0x00,0x10,0x00,0x10,0x10,0x10,0x50,0x20 ; j #6A 106
       10 10 50 20 
043F39 80 80 90 A0 0077*      db 0x80,0x80,0x90,0xA0,0xC0,0xA0,0x90,0x00 ; k #6B 107
       C0 A0 90 00 
043F41 20 20 20 20 0078*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; l #6C 108
       20 20 20 00 
043F49 00 00 D0 A8 0079*      db 0x00,0x00,0xD0,0xA8,0xA8,0x88,0x88,0x00 ; m #6D 109
       A8 88 88 00 
043F51 00 00 B0 C8 0080*      db 0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x00 ; n #6E 110
       88 88 88 00 
043F59 00 00 70 88 0081*      db 0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00 ; o #6F 111
       88 88 70 00 
043F61 00 00 F0 88 0082*      db 0x00,0x00,0xF0,0x88,0x88,0xF0,0x80,0x80 ; p #70 112
       88 F0 80 80 
043F69 00 00 78 88 0083*      db 0x00,0x00,0x78,0x88,0x88,0x78,0x08,0x08 ; q #71 113
       88 78 08 08 
043F71 00 00 B0 C8 0084*      db 0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x00 ; r 114 #72
       80 80 80 00 
043F79 00 00 70 80 0085*      db 0x00,0x00,0x70,0x80,0x60,0x10,0xE0,0x00 ; s #73 115
       60 10 E0 00 
043F81 40 40 F0 40 0086*      db 0x40,0x40,0xF0,0x40,0x40,0x40,0x30,0x00 ; t #74 116
       40 40 30 00 
043F89 00 00 88 88 0087*      db 0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x00 ; u #75 117
       88 98 68 00 
043F91 00 00 88 88 0088*      db 0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00 ; v #76 118
       88 50 20 00 
043F99 00 00 88 88 0089*      db 0x00,0x00,0x88,0x88,0xA8,0xA8,0x50,0x00 ; w #77 119
       A8 A8 50 00 
043FA1 00 00 88 50 0090*      db 0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00 ; x #78 120
       20 50 88 00 
043FA9 00 00 88 88 0091*      db 0x00,0x00,0x88,0x88,0x50,0x50,0x20,0xC0 ; y #79 121
       50 50 20 C0 
043FB1 00 00 F8 10 0092*      db 0x00,0x00,0xF8,0x10,0x20,0x40,0xF8,0x00 ; z #7A 122
       20 40 F8 00 
043FB9 30 40 40 80 0093*      db 0x30,0x40,0x40,0x80,0x40,0x40,0x30,0x00 ; { #7B 123
       40 40 30 00 
043FC1 20 20 20 20 0094*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; | #7C 124
       20 20 20 20 
043FC9 60 10 10 08 0095*      db 0x60,0x10,0x10,0x08,0x10,0x10,0x60,0x00 ; } #7D 125
       10 10 60 00 
043FD1 68 B0 00 00 0096*      db 0x68,0xB0,0x00,0x00,0x00,0x00,0x00,0x00 ; ~ #7E 126
       00 00 00 00 
043FD9 A8 50 A8 50 0097*      db 0xA8,0x50,0xA8,0x50,0xA8,0x50,0xA8,0x00 ;  #7F 127
       A8 50 A8 00 
043FE1 00 00 00 FC 0098*      db 0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00 ;  #80 128
       00 00 00 00 
043FE9 20 20 20 20 0099*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ;  #81 129
       20 20 20 20 
043FF1 00 00 00 3C 0100*      db 0x00,0x00,0x00,0x3C,0x20,0x20,0x20,0x20 ;  #82 130
       20 20 20 20 
043FF9 00 00 00 E0 0101*      db 0x00,0x00,0x00,0xE0,0x20,0x20,0x20,0x20 ;  #83 131
       20 20 20 20 
044001 20 20 20 3C 0102*      db 0x20,0x20,0x20,0x3C,0x00,0x00,0x00,0x00 ;  #84 132
       00 00 00 00 
044009 20 20 20 E0 0103*      db 0x20,0x20,0x20,0xE0,0x00,0x00,0x00,0x00 ;  #85 133
       00 00 00 00 
044011 20 20 20 3C 0104*      db 0x20,0x20,0x20,0x3C,0x20,0x20,0x20,0x20 ;  #86 134
       20 20 20 20 
044019 20 20 20 E0 0105*      db 0x20,0x20,0x20,0xE0,0x20,0x20,0x20,0x20 ;  #87 135
       20 20 20 20 
044021 00 00 00 FC 0106*      db 0x00,0x00,0x00,0xFC,0x20,0x20,0x20,0x20 ;  #88 136
       20 20 20 20 
044029 20 20 20 FC 0107*      db 0x20,0x20,0x20,0xFC,0x00,0x00,0x00,0x00 ;  #89 137
       00 00 00 00 
044031 20 20 20 FC 0108*      db 0x20,0x20,0x20,0xFC,0x20,0x20,0x20,0x20 ;  #8A 138
       20 20 20 20 
044039 00 00 FC 00 0109*      db 0x00,0x00,0xFC,0x00,0xFC,0x00,0x00,0x00 ;  #8B 139
       FC 00 00 00 
044041 50 50 50 50 0110*      db 0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50 ;  #8C 140
       50 50 50 50 
044049 00 00 3C 20 0111*      db 0x00,0x00,0x3C,0x20,0x3C,0x20,0x20,0x20 ;  #8D 141
       3C 20 20 20 
044051 00 00 00 7C 0112*      db 0x00,0x00,0x00,0x7C,0x50,0x50,0x50,0x50 ;  #8E 142
       50 50 50 50 
044059 00 00 7C 40 0113*      db 0x00,0x00,0x7C,0x40,0x5C,0x50,0x50,0x50 ;  #8F 143
       5C 50 50 50 
044061 00 00 E0 20 0114*      db 0x00,0x00,0xE0,0x20,0xE0,0x20,0x20,0x20 ;  #90 144
       E0 20 20 20 
044069 00 00 00 F0 0115*      db 0x00,0x00,0x00,0xF0,0x50,0x50,0x50,0x50 ;  #91 145
       50 50 50 50 
044071 00 00 F0 10 0116*      db 0x00,0x00,0xF0,0x10,0xD0,0x50,0x50,0x50 ;  #92 146
       D0 50 50 50 
044079 20 20 3C 20 0117*      db 0x20,0x20,0x3C,0x20,0x3C,0x00,0x00,0x00 ;  #93 147
       3C 00 00 00 
044081 50 50 50 7C 0118*      db 0x50,0x50,0x50,0x7C,0x00,0x00,0x00,0x00 ;  #94 148
       00 00 00 00 
044089 50 50 5C 40 0119*      db 0x50,0x50,0x5C,0x40,0x7C,0x00,0x00,0x00 ;  #95 149
       7C 00 00 00 
044091 20 20 E0 20 0120*      db 0x20,0x20,0xE0,0x20,0xE0,0x00,0x00,0x00 ;  #96 150
       E0 00 00 00 
044099 50 50 50 F0 0121*      db 0x50,0x50,0x50,0xF0,0x00,0x00,0x00,0x00 ;  #97 151
       00 00 00 00 
0440A1 50 50 D0 10 0122*      db 0x50,0x50,0xD0,0x10,0xF0,0x00,0x00,0x00 ;  #98 152
       F0 00 00 00 
0440A9 20 20 3C 20 0123*      db 0x20,0x20,0x3C,0x20,0x3C,0x20,0x20,0x20 ;  #99 153
       3C 20 20 20 
0440B1 50 50 50 5C 0124*      db 0x50,0x50,0x50,0x5C,0x50,0x50,0x50,0x50 ;  #9A 154
       50 50 50 50 
0440B9 50 50 5C 40 0125*      db 0x50,0x50,0x5C,0x40,0x5C,0x50,0x50,0x50 ;  #9B 155
       5C 50 50 50 
0440C1 20 20 E0 20 0126*      db 0x20,0x20,0xE0,0x20,0xE0,0x20,0x20,0x20 ;  #9C 156
       E0 20 20 20 
0440C9 50 50 50 D0 0127*      db 0x50,0x50,0x50,0xD0,0x50,0x50,0x50,0x50 ;  #9D 157
       50 50 50 50 
0440D1 50 50 D0 10 0128*      db 0x50,0x50,0xD0,0x10,0xD0,0x50,0x50,0x50 ;  #9E 158
       D0 50 50 50 
0440D9 00 00 FC 00 0129*      db 0x00,0x00,0xFC,0x00,0xFC,0x20,0x20,0x20 ;  #9F 159
       FC 20 20 20 
0440E1 00 00 00 FC 0130*      db 0x00,0x00,0x00,0xFC,0x50,0x50,0x50,0x50 ;  #A0 160
       50 50 50 50 
0440E9 00 00 FC 00 0131*      db 0x00,0x00,0xFC,0x00,0xDC,0x50,0x50,0x50 ;  #A1 161
       DC 50 50 50 
0440F1 20 20 FC 00 0132*      db 0x20,0x20,0xFC,0x00,0xFC,0x00,0x00,0x00 ;  #A2 162
       FC 00 00 00 
0440F9 50 50 50 FC 0133*      db 0x50,0x50,0x50,0xFC,0x00,0x00,0x00,0x00 ;  #A3 163
       00 00 00 00 
044101 50 50 DC 00 0134*      db 0x50,0x50,0xDC,0x00,0xFC,0x00,0x00,0x00 ;  #A4 164
       FC 00 00 00 
044109 20 20 FC 20 0135*      db 0x20,0x20,0xFC,0x20,0xFC,0x20,0x20,0x20 ;  #A5 165
       FC 20 20 20 
044111 50 50 50 FC 0136*      db 0x50,0x50,0x50,0xFC,0x50,0x50,0x50,0x50 ;  #A6 166
       50 50 50 50 
044119 50 50 DC 00 0137*      db 0x50,0x50,0xDC,0x00,0xDC,0x50,0x50,0x50 ;  #A7 167
       DC 50 50 50 
044121 FC FC 00 00 0138*      db 0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00 ;  #A8 168
       00 00 00 00 
044129 00 00 00 00 0139*      db 0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC ;  #A9 169
       00 00 FC FC 
044131 FC FC FC FC 0140*      db 0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC ;  #AA 170
       FC FC FC FC 
044139 C0 C0 C0 C0 0141*      db 0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0 ;  #AB 171
       C0 C0 C0 C0 
044141 0C 0C 0C 0C 0142*      db 0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C ;  #AC 172
       0C 0C 0C 0C 
044149 A8 00 A8 00 0143*      db 0xA8,0x00,0xA8,0x00,0xA8,0x00,0xA8,0x00 ;  #AD 173
       A8 00 A8 00 
044151 A8 54 A8 54 0144*      db 0xA8,0x54,0xA8,0x54,0xA8,0x54,0xA8,0x54 ;  #AE 174
       A8 54 A8 54 
044159 54 FC 54 FC 0145*      db 0x54,0xFC,0x54,0xFC,0x54,0xFC,0x54,0xFC ;  #AF 175
       54 FC 54 FC 
044161             0049   	include "nurples/src/asm/levels.asm"
044161 00          0001*  tiles_level_00: db  0 ; number of rows, 0 is max of 256
044162 00 00 00 00 0002*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 0
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
044172 00 00 00 00 0003*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03 ; row 1
       00 00 00 00 
       00 03 00 05 
       03 05 00 03 
044182 00 00 00 00 0004*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 2
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
044192 00 00 00 07 0005*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 3
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
0441A2 00 00 00 03 0006*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 4
       00 05 03 05 
       00 03 05 00 
       03 00 00 03 
0441B2 00 00 00 03 0007*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 5
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
0441C2 00 00 00 01 0008*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 6
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
0441D2 00 00 00 03 0009*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 7
       00 00 03 05 
       04 03 00 00 
       03 00 00 03 
0441E2 00 00 00 03 0010*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 8
       00 00 03 04 
       05 03 00 00 
       03 00 00 03 
0441F2 01 02 02 01 0011*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 9
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
044202 03 04 05 03 0012*  	db 0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03 ; row 10
       00 00 03 00 
       00 03 00 00 
       03 05 05 03 
044212 03 05 04 03 0013*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 11
       00 00 03 00 
       00 03 00 00 
       03 04 04 03 
044222 01 02 02 01 0014*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 12
       02 02 01 02 
       02 06 02 02 
       01 02 02 01 
044232 00 00 00 00 0015*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 13
       00 00 03 04 
       00 03 05 00 
       03 00 00 03 
044242 00 00 00 00 0016*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 14
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
044252 00 00 00 00 0017*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 15
       00 00 01 02 
       02 07 02 02 
       01 02 02 01 
044262 00 00 00 00 0018*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x00,0x00,0x00 ; row 16
       00 00 03 05 
       05 03 00 05 
       03 00 00 00 
044272 00 00 00 00 0019*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 17
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
044282 00 00 00 00 0020*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 18
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
044292 00 00 00 00 0021*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x00 ; row 19
       00 00 03 00 
       00 03 04 00 
       03 00 00 00 
0442A2 00 00 00 00 0022*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 20
       00 00 03 00 
       05 03 00 00 
       03 00 00 00 
0442B2 00 00 00 00 0023*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00 ; row 21
       00 00 03 00 
       00 03 05 00 
       03 00 00 00 
0442C2 00 00 00 00 0024*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 22
       00 00 03 04 
       00 03 00 00 
       03 00 00 00 
0442D2 00 00 00 00 0025*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 23
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0442E2 00 00 00 00 0026*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 24
       00 00 03 00 
       04 03 00 00 
       00 00 00 00 
0442F2 00 00 00 00 0027*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 25
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
044302 00 00 00 01 0028*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 26
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
044312 00 00 00 03 0029*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 27
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044322 00 00 00 03 0030*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 28
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
044332 00 00 00 01 0031*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 29
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044342 00 00 00 03 0032*  	db 0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 30
       04 05 03 00 
       00 03 00 00 
       00 00 00 00 
044352 00 00 00 03 0033*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 31
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
044362 00 00 00 01 0034*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 32
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
044372 00 00 00 00 0035*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 33
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044382 00 00 00 00 0036*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 34
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044392 00 00 00 00 0037*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 35
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
0443A2 00 00 00 00 0038*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 36
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0443B2 00 00 00 00 0039*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 37
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0443C2 00 00 00 00 0040*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 38
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0443D2 00 00 00 00 0041*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 39
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
0443E2 00 00 00 00 0042*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 40
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0443F2 00 00 00 01 0043*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 41
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044402 00 00 00 03 0044*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 42
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044412 00 00 00 03 0045*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 43
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044422 07 02 02 01 0046*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 44
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044432 03 00 00 03 0047*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 45
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044442 03 00 00 03 0048*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 46
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044452 01 02 02 01 0049*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 47
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044462 00 00 00 03 0050*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 48
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044472 00 00 00 03 0051*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 49
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044482 00 00 00 06 0052*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 50
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
044492 00 00 00 00 0053*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 51
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
0444A2 00 00 00 00 0054*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 52
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0444B2 00 00 00 00 0055*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 53
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
0444C2 00 00 00 00 0056*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 54
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0444D2 00 00 00 00 0057*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 55
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0444E2 00 00 00 01 0058*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 56
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0444F2 00 00 00 03 0059*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 57
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
044502 00 00 00 03 0060*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 58
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
044512 00 00 00 01 0061*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 59
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044522 00 00 00 03 0062*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 60
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044532 00 00 00 03 0063*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 61
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044542 00 00 00 07 0064*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 62
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
044552 00 00 00 00 0065*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 63
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044562 00 00 00 00 0066*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 64
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044572 00 00 00 00 0067*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 65
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
044582 00 00 00 00 0068*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 66
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044592 00 00 00 00 0069*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 67
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0445A2 00 00 00 00 0070*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 68
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0445B2 00 00 00 00 0071*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 69
       00 00 00 00 
       00 03 04 04 
       03 00 00 00 
0445C2 00 00 00 00 0072*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00 ; row 70
       00 00 00 00 
       00 03 05 04 
       03 00 00 00 
0445D2 00 00 00 00 0073*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 71
       00 00 00 00 
       00 01 02 02 
       01 00 00 00 
0445E2 00 00 00 00 0074*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 72
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
0445F2 00 00 00 00 0075*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 73
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
044602 00 00 00 00 0076*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 74
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
044612 00 00 00 00 0077*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 75
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044622 00 00 00 00 0078*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 76
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044632 00 00 00 07 0079*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 77
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
044642 00 00 00 03 0080*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 78
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044652 00 00 00 03 0081*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 79
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044662 00 00 00 01 0082*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 80
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
044672 00 00 00 03 0083*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 81
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
044682 00 00 00 03 0084*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 82
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
044692 00 00 00 01 0085*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 83
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
0446A2 00 00 00 00 0086*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 84
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0446B2 00 00 00 00 0087*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 85
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0446C2 00 00 00 00 0088*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 86
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0446D2 00 00 00 00 0089*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 87
       00 00 03 05 
       05 03 00 00 
       03 00 00 00 
0446E2 00 00 00 00 0090*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 88
       00 00 03 04 
       04 03 00 00 
       03 00 00 00 
0446F2 00 00 00 00 0091*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 89
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
044702 00 00 00 00 0092*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 90
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
044712 00 00 00 00 0093*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 91
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
044722 00 00 00 00 0094*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 92
       00 00 06 02 
       02 01 02 02 
       01 02 02 01 
044732 00 00 00 00 0095*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03 ; row 93
       00 00 00 00 
       00 03 00 00 
       03 05 04 03 
044742 00 00 00 00 0096*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03 ; row 94
       00 00 00 00 
       00 03 00 00 
       03 04 05 03 
044752 00 00 00 01 0097*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 95
       02 02 02 02 
       02 07 02 02 
       01 02 02 01 
044762 00 00 00 03 0098*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 96
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044772 00 00 00 03 0099*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 97
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044782 00 00 00 01 0100*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x02,0x02,0x01 ; row 98
       02 02 02 02 
       02 02 02 02 
       01 02 02 01 
044792 01 02 02 01 0101*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 99
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447A2 03 00 00 03 0102*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 100
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447B2 03 00 00 03 0103*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 101
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447C2 01 02 02 07 0104*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 102
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447D2 03 00 00 03 0105*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 103
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447E2 03 00 00 03 0106*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 104
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447F2 01 02 02 01 0107*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 105
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044802 03 00 04 03 0108*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 106
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044812 03 04 00 03 0109*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 107
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044822 01 02 02 01 0110*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 108
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
044832 03 00 00 03 0111*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 109
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044842 03 00 04 03 0112*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 110
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
044852 01 02 02 01 0113*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 111
       02 02 07 02 
       02 01 00 00 
       00 00 00 00 
044862 00 00 00 03 0114*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 112
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
044872 00 00 00 03 0115*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 113
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
044882 00 00 00 01 0116*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 114
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
044892 00 00 00 00 0117*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 115
       00 00 03 00 
       00 03 04 04 
       03 00 00 00 
0448A2 00 00 00 00 0118*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00 ; row 116
       00 00 03 00 
       00 03 05 05 
       03 00 00 00 
0448B2 00 00 00 00 0119*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 117
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0448C2 00 00 00 00 0120*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 118
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
0448D2 00 00 00 00 0121*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 119
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
0448E2 00 00 00 00 0122*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 120
       00 00 00 00 
       00 06 02 02 
       01 02 02 01 
0448F2 00 00 00 00 0123*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x05,0x03 ; row 121
       00 00 00 00 
       00 03 00 05 
       03 00 05 03 
044902 00 00 00 00 0124*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x05,0x00,0x03 ; row 122
       00 00 00 00 
       00 03 00 04 
       03 05 00 03 
044912 00 00 00 00 0125*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 123
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
044922 00 00 00 00 0126*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 124
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
044932 00 00 00 00 0127*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 125
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
044942 00 00 00 00 0128*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 126
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
044952 00 00 00 00 0129*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 127
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
044962 00 00 00 00 0130*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 128
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
044972 00 00 00 01 0131*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 129
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
044982 00 00 00 03 0132*  	db 0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 130
       05 00 03 00 
       00 00 00 00 
       00 00 00 00 
044992 00 00 00 03 0133*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 131
       00 05 03 00 
       00 00 00 00 
       00 00 00 00 
0449A2 01 02 02 07 0134*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 132
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0449B2 03 04 00 03 0135*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 133
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0449C2 03 05 04 03 0136*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 134
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0449D2 01 02 02 01 0137*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 135
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0449E2 03 00 00 03 0138*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 136
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0449F2 03 00 00 03 0139*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 137
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044A02 01 02 02 01 0140*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 138
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044A12 03 00 00 03 0141*  	db 0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 139
       04 05 03 00 
       00 00 00 00 
       00 00 00 00 
044A22 03 00 00 03 0142*  	db 0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 140
       05 04 03 00 
       00 00 00 00 
       00 00 00 00 
044A32 01 02 02 01 0143*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 141
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
044A42 00 00 00 03 0144*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 142
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044A52 00 00 00 03 0145*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 143
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044A62 00 00 00 06 0146*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 144
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
044A72 00 00 00 00 0147*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 145
       00 00 03 00 
       00 03 04 04 
       03 00 00 03 
044A82 00 00 00 00 0148*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03 ; row 146
       00 00 03 00 
       00 03 05 05 
       03 00 00 03 
044A92 00 00 00 00 0149*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01 ; row 147
       00 00 01 02 
       02 01 02 02 
       06 02 02 01 
044AA2 00 00 00 00 0150*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 148
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
044AB2 00 00 00 00 0151*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 149
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
044AC2 00 00 00 00 0152*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 150
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
044AD2 00 00 00 00 0153*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 151
       00 00 00 00 
       00 03 04 04 
       03 00 00 03 
044AE2 00 00 00 00 0154*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03 ; row 152
       00 00 00 00 
       00 03 05 04 
       03 00 00 03 
044AF2 00 00 00 00 0155*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 153
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
044B02 00 00 00 00 0156*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 154
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
044B12 00 00 00 00 0157*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 155
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
044B22 00 00 00 00 0158*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 156
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
044B32 00 00 00 00 0159*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 157
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044B42 00 00 00 00 0160*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 158
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044B52 00 00 00 00 0161*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01 ; row 159
       00 00 00 00 
       00 00 00 00 
       01 02 02 01 
044B62 00 00 00 00 0162*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03 ; row 160
       00 00 00 00 
       00 00 00 00 
       03 05 05 03 
044B72 00 00 00 00 0163*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03 ; row 161
       00 00 00 00 
       00 00 00 00 
       03 05 04 03 
044B82 00 00 00 00 0164*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01 ; row 162
       00 00 00 00 
       00 00 00 00 
       06 02 02 01 
044B92 00 00 00 00 0165*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 163
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044BA2 00 00 00 00 0166*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 164
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044BB2 00 00 00 01 0167*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01 ; row 165
       02 02 02 02 
       02 02 02 02 
       07 02 02 01 
044BC2 00 00 00 03 0168*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x04,0x04,0x04,0x05,0x03 ; row 166
       04 04 05 04 
       05 05 05 04 
       04 04 05 03 
044BD2 00 00 00 03 0169*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x04,0x04,0x04,0x04,0x05,0x05,0x04,0x05,0x05,0x03 ; row 167
       05 05 04 04 
       04 04 05 05 
       04 05 05 03 
044BE2 00 00 00 01 0170*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01 ; row 168
       02 02 02 02 
       02 02 02 02 
       02 02 02 01 
044BF2 01 02 02 07 0171*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 169
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C02 03 00 00 03 0172*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 170
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C12 03 00 00 03 0173*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 171
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C22 01 02 02 01 0174*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 172
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C32 03 04 04 03 0175*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 173
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C42 03 04 04 03 0176*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 174
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C52 01 02 02 01 0177*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 175
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C62 03 00 00 03 0178*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 176
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C72 03 00 00 03 0179*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 177
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C82 01 02 02 01 0180*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 178
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C92 03 00 00 03 0181*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 179
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044CA2 03 00 00 03 0182*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 180
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044CB2 01 02 02 07 0183*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 181
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044CC2 03 00 00 03 0184*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 182
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044CD2 03 00 00 03 0185*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 183
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044CE2 01 02 02 01 0186*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 184
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044CF2 00 00 00 03 0187*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 185
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
044D02 00 00 00 03 0188*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 186
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
044D12 00 00 00 01 0189*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 187
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044D22 00 00 00 03 0190*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 188
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044D32 00 00 00 03 0191*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 189
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044D42 00 00 00 01 0192*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 190
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
044D52 00 00 00 03 0193*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 191
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044D62 00 00 00 03 0194*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 192
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044D72 00 00 00 01 0195*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 193
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044D82 00 00 00 03 0196*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 194
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
044D92 00 00 00 03 0197*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 195
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
044DA2 00 00 00 01 0198*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 196
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044DB2 00 00 00 03 0199*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 197
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044DC2 00 00 00 03 0200*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 198
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044DD2 00 00 00 07 0201*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 199
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044DE2 00 00 00 03 0202*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 200
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044DF2 00 00 00 03 0203*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 201
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044E02 00 00 00 01 0204*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 202
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044E12 00 00 00 00 0205*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 203
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
044E22 00 00 00 00 0206*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 204
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
044E32 00 00 00 00 0207*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 205
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
044E42 00 00 00 00 0208*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 206
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044E52 00 00 00 00 0209*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 207
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044E62 00 00 00 00 0210*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 208
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
044E72 00 00 00 00 0211*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 209
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
044E82 00 00 00 00 0212*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 210
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
044E92 00 00 00 00 0213*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 211
       00 00 00 00 
       01 06 02 02 
       01 02 02 01 
044EA2 00 00 00 00 0214*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x01,0x00,0x00,0x00,0x00,0x00 ; row 212
       00 00 00 01 
       05 04 01 00 
       00 00 00 00 
044EB2 00 00 00 00 0215*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00 ; row 213
       00 00 01 05 
       04 05 01 00 
       00 00 00 00 
044EC2 00 00 00 00 0216*  	db 0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 214
       00 01 05 04 
       05 01 00 00 
       00 00 00 00 
044ED2 00 00 00 00 0217*  	db 0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 215
       01 05 04 05 
       01 00 00 00 
       00 00 00 00 
044EE2 00 00 00 01 0218*  	db 0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 216
       05 04 05 01 
       00 00 00 00 
       00 00 00 00 
044EF2 00 00 01 05 0219*  	db 0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 217
       04 05 01 00 
       00 00 00 00 
       00 00 00 00 
044F02 01 02 02 07 0220*  	db 0x01,0x02,0x02,0x07,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 218
       05 01 00 00 
       00 00 00 00 
       00 00 00 00 
044F12 03 00 00 03 0221*  	db 0x03,0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 219
       01 00 00 00 
       00 00 00 00 
       00 00 00 00 
044F22 03 00 00 03 0222*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 220
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044F32 01 02 02 01 0223*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 221
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044F42 03 00 00 03 0224*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 222
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044F52 03 00 00 03 0225*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 223
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044F62 01 02 02 01 0226*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 224
       02 02 06 00 
       00 00 00 00 
       00 00 00 00 
044F72 00 00 00 03 0227*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 225
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044F82 00 00 00 03 0228*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 226
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044F92 00 00 00 01 0229*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 227
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
044FA2 00 00 00 03 0230*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 228
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044FB2 00 00 00 03 0231*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 229
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044FC2 00 00 00 01 0232*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 230
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
044FD2 00 00 00 03 0233*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 231
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044FE2 00 00 00 03 0234*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 232
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044FF2 01 02 02 01 0235*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00 ; row 233
       02 02 01 02 
       02 01 02 02 
       06 00 00 00 
045002 03 00 00 03 0236*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 234
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
045012 03 00 00 03 0237*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 235
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
045022 07 02 02 01 0238*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 236
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
045032 00 00 00 03 0239*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 237
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
045042 00 00 00 03 0240*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 238
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
045052 00 00 00 01 0241*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 239
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
045062 00 00 00 03 0242*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 240
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
045072 00 00 00 03 0243*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 241
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
045082 00 00 00 01 0244*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 242
       02 02 06 02 
       02 01 02 02 
       01 00 00 00 
045092 00 00 00 00 0245*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 243
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0450A2 00 00 00 00 0246*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 244
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0450B2 00 00 00 00 0247*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 245
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0450C2 00 00 00 00 0248*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 246
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
0450D2 00 00 00 00 0249*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 247
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
0450E2 00 00 00 01 0250*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 248
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0450F2 00 00 00 03 0251*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 249
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
045102 00 00 00 03 0252*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 250
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
045112 01 02 02 07 0253*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01 ; row 251
       02 02 01 02 
       02 01 02 02 
       07 02 02 01 
045122 03 05 05 03 0254*  	db 0x03,0x05,0x05,0x03,0x04,0x05,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x05,0x04,0x03 ; row 252
       04 05 03 05 
       05 03 00 05 
       03 05 04 03 
045132 03 04 04 03 0255*  	db 0x03,0x04,0x04,0x03,0x05,0x05,0x03,0x04,0x04,0x03,0x05,0x00,0x03,0x04,0x04,0x03 ; row 253
       05 05 03 04 
       04 03 05 00 
       03 04 04 03 
045142 01 02 02 06 0256*  	db 0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06 ; row 254
       02 02 01 02 
       02 06 02 02 
       01 02 02 06 
045152 00 00 00 00 0257*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045162             0258*  
045162             0259*  
045162 10          0260*  tiles_level_01: db 16  ; number of rows, 0 is max of 256
045163 00 00 00 00 0261*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045173 00 00 00 00 0262*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045183 00 00 00 00 0263*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045193 00 00 00 00 0264*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451A3 00 00 00 00 0265*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451B3 00 00 00 00 0266*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451C3 00 00 00 00 0267*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451D3 00 00 00 00 0268*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451E3 00 00 00 00 0269*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451F3 00 00 00 00 0270*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045203 00 00 00 00 0271*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045213 00 00 00 00 0272*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045223 00 00 00 00 0273*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045233 00 00 00 00 0274*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045243 00 00 00 00 0275*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045253 00 00 00 00 0276*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045263             0277*  
045263             0050   
045263             0051   	include "nurples/src/asm/sprites.asm"
045263             0001*  ; ###### SPRITE TABLE FIELD INDICES ######
045263             0002*  table_bytes_per_record: equ 38 ; 38 bytes per sprite record
045263             0003*  sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
045263             0004*  sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
045263             0005*  sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
045263             0006*  sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
045263             0007*  sprite_collisions:      equ 08 ; 1 bytes low/high nibble: collision details
045263             0008*  sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
045263             0009*  sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
045263             0010*  sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
045263             0011*  sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
045263             0012*  sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
045263             0013*  sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
045263             0014*  sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
045263             0015*  sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
045263             0016*  sprite_orientation:     equ 29 ; 3 bytes orientation bits
045263             0017*  sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
045263             0018*  sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
045263             0019*  sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
045263             0020*  sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
045263             0021*  sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type, BCD
045263             0022*  sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision, binary
045263             0023*  
045263             0024*  ; ###### SPRITE TABLE VARIABLES ######
045263             0025*  ; maximum number of sprites
045263             0026*  table_max_records: equ 4 ; it can handle more but this is pushing it
045263             0027*  table_total_bytes: equ table_max_records*table_bytes_per_record
045263             0028*  
045263             0029*  ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
045263             0030*  table_base:
045263 00 00 00 00 0031*  sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0452FB             0032*  sprite_end_variables: ; in case we want to traverse the table in reverse
0452FB             0033*  
0452FB             0034*  ; pointer to top address of current record, initialized to table_base
0452FB 63 52 04    0035*  table_pointer: dl table_base
0452FE             0036*  ; how many active sprites
0452FE 00          0037*  table_active_sprites: db 0x00
0452FF             0038*  ; flag indicating collision with screen edge
0452FF             0039*  ; uses orientation codes to specify which edge(s)
0452FF 00          0040*  sprite_screen_edge: db #00
045300             0041*  ; next sprite id to use
045300 00          0042*  sprite_next_id: db 0
045301             0043*  
045301             0044*  ; ######### COLLISION SPRITE PARAMETERS ##########
045301             0045*  ; integer coordinates are all that are needed for collision calculations
045301 00          0046*  collision_x: db 0x00
045302 00          0047*  collision_y: db 0x00
045303 00          0048*  collision_dim_x: db 0x00
045304 00          0049*  collision_dim_y: db 0x00
045305             0050*  
045305             0051*  ; scratch variables
045305 00          0052*  x: db 0x00 ; 8-bit signed integer
045306 00          0053*  y: db 0x00 ; 8-bit signed integer
045307 00 00 00    0054*  x0: dl 0x000000 ; 16.8 signed fixed place
04530A 00 00 00    0055*  y0: dl 0x000000 ; 16.8 signed fixed place
04530D 00 00 00    0056*  incx1: dl 0x000000 ; 16.8 signed fixed place
045310 00 00 00    0057*  incy1: dl 0x000000 ; 16.8 signed fixed place
045313 00 00 00    0058*  incx2: dl 0x000000 ; 16.8 signed fixed place
045316 00 00 00    0059*  incy2: dl 0x000000 ; 16.8 signed fixed place
045319             0060*  
045319             0061*  ; sprite_heading: dl 0x000000 ; signed fixed 16.8
045319 00 00 00    0062*  radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
04531C 00 00 00    0063*  sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
04531F 00 00 00    0064*  cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
045322             0065*  
045322             0066*  ; gets the next available sprite id
045322             0067*  ; inputs; none
045322             0068*  ; returns: if new sprite available, a = sprite id,
045322             0069*  ;           ix pointing to new sprite vars, carry set
045322             0070*  ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
045322             0071*  ; destroys: a,b,hl,ix
045322             0072*  ; affects: bumps table_active_sprites by one
045322             0073*  table_get_next_id:
045322 DD 21 63 52 0074*      ld ix,table_base
       04          
045327 11 26 00 00 0075*      ld de,table_bytes_per_record
04532B 06 04       0076*      ld b,table_max_records
04532D             0077*  @loop:
04532D DD 7E 01    0078*      ld a,(ix+sprite_type)
045330 A7          0079*      and a
045331 28 06       0080*      jr z,@found
045333 DD 19       0081*      add ix,de
045335 10 F6       0082*      djnz @loop
045337             0083*  @notfound:
045337 AF          0084*      xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
045338 C9          0085*      ret
045339             0086*  @found:
045339             0087*  ; bump number of active sprites
045339 21 FE 52 04 0088*      ld hl,table_active_sprites
04533D 34          0089*      inc (hl)
04533E             0090*  ; return sprite id
04533E 3E 04       0091*      ld a,table_max_records
045340 90          0092*      sub b
045341 32 00 53 04 0093*      ld (sprite_next_id),a
045345 37          0094*      scf ; sets carry flag indicating we found a free sprite
045346 C9          0095*      ret ; done
045347             0096*  
045347             0097*  ; deactivate the sprite with the given id
045347             0098*  ; inputs: a = sprite id
045347             0099*  ; outputs: nothing
045347             0100*  ; destroys: a,ix,de
045347             0101*  ; affects: decrements table_active_sprites by one
045347             0102*  table_deactivate_sprite:
045347 F5          0103*      push af ; save sprite id bc we need it later
045348 CD 15 5A 04 0104*      call vdu_sprite_select
04534C CD 99 5A 04 0105*      call vdu_sprite_hide
045350 F1          0106*      pop af ; restore sprite id
045351 11 00 00 00 0107*      ld de,0 ; clear deu
045355 57          0108*      ld d,a
045356 1E 26       0109*      ld e,table_bytes_per_record
045358 ED 5C       0110*      mlt de
04535A DD 21 63 52 0111*      ld ix,table_base
       04          
04535F DD 19       0112*      add ix,de
045361 AF          0113*      xor a
045362 DD 77 01    0114*      ld (ix+sprite_type),a
045365 DD 21 FE 52 0115*      ld ix,table_active_sprites
       04          
04536A DD 35 00    0116*      dec (ix)
04536D C9          0117*      ret
04536E             0052   ; API includes
04536E             0053       include "nurples/src/asm/mos_api.inc"
04536E             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
04536E             0002*  ; Title:	AGON MOS - API for user projects
04536E             0003*  ; Author:	Dean Belfield
04536E             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
04536E             0005*  ;			Added MOS error codes for return in HL
04536E             0006*  ; Created:	03/08/2022
04536E             0007*  ; Last Updated:	10/08/2023
04536E             0008*  ;
04536E             0009*  ; Modinfo:
04536E             0010*  ; 05/08/2022:	Added mos_feof
04536E             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
04536E             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
04536E             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
04536E             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
04536E             0015*  ; 13/10/2022:	Added mos_oscli
04536E             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
04536E             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
04536E             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
04536E             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
04536E             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
04536E             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
04536E             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
04536E             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
04536E             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
04536E             0025*  ; 19/05/2023:	Added sysvar_scrMode
04536E             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
04536E             0027*  ; 03/08/2023:	Added mos_setkbvector
04536E             0028*  ; 10/08/2023:	Added mos_getkbmap
04536E             0029*  
04536E             0030*  ; VDP control (VDU 23, 0, n)
04536E             0031*  ;
04536E             0032*  vdp_gp:				EQU 80h
04536E             0033*  vdp_keycode:		EQU 81h
04536E             0034*  vdp_cursor:			EQU	82h
04536E             0035*  vdp_scrchar:		EQU	83h
04536E             0036*  vdp_scrpixel:		EQU	84h
04536E             0037*  vdp_audio:			EQU	85h
04536E             0038*  vdp_mode:			EQU	86h
04536E             0039*  vdp_rtc:			EQU	87h
04536E             0040*  vdp_keystate:		EQU	88h
04536E             0041*  vdp_logicalcoords:	EQU	C0h
04536E             0042*  vdp_terminalmode:	EQU	FFh
04536E             0043*  
04536E             0044*  ; MOS high level functions
04536E             0045*  ;
04536E             0046*  mos_getkey:			EQU	00h
04536E             0047*  mos_load:			EQU	01h
04536E             0048*  mos_save:			EQU	02h
04536E             0049*  mos_cd:				EQU	03h
04536E             0050*  mos_dir:			EQU	04h
04536E             0051*  mos_del:			EQU	05h
04536E             0052*  mos_ren:			EQU	06h
04536E             0053*  mos_mkdir:			EQU	07h
04536E             0054*  mos_sysvars:		EQU	08h
04536E             0055*  mos_editline:		EQU	09h
04536E             0056*  mos_fopen:			EQU	0Ah
04536E             0057*  mos_fclose:			EQU	0Bh
04536E             0058*  mos_fgetc:			EQU	0Ch
04536E             0059*  mos_fputc:			EQU	0Dh
04536E             0060*  mos_feof:			EQU	0Eh
04536E             0061*  mos_getError:		EQU	0Fh
04536E             0062*  mos_oscli:			EQU	10h
04536E             0063*  mos_copy:			EQU	11h
04536E             0064*  mos_getrtc:			EQU	12h
04536E             0065*  mos_setrtc:			EQU	13h
04536E             0066*  mos_setintvector:	EQU	14h
04536E             0067*  mos_uopen:			EQU	15h
04536E             0068*  mos_uclose:			EQU	16h
04536E             0069*  mos_ugetc:			EQU	17h
04536E             0070*  mos_uputc:			EQU	18h
04536E             0071*  mos_getfil:			EQU	19h
04536E             0072*  mos_fread:			EQU	1Ah
04536E             0073*  mos_fwrite:			EQU	1Bh
04536E             0074*  mos_flseek:			EQU	1Ch
04536E             0075*  mos_setkbvector:	EQU	1Dh
04536E             0076*  mos_getkbmap:		EQU	1Eh
04536E             0077*  
04536E             0078*  ; MOS program exit codes
04536E             0079*  ;
04536E             0080*  EXIT_OK:				EQU  0;	"OK",
04536E             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
04536E             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
04536E             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
04536E             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
04536E             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
04536E             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
04536E             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
04536E             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
04536E             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
04536E             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
04536E             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
04536E             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
04536E             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
04536E             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
04536E             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
04536E             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
04536E             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
04536E             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
04536E             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
04536E             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
04536E             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
04536E             0102*  ; FatFS file access functions
04536E             0103*  ;
04536E             0104*  ffs_fopen:			EQU	80h
04536E             0105*  ffs_fclose:			EQU	81h
04536E             0106*  ffs_fread:			EQU	82h
04536E             0107*  ffs_fwrite:			EQU	83h
04536E             0108*  ffs_flseek:			EQU	84h
04536E             0109*  ffs_ftruncate:		EQU	85h
04536E             0110*  ffs_fsync:			EQU	86h
04536E             0111*  ffs_fforward:		EQU	87h
04536E             0112*  ffs_fexpand:		EQU	88h
04536E             0113*  ffs_fgets:			EQU	89h
04536E             0114*  ffs_fputc:			EQU	8Ah
04536E             0115*  ffs_fputs:			EQU	8Bh
04536E             0116*  ffs_fprintf:		EQU	8Ch
04536E             0117*  ffs_ftell:			EQU	8Dh
04536E             0118*  ffs_feof:			EQU	8Eh
04536E             0119*  ffs_fsize:			EQU	8Fh
04536E             0120*  ffs_ferror:			EQU	90h
04536E             0121*  
04536E             0122*  ; FatFS directory access functions
04536E             0123*  ;
04536E             0124*  ffs_dopen:			EQU	91h
04536E             0125*  ffs_dclose:			EQU	92h
04536E             0126*  ffs_dread:			EQU	93h
04536E             0127*  ffs_dfindfirst:		EQU	94h
04536E             0128*  ffs_dfindnext:		EQU	95h
04536E             0129*  
04536E             0130*  ; FatFS file and directory management functions
04536E             0131*  ;
04536E             0132*  ffs_stat:			EQU	96h
04536E             0133*  ffs_unlink:			EQU	97h
04536E             0134*  ffs_rename:			EQU	98h
04536E             0135*  ffs_chmod:			EQU	99h
04536E             0136*  ffs_utime:			EQU	9Ah
04536E             0137*  ffs_mkdir:			EQU	9Bh
04536E             0138*  ffs_chdir:			EQU	9Ch
04536E             0139*  ffs_chdrive:		EQU	9Dh
04536E             0140*  ffs_getcwd:			EQU	9Eh
04536E             0141*  
04536E             0142*  ; FatFS volume management and system configuration functions
04536E             0143*  ;
04536E             0144*  ffs_mount:			EQU	9Fh
04536E             0145*  ffs_mkfs:			EQU	A0h
04536E             0146*  ffs_fdisk:			EQU	A1h
04536E             0147*  ffs_getfree:		EQU	A2h
04536E             0148*  ffs_getlabel:		EQU	A3h
04536E             0149*  ffs_setlabel:		EQU	A4h
04536E             0150*  ffs_setcp:			EQU	A5h
04536E             0151*  
04536E             0152*  ; File access modes
04536E             0153*  ;
04536E             0154*  fa_read:			EQU	01h
04536E             0155*  fa_write:			EQU	02h
04536E             0156*  fa_open_existing:	EQU	00h
04536E             0157*  fa_create_new:		EQU	04h
04536E             0158*  fa_create_always:	EQU	08h
04536E             0159*  fa_open_always:		EQU	10h
04536E             0160*  fa_open_append:		EQU	30h
04536E             0161*  
04536E             0162*  ; System variable indexes for api_sysvars
04536E             0163*  ; Index into _sysvars in globals.asm
04536E             0164*  ;
04536E             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
04536E             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
04536E             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
04536E             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
04536E             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
04536E             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
04536E             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
04536E             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
04536E             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
04536E             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
04536E             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
04536E             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
04536E             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
04536E             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
04536E             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
04536E             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
04536E             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
04536E             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
04536E             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
04536E             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
04536E             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
04536E             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
04536E             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
04536E             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
04536E             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
04536E             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
04536E             0191*  
04536E             0192*  ; Flags for the VPD protocol
04536E             0193*  ;
04536E             0194*  vdp_pflag_cursor:		EQU	00000001b
04536E             0195*  vdp_pflag_scrchar:		EQU	00000010b
04536E             0196*  vdp_pflag_point:		EQU	00000100b
04536E             0197*  vdp_pflag_audio:		EQU	00001000b
04536E             0198*  vdp_pflag_mode:			EQU	00010000b
04536E             0199*  vdp_pflag_rtc:			EQU	00100000b
04536E             0200*  
04536E             0201*  ;
04536E             0202*  ; FatFS structures
04536E             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
04536E             0204*  ;
04536E             0205*  ; Object ID and allocation information (FFOBJID)
04536E             0206*  ;
04536E             0207*  ; Indexes into FFOBJID structure
04536E             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
04536E             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
04536E             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
04536E             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
04536E             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
04536E             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
04536E             0214*  ;
04536E             0215*  ; File object structure (FIL)
04536E             0216*  ;
04536E             0217*  ; Indexes into FIL structure
04536E             0218*  fil_obj:		EQU 0	; 15: Object identifier
04536E             0219*  fil_flag:		EQU	15 	;  1: File status flags
04536E             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
04536E             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
04536E             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
04536E             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
04536E             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
04536E             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
04536E             0226*  ;
04536E             0227*  ; Directory object structure (DIR)
04536E             0228*  ; Indexes into DIR structure
04536E             0229*  dir_obj:		EQU  0	; 15: Object identifier
04536E             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
04536E             0231*  dir_clust:		EQU	19	;  4: Current cluster
04536E             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
04536E             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
04536E             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
04536E             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
04536E             0236*  ;
04536E             0237*  ; File information structure (FILINFO)
04536E             0238*  ;
04536E             0239*  ; Indexes into FILINFO structure
04536E             0240*  filinfo_fsize:		EQU 0	;   4: File size
04536E             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
04536E             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
04536E             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
04536E             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
04536E             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
04536E             0246*  ;
04536E             0247*  ; Macro for calling the API
04536E             0248*  ; Parameters:
04536E             0249*  ; - function: One of the function numbers listed above
04536E             0250*  ;
04536E             0251*  	MACRO	MOSCALL	function
04536E             0252*  			LD	A, function
04536E             0253*  			RST.LIL	08h
04536E             0254*  	ENDMACRO
04536E             0054       include "nurples/src/asm/functions.inc"
04536E             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
04536E             0002*  ; Print a zero-terminated string
04536E             0003*  ; HL: Pointer to string
04536E             0004*  printString:
04536E C5          0005*  	PUSH	BC
04536F 01 00 00 00 0006*  	LD		BC,0
045373 3E 00       0007*  	LD 	 	A,0
045375 5B DF       0008*  	RST.LIL 18h
045377 C1          0009*  	POP		BC
045378 C9          0010*  	RET
045379             0011*  ; print a VDU sequence
045379             0012*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
045379             0013*  sendVDUsequence:
045379 C5          0014*  	PUSH	BC
04537A 01 00 00 00 0015*  	LD		BC, 0
04537E 4E          0016*  	LD		C, (HL)
04537F 5B DF       0017*  	RST.LIL	18h
045381 C1          0018*  	POP		BC
045382 C9          0019*  	RET
045383             0020*  ; Print Newline sequence to VDP
045383             0021*  printNewline:
045383 3E 0D       0022*  	LD	A, '\r'
045385 5B D7       0023*  	RST.LIL 10h
045387 3E 0A       0024*  	LD	A, '\n'
045389 5B D7       0025*  	RST.LIL 10h
04538B C9          0026*  	RET
04538C             0027*  ; Print a 24-bit HEX number
04538C             0028*  ; HLU: Number to print
04538C             0029*  printHex24:
04538C E5          0030*  	PUSH	HL
04538D 21 02 00 00 0031*  	LD		HL, 2
045391 39          0032*  	ADD		HL, SP
045392 7E          0033*  	LD		A, (HL)
045393 E1          0034*  	POP		HL
045394 CD 9E 53 04 0035*  	CALL	printHex8
045398             0036*  ; Print a 16-bit HEX number
045398             0037*  ; HL: Number to print
045398             0038*  printHex16:
045398 7C          0039*  	LD		A,H
045399 CD 9E 53 04 0040*  	CALL	printHex8
04539D 7D          0041*  	LD		A,L
04539E             0042*  ; Print an 8-bit HEX number
04539E             0043*  ; A: Number to print
04539E             0044*  printHex8:
04539E 4F          0045*  	LD		C,A
04539F 1F          0046*  	RRA
0453A0 1F          0047*  	RRA
0453A1 1F          0048*  	RRA
0453A2 1F          0049*  	RRA
0453A3 CD A8 53 04 0050*  	CALL	@F
0453A7 79          0051*  	LD		A,C
0453A8             0052*  @@:
0453A8 E6 0F       0053*  	AND		0Fh
0453AA C6 90       0054*  	ADD		A,90h
0453AC 27          0055*  	DAA
0453AD CE 40       0056*  	ADC		A,40h
0453AF 27          0057*  	DAA
0453B0 5B D7       0058*  	RST.LIL	10h
0453B2 C9          0059*  	RET
0453B3             0060*  
0453B3             0061*  ; Print a 0x HEX prefix
0453B3             0062*  DisplayHexPrefix:
0453B3 3E 30       0063*  	LD	A, '0'
0453B5 5B D7       0064*  	RST.LIL 10h
0453B7 3E 78       0065*  	LD	A, 'x'
0453B9 5B D7       0066*  	RST.LIL 10h
0453BB C9          0067*  	RET
0453BC             0068*  
0453BC             0069*  ; Prints the decimal value in HL without leading zeroes
0453BC             0070*  ; HL : Value to print
0453BC             0071*  printDec:
0453BC 11 CD 53 04 0072*  	LD	 DE, _printDecBuffer
0453C0 CD D6 53 04 0073*  	CALL Num2String
0453C4 21 CD 53 04 0074*  	LD	 HL, _printDecBuffer
0453C8 CD 6E 53 04 0075*  	CALL printString
0453CC C9          0076*  	RET
0453CD             0077*  _printDecBuffer:
0453CD             0078*  	DS 9
0453D6             0079*  ; This routine converts the value from HL into it's ASCII representation,
0453D6             0080*  ; starting to memory location pointing by DE, in decimal form and with trailing zeroes
0453D6             0081*  ; so it will allways be 5 characters length
0453D6             0082*  ; HL : Value to convert to string
0453D6             0083*  ; DE : pointer to buffer, at least 8 byte + 0
0453D6             0084*  Num2String:
0453D6 D5          0085*  	PUSH DE
0453D7 CD F5 53 04 0086*  	CALL Num2String_worker
0453DB 3E 00       0087*  	LD	 A, 0
0453DD 12          0088*  	LD	 (DE), A	; terminate string
0453DE D1          0089*  	POP  DE
0453DF D5          0090*  	PUSH DE
0453E0             0091*  @findfirstzero:
0453E0 1A          0092*  	LD	 A, (DE)
0453E1 FE 30       0093*  	CP	 '0'
0453E3 20 03       0094*  	JR	 NZ, @done
0453E5 13          0095*  	INC  DE
0453E6 18 F8       0096*  	JR	 @findfirstzero
0453E8             0097*  @done:
0453E8 B7          0098*  	OR	 A	; end-of-string reached / was the value 0?
0453E9 20 01       0099*  	JR	 NZ, @removezeroes
0453EB 1B          0100*  	DEC  DE
0453EC             0101*  @removezeroes:
0453EC E1          0102*  	POP	 HL	; start of string, DE == start of first number
0453ED             0103*  @copydigit:
0453ED 1A          0104*  	LD	A, (DE)
0453EE 77          0105*  	LD	(HL), A
0453EF B7          0106*  	OR  A
0453F0 C8          0107*  	RET	Z
0453F1 23          0108*  	INC	HL
0453F2 13          0109*  	INC DE
0453F3 18 F8       0110*  	JR	@copydigit
0453F5             0111*  
0453F5             0112*  Num2String_worker:
0453F5 01 80 69 67 0113*  	LD	 BC,-10000000
0453F9 CD 2C 54 04 0114*  	CALL OneDigit
0453FD 01 C0 BD F0 0115*  	LD	 BC,-1000000
045401 CD 2C 54 04 0116*  	CALL OneDigit
045405 01 60 79 FE 0117*  	LD	 BC,-100000
045409 CD 2C 54 04 0118*  	CALL OneDigit
04540D 01 F0 D8 FF 0119*  	LD   BC,-10000
045411 CD 2C 54 04 0120*  	CALL OneDigit
045415 01 18 FC FF 0121*  	LD   BC,-1000
045419 CD 2C 54 04 0122*  	CALL OneDigit
04541D 01 9C FF FF 0123*  	LD   BC,-100
045421 CD 2C 54 04 0124*  	CALL OneDigit
045425 0E F6       0125*  	LD   C,-10
045427 CD 2C 54 04 0126*  	CALL OneDigit
04542B 48          0127*  	LD   C,B
04542C             0128*  OneDigit:
04542C 3E 2F       0129*  	LD   A,'0'-1
04542E             0130*  DivideMe:
04542E 3C          0131*  	INC  A
04542F 09          0132*  	ADD  HL,BC
045430 38 FC       0133*  	JR   C,DivideMe
045432 ED 42       0134*  	SBC  HL,BC
045434 12          0135*  	LD   (DE),A
045435 13          0136*  	INC  DE
045436 C9          0137*  	RET
045437             0138*  
045437             0139*  
045437             0140*  ; #### new functions added by Brandon R. Gates ####
045437             0141*  
045437             0142*  ; print the binary representation of the 8-bit value in a
045437             0143*  ; destroys a, hl, bc
045437             0144*  printBin8:
045437 06 08       0145*      ld b,8      ; loop counter for 8 bits
045439 21 54 54 04 0146*      ld hl,@cmd  ; set hl to the low byte of the output string
04543D             0147*                  ; (which will be the high bit of the value in a)
04543D             0148*  @loop:
04543D 07          0149*      rlca ; put the next highest bit into carry
04543E 38 04       0150*      jr c,@one
045440 36 30       0151*      ld (hl),'0'
045442 18 02       0152*      jr @next_bit
045444             0153*  @one:
045444 36 31       0154*      ld (hl),'1'
045446             0155*  @next_bit:
045446 23          0156*      inc hl
045447 10 F4       0157*      djnz @loop
045449             0158*  ; print it
045449 21 54 54 04 0159*  	ld hl,@cmd
04544D 01 08 00 00 0160*  	ld bc,@end-@cmd
045451 5B DF       0161*  	rst.lil $18
045453 C9          0162*  	ret
045454             0163*  @cmd: ds 8 ; eight bytes for eight bits
04545C             0164*  @end:
04545C             0165*  
04545C             0166*  ; print registers to screen in hexidecimal format
04545C             0167*  ; inputs: none
04545C             0168*  ; outputs: values of every register printed to screen
04545C             0169*  ;    values of each register in global scratch memory
04545C             0170*  ; destroys: nothing
04545C             0171*  dumpRegistersHex:
04545C             0172*  ; store everything in scratch
04545C 22 7B 5B 04 0173*      ld (uhl),hl
045460 ED 43 7F 5B 0174*      ld (ubc),bc
       04          
045465 ED 53 83 5B 0175*      ld (ude),de
       04          
04546A DD 22 87 5B 0176*      ld (uix),ix
       04          
04546F FD 22 8B 5B 0177*      ld (uiy),iy
       04          
045474 F5          0178*      push af ; fml
045475 E1          0179*      pop hl  ; thanks, zilog
045476 22 77 5B 04 0180*      ld (uaf),hl
04547A F5          0181*      push af ; dammit
04547B             0182*  
04547B             0183*  ; home the cursor
04547B             0184*      ; call vdu_home_cursor
04547B             0185*  
04547B             0186*  ; print each register
04547B 21 11 55 04 0187*      ld hl,@str_afu
04547F CD 6E 53 04 0188*      call printString
045483 2A 77 5B 04 0189*      ld hl,(uaf)
045487 CD 8C 53 04 0190*      call printHex24
04548B CD 83 53 04 0191*      call printNewline
04548F             0192*  
04548F 21 15 55 04 0193*      ld hl,@str_hlu
045493 CD 6E 53 04 0194*      call printString
045497 2A 7B 5B 04 0195*      ld hl,(uhl)
04549B CD 8C 53 04 0196*      call printHex24
04549F CD 83 53 04 0197*      call printNewline
0454A3             0198*  
0454A3 21 19 55 04 0199*      ld hl,@str_bcu
0454A7 CD 6E 53 04 0200*      call printString
0454AB 2A 7F 5B 04 0201*      ld hl,(ubc)
0454AF CD 8C 53 04 0202*      call printHex24
0454B3 CD 83 53 04 0203*      call printNewline
0454B7             0204*  
0454B7 21 1D 55 04 0205*      ld hl,@str_deu
0454BB CD 6E 53 04 0206*      call printString
0454BF 2A 83 5B 04 0207*      ld hl,(ude)
0454C3 CD 8C 53 04 0208*      call printHex24
0454C7 CD 83 53 04 0209*      call printNewline
0454CB             0210*  
0454CB 21 21 55 04 0211*      ld hl,@str_ixu
0454CF CD 6E 53 04 0212*      call printString
0454D3 2A 87 5B 04 0213*      ld hl,(uix)
0454D7 CD 8C 53 04 0214*      call printHex24
0454DB CD 83 53 04 0215*      call printNewline
0454DF             0216*  
0454DF 21 25 55 04 0217*      ld hl,@str_iyu
0454E3 CD 6E 53 04 0218*      call printString
0454E7 2A 8B 5B 04 0219*      ld hl,(uiy)
0454EB CD 8C 53 04 0220*      call printHex24
0454EF CD 83 53 04 0221*      call printNewline
0454F3             0222*  
0454F3             0223*      ; call vsync
0454F3             0224*  
0454F3 CD 83 53 04 0225*      call printNewline
0454F7             0226*  ; restore everything
0454F7 2A 7B 5B 04 0227*      ld hl, (uhl)
0454FB ED 4B 7F 5B 0228*      ld bc, (ubc)
       04          
045500 ED 5B 83 5B 0229*      ld de, (ude)
       04          
045505 DD 2A 87 5B 0230*      ld ix, (uix)
       04          
04550A FD 2A 8B 5B 0231*      ld iy, (uiy)
       04          
04550F F1          0232*      pop af
045510             0233*  ; all done
045510 C9          0234*      ret
045511             0235*  
045511 61 66 3D 00 0236*  @str_afu: db "af=",0
045515 68 6C 3D 00 0237*  @str_hlu: db "hl=",0
045519 62 63 3D 00 0238*  @str_bcu: db "bc=",0
04551D 64 65 3D 00 0239*  @str_deu: db "de=",0
045521 69 78 3D 00 0240*  @str_ixu: db "ix=",0
045525 69 79 3D 00 0241*  @str_iyu: db "iy=",0
045529             0242*  
045529             0243*  ; print udeuhl to screen in hexidecimal format
045529             0244*  ; inputs: none
045529             0245*  ; outputs: concatenated hexidecimal udeuhl
045529             0246*  ; destroys: nothing
045529             0247*  dumpUDEUHLHex:
045529             0248*  ; store everything in scratch
045529 22 7B 5B 04 0249*      ld (uhl),hl
04552D ED 43 7F 5B 0250*      ld (ubc),bc
       04          
045532 ED 53 83 5B 0251*      ld (ude),de
       04          
045537 DD 22 87 5B 0252*      ld (uix),ix
       04          
04553C FD 22 8B 5B 0253*      ld (uiy),iy
       04          
045541 F5          0254*      push af
045542             0255*  
045542             0256*  ; print each register
045542             0257*  
045542 21 7C 55 04 0258*      ld hl,@str_udeuhl
045546 CD 6E 53 04 0259*      call printString
04554A 2A 83 5B 04 0260*      ld hl,(ude)
04554E CD 8C 53 04 0261*      call printHex24
045552 3E 2E       0262*  	ld a,'.'	; print a dot to separate the values
045554 5B D7       0263*  	rst.lil 10h
045556 2A 7B 5B 04 0264*      ld hl,(uhl)
04555A CD 8C 53 04 0265*      call printHex24
04555E CD 83 53 04 0266*      call printNewline
045562             0267*  
045562             0268*  ; restore everything
045562 2A 7B 5B 04 0269*      ld hl, (uhl)
045566 ED 4B 7F 5B 0270*      ld bc, (ubc)
       04          
04556B ED 5B 83 5B 0271*      ld de, (ude)
       04          
045570 DD 2A 87 5B 0272*      ld ix, (uix)
       04          
045575 FD 2A 8B 5B 0273*      ld iy, (uiy)
       04          
04557A F1          0274*      pop af
04557B             0275*  ; all done
04557B C9          0276*      ret
04557C             0277*  
04557C 75 64 65 2E 0278*  @str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
045585             0279*  
045585             0280*  ; ; global scratch memory for registers
045585             0281*  ; uaf: dl 0
045585             0282*  ; uhl: dl 0
045585             0283*  ; ubc: dl 0
045585             0284*  ; ude: dl 0
045585             0285*  ; uix: dl 0
045585             0286*  ; uiy: dl 0
045585             0287*  ; usp: dl 0
045585             0288*  ; upc: dl 0
045585             0289*  
045585             0290*  ; inputs: whatever is in the flags register
045585             0291*  ; outputs: binary representation of flags
045585             0292*  ;          with a header so we know which is what
045585             0293*  ; destroys: hl
045585             0294*  ; preserves: af
045585             0295*  dumpFlags:
045585             0296*  ; first we curse zilog for not giving direct access to flags
045585 F5          0297*      push af ; this is so we can send it back unharmed
045586 F5          0298*      push af ; this is so we can pop it to hl
045587             0299*  ; store everything in scratch
045587 22 7B 5B 04 0300*      ld (uhl),hl
04558B ED 43 7F 5B 0301*      ld (ubc),bc
       04          
045590 ED 53 83 5B 0302*      ld (ude),de
       04          
045595 DD 22 87 5B 0303*      ld (uix),ix
       04          
04559A FD 22 8B 5B 0304*      ld (uiy),iy
       04          
04559F             0305*  ; next we print the header
04559F 21 CB 55 04 0306*      ld hl,@header
0455A3 CD 6E 53 04 0307*      call printString
0455A7 E1          0308*      pop hl ; flags are now in l
0455A8 7D          0309*      ld a,l ; flags are now in a
0455A9 CD 37 54 04 0310*      call printBin8
0455AD CD 83 53 04 0311*  	call printNewline
0455B1             0312*  ; restore everything
0455B1 2A 7B 5B 04 0313*      ld hl, (uhl)
0455B5 ED 4B 7F 5B 0314*      ld bc, (ubc)
       04          
0455BA ED 5B 83 5B 0315*      ld de, (ude)
       04          
0455BF DD 2A 87 5B 0316*      ld ix, (uix)
       04          
0455C4 FD 2A 8B 5B 0317*      ld iy, (uiy)
       04          
0455C9 F1          0318*      pop af ; send her home the way she came
0455CA C9          0319*      ret
0455CB             0320*  ; Bit 7 (S): Sign flag
0455CB             0321*  ; Bit 6 (Z): Zero flag
0455CB             0322*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0455CB             0323*  ; Bit 4 (H): Half Carry flag
0455CB             0324*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0455CB             0325*  ; Bit 2 (PV): Parity/Overflow flag
0455CB             0326*  ; Bit 1 (N): Subtract flag
0455CB             0327*  ; Bit 0 (C): Carry flag
0455CB 53 5A 78 48 0328*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0455D6             0329*  
0455D6             0330*  ; set all the bits in the flag register
0455D6             0331*  ; more of an academic exercise than anything useful
0455D6             0332*  ; inputs; none
0455D6             0333*  ; outputs; a=0,f=255
0455D6             0334*  ; destroys: flags, hl
0455D6             0335*  ; preserves: a, because why not
0455D6             0336*  setAllFlags:
0455D6 21 FF 00 00 0337*      ld hl,255
0455DA 67          0338*      ld h,a ; four cycles to preserve a is cheap
0455DB E5          0339*      push hl
0455DC F1          0340*      pop af
0455DD C9          0341*      ret
0455DE             0342*  
0455DE             0343*  ; reset all the bits in the flag register
0455DE             0344*  ; unlike its inverse counterpart, this may actually be useful
0455DE             0345*  ; inputs; none
0455DE             0346*  ; outputs; a=0,f=0
0455DE             0347*  ; destroys: flags, hl
0455DE             0348*  ; preserves: a, because why not
0455DE             0349*  resetAllFlags:
0455DE 21 00 00 00 0350*      ld hl,0
0455E2 67          0351*      ld h,a ; four cycles to preserve a is cheap
0455E3 E5          0352*      push hl
0455E4 F1          0353*      pop af
0455E5 C9          0354*      ret
0455E6             0355*  
0455E6             0356*  ; ------------------
0455E6             0357*  ; delay routine
0455E6             0358*  ; Author: Richard Turrnidge
0455E6             0359*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.asm
0455E6             0360*  ; routine waits a fixed time, then returns
0455E6             0361*  ; arrive with A =  the delay byte. One bit to be set only.
0455E6             0362*  ; eg. ld A, 00000100b
0455E6             0363*  
0455E6             0364*  multiPurposeDelay:
0455E6 C5          0365*      push bc
0455E7 47          0366*      ld b, a
0455E8 3E 08       0367*      ld a,$08
0455EA 5B CF       0368*      RST.LIL	08h                 ; get IX pointer to sysvars
0455EC             0369*  
0455EC             0370*  waitLoop:
0455EC             0371*  
0455EC DD 7E 00    0372*      ld a, (ix + 0)              ; ix+0h is lowest byte of clock timer
0455EF             0373*  
0455EF             0374*                                  ;   we check if bit set is same as last time we checked.
0455EF             0375*                                  ;   bit 0 - don't use
0455EF             0376*                                  ;   bit 1 - changes 64 times per second
0455EF             0377*                                  ;   bit 2 - changes 32 times per second
0455EF             0378*                                  ;   bit 3 - changes 16 times per second
0455EF             0379*  
0455EF             0380*                                  ;   bit 4 - changes 8 times per second
0455EF             0381*                                  ;   bit 5 - changes 4 times per second
0455EF             0382*                                  ;   bit 6 - changes 2 times per second
0455EF             0383*                                  ;   bit 7 - changes 1 times per second
0455EF A0          0384*      and b
0455F0 4F          0385*      ld c,a
0455F1 3A FF 55 04 0386*      ld a, (oldTimeStamp)
0455F5 B9          0387*      cp c                        ; is A same as last value?
0455F6 28 F4       0388*      jr z, waitLoop              ; loop here if it is
0455F8 79          0389*      ld a, c
0455F9 32 FF 55 04 0390*      ld (oldTimeStamp), a        ; set new value
0455FD             0391*  
0455FD C1          0392*      pop bc
0455FE C9          0393*      ret
0455FF             0394*  
0455FF 00          0395*  oldTimeStamp:   .db 00h
045600             0055       include "nurples/src/asm/vdu.inc"
045600             0001*  ; The following is a high-level list of the VDU sequences that are supported:
045600             0002*  ; VDU 0: Null (no operation)
045600             0003*  ; VDU 1: Send next character to printer (if printer is enabled) 
045600             0004*  ; VDU 2: Enable printer 
045600             0005*  ; VDU 3: Disable printer 
045600             0006*  ; VDU 4: Write text at text cursor
045600             0007*  ; VDU 5: Write text at graphics cursor
045600             0008*  ; VDU 6: Enable screen (opposite of VDU 21) 
045600             0009*  ; VDU 7: Make a short beep (BEL)
045600             0010*  ; VDU 8: Move cursor back one character
045600             0011*  ; VDU 9: Move cursor forward one character
045600             0012*  ; VDU 10: Move cursor down one line
045600             0013*  ; VDU 11: Move cursor up one line
045600             0014*  ; VDU 12: Clear text area (CLS)
045600             0015*  ; VDU 13: Carriage return
045600             0016*  ; VDU 14: Page mode On *
045600             0017*  ; VDU 15: Page mode Off *
045600             0018*  ; VDU 16: Clear graphics area (CLG)
045600             0019*  ; VDU 17, colour: Define text colour (COLOUR)
045600             0020*  ; VDU 18, mode, colour: Define graphics colour (GCOL mode, colour)
045600             0021*  ; VDU 19, l, p, r, g, b: Define logical colour (COLOUR l, p / COLOUR l, r, g, b)
045600             0022*  ; VDU 20: Reset palette and text/graphics colours and drawing modes 
045600             0023*  ; VDU 21: Disable screen (turns of VDU command processing, except for VDU 1 and VDU 6) 
045600             0024*  ; VDU 22, n: Select screen mode (MODE n)
045600             0025*  ; VDU 23, n: Re-program display character / System Commands
045600             0026*  ; VDU 24, left; bottom; right; top;: Set graphics viewport **
045600             0027*  ; VDU 25, mode, x; y;: PLOT command
045600             0028*  ; VDU 26: Reset graphics and text viewports **
045600             0029*  ; VDU 27, char: Output character to screen 
045600             0030*  ; VDU 28, left, bottom, right, top: Set text viewport **
045600             0031*  ; VDU 29, x; y;: Set graphics origin
045600             0032*  ; VDU 30: Home cursor
045600             0033*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
045600             0034*  ; VDU 127: Backspace
045600             0035*  
045600             0036*  ; VDU 0: Null (no operation)
045600             0037*  ;     On encountering a VDU 0 command, the VDP will do nothing.
045600             0038*  ;     This may be useful for padding out a VDU command sequence,
045600             0039*  ;     or for inserting a placeholder for a command that will be added later.
045600             0040*  ; inputs: none
045600             0041*  ; outputs: an empty byte somewhere in VDU
045600             0042*  ; destroys: a
045600             0043*  vdu_null:
045600 AF          0044*      xor a
045601 5B D7       0045*  	rst.lil $10
045603 C9          0046*  	ret
045604             0047*  
045604             0048*  ; VDU 1: Send next character to printer (if printer is enabled) 
045604             0049*  ;     Ensures that the next character received by the VDP is sent through to
045604             0050*  ;     the printer, and not to the screen. This is useful for sending control
045604             0051*  ;     codes to the printer, or for sending data to the printer that is not
045604             0052*  ;     intended to be displayed on the screen. It allows characters that would
045604             0053*  ;     not otherwise normally be sent through to the printer to be sent.
045604             0054*  ;     If the printer has not been enabled then this command will just discard
045604             0055*  ;     the next byte sent to the VDP.
045604             0056*  ; inputs: a is the ascii code of the character to send
045604             0057*  ; prerequisites: "printer" must first be activated with VDU 2 (see below)
045604             0058*  ; outputs: a character on the serial terminal connected to the USB port
045604             0059*  ;           and the same character on the screen at the current text cursor location
045604             0060*  ; QUESTION: does it also advance the text cursor?
045604             0061*  ; destroys: hl, bc
045604             0062*  vdu_char_to_printer:
045604 32 14 56 04 0063*  	ld (@arg),a
045608 21 13 56 04 0064*  	ld hl,@cmd
04560C 01 02 00 00 0065*  	ld bc,@end-@cmd
045610 5B DF       0066*  	rst.lil $18
045612 C9          0067*  	ret
045613 01          0068*  @cmd: db 1
045614 00          0069*  @arg: db 0
045615             0070*  @end:
045615             0071*  
045615             0072*  ; VDU 2: Enable printer 
045615             0073*  ;     Enables the printer.
045615             0074*  ;     In the context of the Agon platform, the printer is a serial
045615             0075*  ;     terminal that is connected to the VDPs USB port. Typically
045615             0076*  ;     this port is used for power, but it can also be used to send and
045615             0077*  ;     receive data to and from the VDP.
045615             0078*  ;     When the printer is enabled, the VDP will send characters it receives
045615             0079*  ;     to the printer as well as to the screen. It will additionally send
045615             0080*  ;     through control codes 8-13. To send other control codes to the printer,
045615             0081*  ;     use the VDU 1 command.
045615             0082*  ;     The VDP will not send through other control codes to the printer,
045615             0083*  ;     and will will not send through data it receives as part of other commands.
045615             0084*  vdu_enable_printer:
045615 3E 02       0085*      ld a,2
045617 5B D7       0086*  	rst.lil $10
045619 C9          0087*  	ret
04561A             0088*  
04561A             0089*  ; VDU 3: Disable printer 
04561A             0090*  ; inputs: none
04561A             0091*  ; outputs: a USB port bereft of communication with the VDP
04561A             0092*  ; destroys: a
04561A             0093*  vdu_disable_printer:
04561A 3E 03       0094*      ld a,3
04561C 5B D7       0095*  	rst.lil $10
04561E C9          0096*  	ret
04561F             0097*  
04561F             0098*  ; VDU 4: Write text at text cursor
04561F             0099*  ;     This causes text to be written at the current text cursor position.
04561F             0100*  ;     This is the default mode for text display.
04561F             0101*  ;     Text is written using the current text foreground and background colours.
04561F             0102*  ; inputs: a is the character to write to the screen
04561F             0103*  ; prerequisites: the text cursor at the intended position on screen
04561F             0104*  ; outputs: prints the character and moves text cursor right one position
04561F             0105*  ; destroys: a, hl, bc
04561F             0106*  vdu_char_to_text_cursor:
04561F 32 2F 56 04 0107*  	ld (@arg),a
045623 21 2E 56 04 0108*  	ld hl,@cmd
045627 01 02 00 00 0109*  	ld bc,@end-@cmd
04562B 5B DF       0110*  	rst.lil $18
04562D C9          0111*  	ret
04562E 04          0112*  @cmd: db 4
04562F 00          0113*  @arg: db 0
045630             0114*  @end:
045630             0115*  
045630             0116*  ; VDU 5: Write text at graphics cursor
045630             0117*  ;     This causes text to be written at the current graphics cursor position.
045630             0118*  ;     Using this, characters may be positioned at any graphics coordinate within
045630             0119*  ;     the graphics viewport. This is useful for positioning text over graphics,
045630             0120*  ;     or for positioning text at a specific location on the screen.
045630             0121*  ;     Characters are plotted using the current graphics foreground colour,
045630             0122*  ;     using the current graphics foreground plotting mode (see VDU 18).
045630             0123*  ;     The character background is transparent, and will not overwrite any
045630             0124*  ;     graphics that are already present at the characters location.
045630             0125*  ;     The exception to this is VDU 27, the delete character, which backspaces
045630             0126*  ;     and deletes as per its usual behaviour, but will erase using the current
045630             0127*  ;     graphics background colour.
045630             0128*  ; inputs: a is the character to write to the screen
045630             0129*  ; prerequisites: the graphics cursor at the intended position on screen
045630             0130*  ; outputs: see the name of the function
045630             0131*  ; destroys: a, hl, bc
045630             0132*  vdu_char_to_gfx_cursor:
045630 32 40 56 04 0133*  	ld (@arg),a
045634 21 3F 56 04 0134*  	ld hl,@cmd
045638 01 02 00 00 0135*  	ld bc,@end-@cmd
04563C 5B DF       0136*  	rst.lil $18
04563E C9          0137*  	ret
04563F 05          0138*  @cmd: db 5
045640 00          0139*  @arg: db 0
045641             0140*  @end:
045641             0141*  
045641             0142*  ; VDU 6: Enable screen (opposite of VDU 21) 
045641             0143*  ;     This enables the screen, and re-enables VDU command processing,
045641             0144*  ;     reversing the effect of VDU 21.
045641             0145*  ; inputs: none
045641             0146*  ; outputs: a functioning screen and VDU
045641             0147*  ; destroys: a
045641             0148*  vdu_enable_screen:
045641 3E 06       0149*      ld a,6
045643 5B D7       0150*  	rst.lil $10
045645 C9          0151*  	ret
045646             0152*  
045646             0153*  ; PASSES
045646             0154*  ; VDU 7: Make a short beep (BEL)
045646             0155*  ;     Plays a short beep sound on audio channel 0. If the audio channel
045646             0156*  ;     is already in use, or has been disabled, then this command will have no effect.
045646             0157*  ; inputs: none
045646             0158*  ; outputs: an unpleasant but thankfully short-lived audio tone
045646             0159*  ; destroys: a
045646             0160*  vdu_beep:
045646 3E 07       0161*      ld a,7
045648 5B D7       0162*  	rst.lil $10
04564A C9          0163*  	ret
04564B             0164*  
04564B             0165*  ; VDU 8: Move cursor back one character
04564B             0166*  ;     Moves the text cursor one character in the negative X direction.
04564B             0167*  ;     By default, when at the start of a line it will move to the end of
04564B             0168*  ;     the previous line (as defined by the current text viewport).
04564B             0169*  ;     If the cursor is also at the top of the screen then the viewport will scroll down.
04564B             0170*  ;     The cursor remains constrained to the current text viewport.
04564B             0171*  ;     When in VDU 5 mode and the graphics cursor is active, the viewport will not scroll.
04564B             0172*  ;     The cursor is just moved left by one character width.
04564B             0173*  ;     Further behaviour of the cursor can be controlled using the VDU 23,16 command.
04564B             0174*  ;     It should be noted that as of Console8 VDP 2.5.0, the cursor system does not
04564B             0175*  ;     support adjusting the direction of the cursors X axis, so this command
04564B             0176*  ;     will move the cursor to the left. This is likely to change in the future.
04564B             0177*  vdu_cursor_back:
04564B 3E 08       0178*      ld a,8
04564D 5B D7       0179*  	rst.lil $10
04564F C9          0180*  	ret
045650             0181*  
045650             0182*  ; VDU 9: Move cursor forward one character
045650             0183*  vdu_cursor_forward:
045650 3E 09       0184*      ld a,9
045652 5B D7       0185*  	rst.lil $10
045654 C9          0186*  	ret
045655             0187*  
045655             0188*  ; VDU 10: Move cursor down one line
045655             0189*  vdu_cursor_down:
045655 3E 0A       0190*      ld a,10
045657 5B D7       0191*  	rst.lil $10
045659 C9          0192*  	ret
04565A             0193*  
04565A             0194*  ; VDU 11: Move cursor up one line
04565A             0195*  vdu_cursor_up:
04565A 3E 0B       0196*      ld a,11
04565C 5B D7       0197*  	rst.lil $10
04565E C9          0198*  	ret
04565F             0199*  
04565F             0200*  ; VDU 12: Clear text area (CLS)
04565F             0201*  vdu_cls:
04565F 3E 0C       0202*      ld a,12
045661 5B D7       0203*  	rst.lil $10
045663 C9          0204*  	ret
045664             0205*  
045664             0206*  ; VDU 13: Carriage return
045664             0207*  vdu_cr:
045664 3E 0D       0208*      ld a,13
045666 5B D7       0209*  	rst.lil $10
045668 C9          0210*  	ret
045669             0211*  
045669             0212*  ; VDU 14: Page mode On *
045669             0213*  vdu_page_on:
045669 3E 0E       0214*      ld a,14
04566B 5B D7       0215*  	rst.lil $10
04566D C9          0216*  	ret
04566E             0217*  
04566E             0218*  ; VDU 15: Page mode Off *
04566E             0219*  vdu_page_off:
04566E 3E 0F       0220*      ld a,15
045670 5B D7       0221*  	rst.lil $10
045672 C9          0222*  	ret
045673             0223*  
045673             0224*  ; VDU 16: Clear graphics area (CLG)
045673             0225*  vdu_clg:
045673 3E 10       0226*      ld a,16
045675 5B D7       0227*  	rst.lil $10
045677 C9          0228*  	ret
045678             0229*  
045678             0230*  ; VDU 17, colour: Define text colour (COLOUR)
045678             0231*  vdu_colour_text:
045678 32 88 56 04 0232*  	ld (@arg),a
04567C 21 87 56 04 0233*  	ld hl,@cmd
045680 01 02 00 00 0234*  	ld bc,@end-@cmd
045684 5B DF       0235*  	rst.lil $18
045686 C9          0236*  	ret
045687 11          0237*  @cmd: db 17
045688 00          0238*  @arg: db 0
045689             0239*  @end:
045689             0240*  
045689             0241*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
045689             0242*  ; inputs: a is the plotting mode, c is the colour
045689             0243*  ; outputs: a VDU set to put pixels on the screen with the selected mode/colour
045689             0244*  vdu_gcol_fg:
045689             0245*  ; This command will set both the current graphics colour,
045689             0246*  ; and the current graphics plotting mode.
045689             0247*  ; As with VDU 17 the colour number will set the foreground colour
045689             0248*  ; if it is in the range 0-127, or the background colour if it is
045689             0249*  ; in the range 128-255, and will be interpreted in the same manner.
045689             0250*  ; Support for different plotting modes on Agon is currently very limited.
045689             0251*  ; The only fully supported mode is mode 0, which is the default mode.
045689             0252*  ; This mode will plot the given colour at the given graphics coordinate,
045689             0253*  ; and will overwrite any existing graphics at that coordinate. There is
045689             0254*  ; very limited support for mode 4, which will invert the colour of any
045689             0255*  ; existing graphics at the given coordinate, but this is not fully supported
045689             0256*  ; and may not work as expected.
045689             0257*  ; Support for other plotting modes, matching those provided by Acorns
045689             0258*  ; original VDU system, may be added in the future.
045689             0259*  ; This command is identical to the BASIC GCOL keyword.
045689 32 9E 56 04 0260*  	ld (@mode),a
04568D 79          0261*      ld a,c
04568E 32 9F 56 04 0262*      ld (@col),a
045692 21 9D 56 04 0263*  	ld hl,@cmd
045696 01 03 00 00 0264*  	ld bc,@end-@cmd
04569A 5B DF       0265*  	rst.lil $18
04569C C9          0266*  	ret
04569D 12          0267*  @cmd: db 18
04569E 00          0268*  @mode: db 0
04569F 00          0269*  @col: db 0
0456A0             0270*  @end:
0456A0             0271*  
0456A0             0272*  vdu_gcol_bg:
0456A0 32 B7 56 04 0273*  	ld (@mode),a
0456A4 79          0274*      ld a,c
0456A5 C6 80       0275*      add a,128
0456A7 32 B8 56 04 0276*      ld (@col),a
0456AB 21 B6 56 04 0277*  	ld hl,@cmd
0456AF 01 03 00 00 0278*  	ld bc,@end-@cmd
0456B3 5B DF       0279*  	rst.lil $18
0456B5 C9          0280*  	ret
0456B6 12          0281*  @cmd:  db 18
0456B7 00          0282*  @mode: db 0
0456B8 00          0283*  @col:  db 0
0456B9             0284*  @end:
0456B9             0285*  
0456B9             0286*  ; VDU 19, l, p, r, g, b: Define logical colour (COLOUR l, p / COLOUR l, r, g, b)
0456B9             0287*  ;     This command sets the colour palette, by mapping a logical colour
0456B9             0288*  ;     to a physical colour. This is useful for defining custom colours,
0456B9             0289*  ;     or for redefining the default colours.
0456B9             0290*  ;     If the physical colour number is given as 255 then the colour will
0456B9             0291*  ;     be defined using the red, green, and blue values given. If the physical
0456B9             0292*  ;     colour number is given as any other value then the colour will be defined
0456B9             0293*  ;     using the colour palette entry given by that number, up to colour number 63.
0456B9             0294*  ;     If the physical colour is not 255 then the red, green, and blue values
0456B9             0295*  ;     must still be provided, but will be ignored.
0456B9             0296*  ;     The values for red, green and blue must be given in the range 0-255.
0456B9             0297*  ;     You should note that the physical Agon hardware only supports 64 colours,
0456B9             0298*  ;     so the actual colour displayed may not be exactly the same as the colour
0456B9             0299*  ;     requested. The nearest colour will be chosen.
0456B9             0300*  ;     This command is equivalent to the BASIC COLOUR keyword.
0456B9             0301*  ; inputs: a=physcial colour, b=logical colour, chl=r,g,b
0456B9             0302*  vdu_def_log_colour:
0456B9 32 DE 56 04 0303*  	ld (@physical),a
0456BD 47          0304*      ld b,a
0456BE 32 DD 56 04 0305*      ld (@logical),a
0456C2 79          0306*      ld a,c
0456C3 32 DF 56 04 0307*      ld (@red),a
0456C7 7C          0308*      ld a,h
0456C8 32 E0 56 04 0309*      ld (@green),a
0456CC 7D          0310*      ld a,l
0456CD 32 E1 56 04 0311*      ld (@blue),a
0456D1 21 DC 56 04 0312*  	ld hl,@cmd
0456D5 01 06 00 00 0313*  	ld bc,@end-@cmd
0456D9 5B DF       0314*  	rst.lil $18
0456DB C9          0315*  	ret
0456DC 13          0316*  @cmd: db 19
0456DD 00          0317*  @logical: db 0
0456DE 00          0318*  @physical: db 0
0456DF 00          0319*  @red: db 0
0456E0 00          0320*  @green: db 0
0456E1 00          0321*  @blue: db 0
0456E2             0322*  @end:
0456E2             0323*  
0456E2             0324*  ; VDU 20: Reset palette and text/graphics colours and drawing modes 
0456E2             0325*  vdu_reset_gfx:
0456E2 3E 14       0326*      ld a,20
0456E4 5B D7       0327*  	rst.lil $10
0456E6 C9          0328*  	ret
0456E7             0329*  
0456E7             0330*  ; VDU 21: Disable screen (turns off VDU command processing,
0456E7             0331*  ; except for VDU 1 and VDU 6) 
0456E7             0332*  vdu_disable_screen:
0456E7 3E 15       0333*      ld a,21
0456E9 5B D7       0334*  	rst.lil $10
0456EB C9          0335*  	ret
0456EC             0336*  
0456EC             0337*  ; VDU 22, n: Select screen mode (MODE n)
0456EC             0338*  ; Inputs: a, screen mode (8-bit unsigned integer), in the following list:
0456EC             0339*  ; https://agonconsole8.github.io/agon-docs/VDP---Screen-Modes.html
0456EC             0340*  ; Screen modes
0456EC             0341*  ; Modes over 128 are double-buffered
0456EC             0342*  ; From Version 1.04 or greater
0456EC             0343*  ; Mode 	Horz 	Vert 	Cols 	Refresh
0456EC             0344*  ; 0 	640 	480 	16 	    60hz
0456EC             0345*  ; * 1 	640 	480 	4 	    60hz
0456EC             0346*  ; 2 	640 	480 	2 	    60hz
0456EC             0347*  ; 3 	640 	240 	64 	    60hz
0456EC             0348*  ; 4 	640 	240 	16 	    60hz
0456EC             0349*  ; 5 	640 	240 	4 	    60hz
0456EC             0350*  ; 6 	640 	240 	2 	    60hz
0456EC             0351*  ; ** 7 	n/a 	n/a 	16 	    60hz
0456EC             0352*  ; 8 	320 	240 	64 	    60hz
0456EC             0353*  ; 9 	320 	240 	16 	    60hz
0456EC             0354*  ; 10 	320 	240 	4 	    60hz
0456EC             0355*  ; 11 	320 	240 	2 	    60hz
0456EC             0356*  ; 12 	320 	200 	64 	    70hz
0456EC             0357*  ; 13 	320 	200 	16 	    70hz
0456EC             0358*  ; 14 	320 	200 	4 	    70hz
0456EC             0359*  ; 15 	320 	200 	2 	    70hz
0456EC             0360*  ; 16 	800 	600 	4 	    60hz
0456EC             0361*  ; 17 	800 	600 	2 	    60hz
0456EC             0362*  ; 18 	1024 	768 	2 	    60hz
0456EC             0363*  ; 129 	640 	480 	4 	    60hz
0456EC             0364*  ; 130 	640 	480 	2 	    60hz
0456EC             0365*  ; 132 	640 	240 	16 	    60hz
0456EC             0366*  ; 133 	640 	240 	4 	    60hz
0456EC             0367*  ; 134 	640 	240 	2 	    60hz
0456EC             0368*  ; 136 	320 	240 	64 	    60hz
0456EC             0369*  ; 137 	320 	240 	16 	    60hz
0456EC             0370*  ; 138 	320 	240 	4 	    60hz
0456EC             0371*  ; 139 	320 	240 	2 	    60hz
0456EC             0372*  ; 140 	320 	200 	64 	    70hz
0456EC             0373*  ; 141 	320 	200 	16 	    70hz
0456EC             0374*  ; 142 	320 	200 	4 	    70hz
0456EC             0375*  ; 143 	320 	200 	2 	    70hz
0456EC             0376*  ; * Mode 1 is the default mode, and is the mode that the system will use on startup.
0456EC             0377*  ; It is also the mode that the system will fall back to use if it was not possible to
0456EC             0378*  ; change to the requested mode.
0456EC             0379*  ; ** Mode 7 is the Teletext mode, and essentially works in a very similar manner to
0456EC             0380*  ; the BBC Micros Teletext mode, which was also mode 7.
0456EC             0381*  vdu_set_screen_mode:
0456EC 32 FC 56 04 0382*  	ld (@arg),a
0456F0 21 FB 56 04 0383*  	ld hl,@cmd
0456F4 01 02 00 00 0384*  	ld bc,@end-@cmd
0456F8 5B DF       0385*  	rst.lil $18
0456FA C9          0386*  	ret
0456FB 16          0387*  @cmd: db 22 ; set screen mode
0456FC 00          0388*  @arg: db 0  ; screen mode parameter
0456FD             0389*  @end:
0456FD             0390*  
0456FD             0391*  ; VDU 23, n: Re-program display character / System Commands
0456FD             0392*  ; inputs: a, ascii code; hl, pointer to bitmask data
0456FD             0393*  vdu_define_character:
0456FD 32 19 57 04 0394*  	ld (@ascii),a
045701 11 1A 57 04 0395*  	ld de,@data
045705 06 08       0396*  	ld b,8 ; loop counter for 8 bytes of data
045707             0397*  @loop:
045707 7E          0398*  	ld a,(hl)
045708 12          0399*  	ld (de),a
045709 23          0400*  	inc hl
04570A 13          0401*  	inc de
04570B 10 FA       0402*  	djnz @loop
04570D 21 18 57 04 0403*  	ld hl,@cmd
045711 01 0A 00 00 0404*  	ld bc,@end-@cmd
045715 5B DF       0405*  	rst.lil $18
045717 C9          0406*  	ret
045718 17          0407*  @cmd:   db 23
045719 00          0408*  @ascii: db 0
04571A             0409*  @data:  ds 8
045722             0410*  @end:
045722             0411*  
045722             0412*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
045722             0413*  ; NOTE: the order of the y-coordinate parameters are inverted
045722             0414*  ; 	because we have turned off logical screen scaling
045722             0415*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
045722             0416*  ; outputs; nothing
045722             0417*  ; destroys: a might make it out alive
045722             0418*  vdu_set_gfx_viewport:
045722 ED 43 42 57 0419*      ld (@x0),bc
       04          
045727 FD 22 44 57 0420*      ld (@y1),iy
       04          
04572C DD 22 46 57 0421*  	ld (@x1),ix
       04          
045731 ED 53 48 57 0422*  	ld (@y0),de
       04          
045736 21 41 57 04 0423*  	ld hl,@cmd
04573A 01 09 00 00 0424*  	ld bc,@end-@cmd
04573E 5B DF       0425*  	rst.lil $18
045740 C9          0426*  	ret
045741 18          0427*  @cmd:   db 24 ; set graphics viewport command
045742 00 00       0428*  @x0: 	dw 0x0000 ; set by bc
045744 00 00       0429*  @y1: 	dw 0x0000 ; set by iy
045746 00 00       0430*  @x1: 	dw 0x0000 ; set by ix
045748 00 00       0431*  @y0: 	dw 0x0000 ; set by de
04574A 00          0432*  @end:   db 0x00	  ; padding
04574B             0433*  
04574B             0434*  ; VDU 25, mode, x; y;: PLOT command
04574B             0435*  ; Implemented in vdu_plot.inc
04574B             0436*  
04574B             0437*  ; VDU 26: Reset graphics and text viewports **
04574B             0438*  vdu_reset_txt_gfx_view:
04574B 3E 1A       0439*      ld a,26
04574D 5B D7       0440*  	rst.lil $10
04574F C9          0441*  	ret
045750             0442*  
045750             0443*  ; PASSES
045750             0444*  ; VDU 27, char: Output character to screen 
045750             0445*  ; inputs: a is the ascii code of the character to draw
045750             0446*  vdu_draw_char:
045750 32 60 57 04 0447*  	ld (@arg),a
045754 21 5F 57 04 0448*  	ld hl,@cmd
045758 01 02 00 00 0449*  	ld bc,@end-@cmd
04575C 5B DF       0450*  	rst.lil $18
04575E C9          0451*  	ret
04575F 1B          0452*  @cmd: db 27
045760 00          0453*  @arg: db 0  ; ascii code of character to draw
045761             0454*  @end:
045761             0455*  
045761             0456*  ; VDU 28, left, bottom, right, top: Set text viewport **
045761             0457*  ; MIND THE LITTLE-ENDIANESS
045761             0458*  ; inputs: c=left,b=bottom,e=right,d=top
045761             0459*  ; outputs; nothing
045761             0460*  ; destroys: a might make it out alive
045761             0461*  vdu_set_txt_viewport:
045761 ED 43 77 57 0462*      ld (@lb),bc
       04          
045766 ED 53 79 57 0463*  	ld (@rt),de
       04          
04576B 21 76 57 04 0464*  	ld hl,@cmd
04576F 01 05 00 00 0465*  	ld bc,@end-@cmd
045773 5B DF       0466*  	rst.lil $18
045775 C9          0467*  	ret
045776 1C          0468*  @cmd:   db 28 ; set text viewport command
045777 00 00       0469*  @lb: 	dw 0x0000 ; set by bc
045779 00 00       0470*  @rt: 	dw 0x0000 ; set by de
04577B 00          0471*  @end:   db 0x00	  ; padding
04577C             0472*  
04577C             0473*  ; PASSES
04577C             0474*  ; VDU 29, x; y;: Set graphics origin
04577C             0475*  ; inputs: bc,de x,y coordinates
04577C             0476*  vdu_set_gfx_origin:
04577C ED 43 92 57 0477*      ld (@x0),bc
       04          
045781 ED 53 94 57 0478*      ld (@y0),de
       04          
045786 21 91 57 04 0479*  	ld hl,@cmd
04578A 01 05 00 00 0480*  	ld bc,@end-@cmd
04578E 5B DF       0481*  	rst.lil $18
045790 C9          0482*  	ret
045791 1D          0483*  @cmd:	db 29
045792 00 00       0484*  @x0: 	dw 0
045794 00 00       0485*  @y0: 	dw 0
045796 00          0486*  @end: 	db 0 ; padding
045797             0487*  
045797             0488*  ; PASSES
045797             0489*  ; VDU 30: Home cursor
045797             0490*  vdu_home_cursor:
045797 3E 1E       0491*      ld a,30
045799 5B D7       0492*  	rst.lil $10
04579B C9          0493*  	ret
04579C             0494*  
04579C             0495*  ; PASSES
04579C             0496*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
04579C             0497*  ; inputs: c=x, b=y 8-bit unsigned integers
04579C             0498*  vdu_move_cursor:
04579C ED 43 AD 57 0499*      ld (@x0),bc
       04          
0457A1 21 AC 57 04 0500*  	ld hl,@cmd
0457A5 01 03 00 00 0501*  	ld bc,@end-@cmd
0457A9 5B DF       0502*  	rst.lil $18
0457AB C9          0503*  	ret
0457AC 1F          0504*  @cmd: 	db 31
0457AD 00          0505*  @x0:	db 0
0457AE 00          0506*  @y0: 	db 0
0457AF 00          0507*  @end: 	db 0 ; padding
0457B0             0508*  
0457B0             0509*  
0457B0             0510*  ; VDU 127: Backspace
0457B0             0511*  vdu_bksp:
0457B0 3E 7F       0512*      ld a,127
0457B2 5B D7       0513*  	rst.lil $10
0457B4 C9          0514*  	ret
0457B5             0515*  
0457B5             0516*  ; activate a bitmap in preparation to draw it
0457B5             0517*  ; inputs: a holding the bitmap index
0457B5             0518*  vdu_bmp_select:
0457B5 32 C7 57 04 0519*  	ld (@bmp),a
0457B9 21 C4 57 04 0520*  	ld hl,@cmd
0457BD 01 04 00 00 0521*  	ld bc,@end-@cmd
0457C1 5B DF       0522*  	rst.lil $18
0457C3 C9          0523*  	ret
0457C4 17 1B 00    0524*  @cmd: db 23,27,0
0457C7 00          0525*  @bmp: db 0
0457C8             0526*  @end:
0457C8             0527*  
0457C8             0528*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0457C8             0529*  ; inputs: hl=bufferId
0457C8             0530*  vdu_buff_select:
0457C8 22 DA 57 04 0531*  	ld (@bufferId),hl
0457CC 21 D7 57 04 0532*  	ld hl,@cmd
0457D0 01 05 00 00 0533*  	ld bc,@end-@cmd
0457D4 5B DF       0534*  	rst.lil $18
0457D6 C9          0535*  	ret
0457D7 17 1B 20    0536*  @cmd: db 23,27,0x20
0457DA 00 00       0537*  @bufferId: dw 0x0000
0457DC 00          0538*  @end: db 0x00 ; padding
0457DD             0539*  
0457DD             0540*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0457DD             0541*  ; inputs: a=format; bc=width; de=height
0457DD             0542*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0457DD             0543*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0457DD             0544*  ; 0 	RGBA8888 (4-bytes per pixel)
0457DD             0545*  ; 1 	RGBA2222 (1-bytes per pixel)
0457DD             0546*  ; 2 	Mono/Mask (1-bit per pixel)
0457DD             0547*  ; 3 	Reserved for internal use by VDP (native format)
0457DD             0548*  vdu_bmp_create:
0457DD ED 43 F9 57 0549*      ld (@width),bc
       04          
0457E2 ED 53 FB 57 0550*      ld (@height),de
       04          
0457E7 32 FD 57 04 0551*      ld (@fmt),a
0457EB 21 F6 57 04 0552*  	ld hl,@cmd
0457EF 01 08 00 00 0553*  	ld bc,@end-@cmd
0457F3 5B DF       0554*  	rst.lil $18
0457F5 C9          0555*  	ret
0457F6 17 1B 21    0556*  @cmd:       db 23,27,0x21
0457F9 00 00       0557*  @width:     dw 0x0000
0457FB 00 00       0558*  @height:    dw 0x0000
0457FD 00          0559*  @fmt:       db 0x00
0457FE             0560*  @end:
0457FE             0561*  
0457FE             0562*  ; Draw a bitmap on the screen
0457FE             0563*  ; inputs: bc, x-coordinate; de, y-coordinate
0457FE             0564*  ; prerequisite: bitmap index set by e.g. vdu_bmp_select
0457FE             0565*  vdu_bmp_draw:
0457FE ED 43 16 58 0566*      ld (@x0),bc
       04          
045803 ED 53 18 58 0567*      ld (@y0),de
       04          
045808 21 13 58 04 0568*  	ld hl,@cmd
04580C 01 07 00 00 0569*  	ld bc,@end-@cmd
045810 5B DF       0570*  	rst.lil $18
045812 C9          0571*  	ret
045813 17 1B 03    0572*  @cmd: db 23,27,3
045816 00 00       0573*  @x0:  dw 0x0000
045818 00 00       0574*  @y0:  dw 0x0000
04581A 00          0575*  @end: db 0x00 ; padding
04581B             0576*  
04581B             0577*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
04581B             0578*  ; inputs: a is scaling mode, 1=on, 0=off
04581B             0579*  ; note: default setting on boot is scaling ON
04581B             0580*  vdu_set_scaling:
04581B 32 2D 58 04 0581*  	ld (@arg),a
04581F 21 2A 58 04 0582*  	ld hl,@cmd
045823 01 04 00 00 0583*  	ld bc,@end-@cmd
045827 5B DF       0584*  	rst.lil $18
045829 C9          0585*  	ret
04582A 17 00 C0    0586*  @cmd: db 23,0,0xC0
04582D 00          0587*  @arg: db 0  ; scaling on/off
04582E             0588*  @end:
04582E             0589*  
04582E             0590*  ; VDU 23, 0, &C3: Swap the screen buffer and/or wait for VSYNC **
04582E             0591*  ; 	Swap the screen buffer (double-buffered modes only) or wait for VSYNC
04582E             0592*  ; 	(all modes).
04582E             0593*  
04582E             0594*  ; 	This command will swap the screen buffer, if the current screen mode
04582E             0595*  ; 	is double-buffered, doing so at the next VSYNC. If the current screen
04582E             0596*  ; 	mode is not double-buffered then this command will wait for the next
04582E             0597*  ; 	VSYNC signal before returning. This can be used to synchronise the
04582E             0598*  ; 	screen with the vertical refresh rate of the monitor.
04582E             0599*  
04582E             0600*  ; 	Waiting for VSYNC can be useful for ensuring smooth graphical animation,
04582E             0601*  ; 	as it will prevent tearing of the screen.
04582E             0602*  ; inputs: none
04582E             0603*  ; outputs: none
04582E             0604*  ; destroys: hl, bc
04582E             0605*  vdu_flip:
04582E 21 39 58 04 0606*  	ld hl,@cmd
045832 01 03 00 00 0607*  	ld bc,@end-@cmd
045836 5B DF       0608*  	rst.lil $18
045838 C9          0609*  	ret
045839 17 00 C3    0610*  @cmd: db 23,0,0xC3
04583C             0611*  @end:
04583C             0612*  
04583C             0613*  ; Command 64: Compress a buffer
04583C             0614*  ; VDU 23, 0, &A0, targetBufferId; 64, sourceBufferId;
04583C             0615*  ; This command will compress the contents of a buffer, replacing the target buffer with the compressed data. Unless the target buffer is the same as the source, the source buffer will be left unchanged.
04583C             0616*  
04583C             0617*  
04583C             0618*  ; Command 65: Decompress a buffer
04583C             0619*  ; VDU 23, 0, &A0, targetBufferId; 65, sourceBufferId;
04583C             0620*  ; This command will decompress the contents of a buffer, replacing the target buffer with the decompressed data. Unless the target buffer is the same as the source, the source buffer will be left unchanged.
04583C             0621*  ; inputs: hl=sourceBufferId, de=targetBufferId
04583C             0622*  vdu_decompress_buffer:
04583C ED 53 59 58 0623*  	ld (@targetBufferId),de
       04          
045841 22 5C 58 04 0624*  	ld (@sourceBufferId),hl
045845 3E 41       0625*  	ld a,65
045847 32 5B 58 04 0626*  	ld (@cmd1),a ; restore the part of command that got stomped on
04584B 21 56 58 04 0627*  	ld hl,@cmd
04584F 01 08 00 00 0628*  	ld bc,@end-@cmd
045853 5B DF       0629*  	rst.lil $18
045855 C9          0630*  	ret
045856 17 00 A0    0631*  @cmd: 	db 23,0,0xA0
045859 00 00       0632*  @targetBufferId: dw 0x0000
04585B 41          0633*  @cmd1:	db 65
04585C 00 00       0634*  @sourceBufferId: dw 0x0000
04585E 00          0635*  @end: 	db 0x00 ; padding
04585F             0636*  
04585F             0637*  ; #### from vdp.inc ####
04585F             0638*  
04585F             0639*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
04585F             0640*  ; VDU 23, 7: Scrolling
04585F             0641*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
04585F             0642*  ; inputs: a, extent; l, direction; h; speed
04585F             0643*  vdu_scroll_down:
04585F 32 74 58 04 0644*  	ld (@extent),a
045863 22 75 58 04 0645*  	ld (@dir),hl ; implicitly populates @speed
045867 21 72 58 04 0646*  	ld hl,@cmd
04586B 01 05 00 00 0647*  	ld bc,@end-@cmd
04586F 5B DF       0648*  	rst.lil $18     ;; Sending command to VDP
045871 C9          0649*  	ret
045872 17 07       0650*  @cmd:       db 23,7
045874 00          0651*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
045875 00          0652*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
045876 00          0653*  @speed:     db 0x00 ; pixels
045877 00          0654*  @end:		db 0x00 ; padding
045878             0655*  
045878             0656*  cursor_on:
045878 21 83 58 04 0657*  	ld hl,@cmd
04587C 01 03 00 00 0658*  	ld bc,@end-@cmd
045880 5B DF       0659*  	rst.lil $18
045882 C9          0660*  	ret
045883             0661*  @cmd:
045883 17 01 01    0662*  	db 23,1,1
045886             0663*  @end:
045886             0664*  
045886             0665*  cursor_off:
045886 21 91 58 04 0666*  	ld hl,@cmd
04588A 01 03 00 00 0667*  	ld bc,@end-@cmd
04588E 5B DF       0668*  	rst.lil $18
045890 C9          0669*  	ret
045891             0670*  @cmd:
045891 17 01 00    0671*  	db 23,1,0
045894             0672*  @end:
045894             0673*  
045894 DD E5       0674*  vdu_vblank:		PUSH 	IX			; Wait for VBLANK interrupt
045896             0675*  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
045896 3E 08       0001*M 			LD	A, function
045898 5B CF       0002*M 			RST.LIL	08h
04589A DD 7E 00    0676*  			LD	A, (IX + sysvar_time + 0)
04589D DD BE 00    0677*  @wait:			CP 	A, (IX + sysvar_time + 0)
0458A0 28 FB       0678*  			JR	Z, @wait
0458A2 DD E1       0679*  			POP	IX
0458A4 C9          0680*  			RET
0458A5             0681*  
0458A5             0682*  ; #### from vdu_bmp.inc ####
0458A5             0683*  ; =========================================================================
0458A5             0684*  ; Bitmaps
0458A5             0685*  ; -------------------------------------------------------------------------
0458A5             0686*  ; VDU 23, 27, 0, n: Select bitmap n
0458A5             0687*  ; VDU 23, 27, &20, bufferId;: Select bitmap using a 16-bit buffer ID *
0458A5             0688*  ; VDU 23, 27, 1, w; h; b1, b2 ... bn: Load colour bitmap data into current bitmap
0458A5             0689*  
0458A5             0690*  ; VDU 23, 27, 1, n, 0, 0;: Capture screen data into bitmap n *
0458A5             0691*  ; VDU 23, 27, &21, bitmapId; 0; : same, but to 16-bit buffer ID *
0458A5             0692*  ; Any PLOT, or VDU 25, style command will push the graphics cursor position -
0458A5             0693*  ; typically "move" style plot commands are used to define the rectangle.
0458A5             0694*  ; To be clear, this command should be performed after two "move" style PLOT commands.
0458A5             0695*  ; inputs: hl; target bufferId
0458A5             0696*  ; all the following are in 16.8 fixed point format
0458A5             0697*  ;   ub.c; top-left x coordinate
0458A5             0698*  ;   ud.e; top-left y coordinate
0458A5             0699*  ;   ui.x; width
0458A5             0700*  ;   ui.y; height
0458A5             0701*  vdu_buff_screen_capture168:
0458A5 ED 53 DC 58 0702*          ld (@y0-1),de
       04          
0458AA ED 43 DA 58 0703*          ld (@x0-1),bc
       04          
0458AF 3E 44       0704*          ld a,0x44 ; plot_pt+mv_abs
0458B1 32 DA 58 04 0705*          ld (@x0-1),a
0458B5             0706*  
0458B5 DD 22 E1 58 0707*          ld (@x1),ix
       04          
0458BA FD 22 E3 58 0708*          ld (@y1),iy
       04          
0458BF 3E 17       0709*          ld a,23
0458C1 32 E5 58 04 0710*          ld (@y1+2),a
0458C5             0711*  
0458C5 22 E8 58 04 0712*          ld (@bufId),hl
0458C9 AF          0713*          xor a
0458CA 32 EA 58 04 0714*          ld (@bufId+2),a
0458CE             0715*  
0458CE 21 D9 58 04 0716*          ld hl,@begin
0458D2 01 13 00 00 0717*          ld bc,@end-@begin
0458D6 5B DF       0718*          rst.lil $18
0458D8 C9          0719*          ret
0458D9             0720*  @begin:
0458D9             0721*  ; absolute move gfx cursor to top-left screen coordinate
0458D9             0722*  ; VDU 25, mode, x; y;: PLOT command
0458D9 19 44       0723*          db 25,0x44 ; plot_pt+mv_abs
0458DB 40 00       0724*  @x0: 	dw 64
0458DD 40 00       0725*  @y0: 	dw 64
0458DF             0726*  ; relative move gfx cursor to bottom-right screen coordinate
0458DF             0727*  ; VDU 25, mode, x; y;: PLOT command
0458DF 19 40       0728*          db 25,0x40 ; plot_pt+mv_rel
0458E1 0F 00       0729*  @x1: 	dw 15
0458E3 0F 00       0730*  @y1: 	dw 15
0458E5             0731*  ; now the main event
0458E5             0732*  ; VDU 23, 27, &21, bitmapId; 0;
0458E5 17 1B 21    0733*          db 23,27,0x21
0458E8 00 20 00 00 0734*  @bufId: dw 0x2000,0x0000
0458EC             0735*  @end: ; no padding required
0458EC             0736*  
0458EC             0737*  vdu_buff_screen_capture_full:
0458EC 21 F7 58 04 0738*          ld hl,@begin
0458F0 01 13 00 00 0739*          ld bc,@end-@begin
0458F4 5B DF       0740*          rst.lil $18
0458F6 C9          0741*          ret
0458F7             0742*  @begin:
0458F7             0743*  ; absolute move gfx cursor to top-left screen coordinate
0458F7             0744*  ; VDU 25, mode, x; y;: PLOT command
0458F7 19 44       0745*          db 25,0x44 ; plot_pt+mv_abs
0458F9 00 00       0746*  @x0: 	dw 0
0458FB 00 00       0747*  @y0: 	dw 0
0458FD             0748*  ; relative move gfx cursor to bottom-right screen coordinate
0458FD             0749*  ; VDU 25, mode, x; y;: PLOT command
0458FD 19 40       0750*          db 25,0x40 ; plot_pt+mv_rel
0458FF 3F 01       0751*  @x1: 	dw 319
045901 EF 00       0752*  @y1: 	dw 239
045903             0753*  ; now the main event
045903             0754*  ; VDU 23, 27, &21, bitmapId; 0;
045903 17 1B 21    0755*          db 23,27,0x21
045906 00 20 00 00 0756*  @bufId: dw 0x2000,0x0000
04590A             0757*  @end: ; no padding required
04590A             0758*  
04590A             0759*  vdu_buff_screen_paste_full:
04590A 21 15 59 04 0760*          ld hl,@begin
04590E 01 0B 00 00 0761*          ld bc,@end-@begin
045912 5B DF       0762*          rst.lil $18
045914 C9          0763*          ret
045915             0764*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
045915 17 1B 20    0765*  @begin:    db 23,27,0x20
045918 00 20       0766*  @bufferId: dw 0x2000
04591A             0767*  ; VDU 25, mode, x; y;: PLOT command
04591A 19 ED       0768*             db 25,0xED ; plot_bmp+dr_abs_fg
04591C 00 00 00 00 0769*             dw 0x0000,0x0000
045920             0770*  @end: ; no padding required
045920             0771*  
045920             0772*  vdu_buff_screen_capture_tiles:
045920 21 2B 59 04 0773*          ld hl,@begin
045924 01 13 00 00 0774*          ld bc,@end-@begin
045928 5B DF       0775*          rst.lil $18
04592A C9          0776*          ret
04592B             0777*  @begin:
04592B             0778*  ; absolute move gfx cursor to top-left screen coordinate
04592B             0779*  ; VDU 25, mode, x; y;: PLOT command
04592B 19 44       0780*          db 25,0x44 ; plot_pt+mv_abs
04592D 00 00       0781*  @x0: 	dw 0
04592F 00 00       0782*  @y0: 	dw 0
045931             0783*  ; relative move gfx cursor to bottom-right screen coordinate
045931             0784*  ; VDU 25, mode, x; y;: PLOT command
045931 19 40       0785*          db 25,0x40 ; plot_pt+mv_rel
045933 FF 00       0786*  @x1: 	dw 319-64
045935 EF 00       0787*  @y1: 	dw 239
045937             0788*  ; now the main event
045937             0789*  ; VDU 23, 27, &21, bitmapId; 0;
045937 17 1B 21    0790*          db 23,27,0x21
04593A 00 20 00 00 0791*  @bufId: dw 0x2000,0x0000
04593E             0792*  @end: ; no padding required
04593E             0793*  
04593E             0794*  vdu_buff_screen_paste_tiles:
04593E 21 49 59 04 0795*          ld hl,@begin
045942 01 0B 00 00 0796*          ld bc,@end-@begin
045946 5B DF       0797*          rst.lil $18
045948 C9          0798*          ret
045949             0799*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
045949 17 1B 20    0800*  @begin:    db 23,27,0x20
04594C 00 20       0801*  @bufferId: dw 0x2000
04594E             0802*  ; VDU 25, mode, x; y;: PLOT command
04594E 19 ED       0803*             db 25,0xED ; plot_bmp+dr_abs_fg
045950 00 00 01 00 0804*             dw 0x0000,0x0001
045954             0805*  @end: ; no padding required
045954             0806*  
045954             0807*  ; VDU 23, 27, 2, w; h; col1; col2;: Create a solid colour rectangular bitmap
045954             0808*  ; VDU 23, 27, 3, x; y;: Draw current bitmap on screen at pixel position x, y
045954             0809*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer *
045954             0810*  ; Value	Meaning
045954             0811*  ; 0	RGBA8888 (4-bytes per pixel)
045954             0812*  ; 1	RGBA2222 (1-bytes per pixel)
045954             0813*  ; 2	Mono/Mask (1-bit per pixel)
045954             0814*  ; 3	Reserved for internal use by VDP ("native" format)VDP.
045954             0815*  ;     They have some significant limitations, and are not intended for general use.
045954             0816*  
045954             0817*  ; =========================================================================
045954             0818*  ; Sprites
045954             0819*  ; -------------------------------------------------------------------------
045954             0820*  ; VDU 23, 27, 4, n: Select sprite n
045954             0821*  ; VDU 23, 27, 5: Clear frames in current sprite
045954             0822*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
045954             0823*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
045954             0824*  ; VDU 23, 27, 7, n: Activate n sprites
045954             0825*  ; VDU 23, 27, 8: Select next frame of current sprite
045954             0826*  ; VDU 23, 27, 9: Select previous frame of current sprite
045954             0827*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
045954             0828*  ; VDU 23, 27, 11: Show current sprite
045954             0829*  ; VDU 23, 27, 12: Hide current sprite
045954             0830*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
045954             0831*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
045954             0832*  ; VDU 23, 27, 15: Update the sprites in the GPU
045954             0833*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
045954             0834*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
045954             0835*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
045954             0836*  
045954             0837*  ; =========================================================================
045954             0838*  ; Mouse cursor
045954             0839*  ; -------------------------------------------------------------------------
045954             0840*  ; VDU 23, 27, &40, hotX, hotY: Setup a mouse cursor with a hot spot at hotX, hotY
045954             0841*  
045954             0842*  ; #### from vdu_plot.inc ####
045954             0843*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
045954             0844*  ; PLOT code 	(Decimal) 	Effect
045954             0845*  ; &00-&07 	0-7 	Solid line, includes both ends
045954             0846*  plot_sl_both: equ 0x00
045954             0847*  
045954             0848*  ; &08-&0F 	8-15 	Solid line, final point omitted
045954             0849*  plot_sl_first: equ 0x08
045954             0850*  
045954             0851*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
045954             0852*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
045954             0853*  
045954             0854*  ; &20-&27 	32-39 	Solid line, first point omitted
045954             0855*  plot_sl_last: equ 0x20
045954             0856*  
045954             0857*  ; &28-&2F 	40-47 	Solid line, both points omitted
045954             0858*  plot_sl_none: equ 0x28
045954             0859*  
045954             0860*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
045954             0861*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
045954             0862*  
045954             0863*  ; &40-&47 	64-71 	Point plot
045954             0864*  plot_pt: equ 0x40
045954             0865*  
045954             0866*  ; &48-&4F 	72-79 	Line fill left and right to non-background 
045954             0867*  plot_lf_lr_non_bg: equ 0x48
045954             0868*  
045954             0869*  ; &50-&57 	80-87 	Triangle fill
045954             0870*  plot_tf: equ 0x50
045954             0871*  
045954             0872*  ; &58-&5F 	88-95 	Line fill right to background 
045954             0873*  plot_lf_r_bg: equ 0x58
045954             0874*  
045954             0875*  ; &60-&67 	96-103 	Rectangle fill
045954             0876*  plot_rf: equ 0x60
045954             0877*  
045954             0878*  ; &68-&6F 	104-111 	Line fill left and right to foreground 
045954             0879*  plot_lf_lr_fg: equ 0x60
045954             0880*  
045954             0881*  ; &70-&77 	112-119 	Parallelogram fill
045954             0882*  plot_pf: equ 0x70
045954             0883*  
045954             0884*  ; &78-&7F 	120-127 	Line fill right to non-foreground 
045954             0885*  plot_lf_r_non_fg: equ 0x78
045954             0886*  
045954             0887*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
045954             0888*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
045954             0889*  
045954             0890*  ; &90-&97 	144-151 	Circle outline
045954             0891*  plot_co: equ 0x90
045954             0892*  
045954             0893*  ; &98-&9F 	152-159 	Circle fill
045954             0894*  plot_cf: equ 0x98
045954             0895*  
045954             0896*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
045954             0897*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
045954             0898*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
045954             0899*  
045954             0900*  ; &B8-&BF 	184-191 	Rectangle copy/move
045954             0901*  plot_rcm: equ 0xB8
045954             0902*  
045954             0903*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
045954             0904*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
045954             0905*  ; &D0-&D7 	208-215 	Not defined
045954             0906*  ; &D8-&DF 	216-223 	Not defined
045954             0907*  ; &E0-&E7 	224-231 	Not defined
045954             0908*  
045954             0909*  ; &E8-&EF 	232-239 	Bitmap plot 
045954             0910*  plot_bmp: equ 0xE8
045954             0911*  
045954             0912*  ; &F0-&F7 	240-247 	Not defined
045954             0913*  ; &F8-&FF 	248-255 	Not defined
045954             0914*  
045954             0915*  ;  Support added in Agon Console8 VDP 2.1.0  Support added in
045954             0916*  ; Agon Console8 VDP 2.2.0
045954             0917*  
045954             0918*  ; Within each group of eight plot codes, the effects are as follows:
045954             0919*  ; Plot code 	Effect
045954             0920*  ; 0 	Move relative
045954             0921*  mv_rel: equ 0
045954             0922*  
045954             0923*  ; 1 	Plot relative in current foreground colour
045954             0924*  dr_rel_fg: equ 1
045954             0925*  
045954             0926*  ; 2 	Not supported (Plot relative in logical inverse colour)
045954             0927*  ; 3 	Plot relative in current background colour
045954             0928*  dr_rel_bg: equ 3
045954             0929*  
045954             0930*  ; 4 	Move absolute
045954             0931*  mv_abs: equ 4
045954             0932*  
045954             0933*  ; 5 	Plot absolute in current foreground colour
045954             0934*  dr_abs_fg: equ 5
045954             0935*  
045954             0936*  ; 6 	Not supported (Plot absolute in logical inverse colour)
045954             0937*  ; 7 	Plot absolute in current background colour
045954             0938*  dr_abs_bg: equ 7
045954             0939*  
045954             0940*  ; Codes 0-3 use the position data provided as part of the command
045954             0941*  ; as a relative position, adding the position given to the current
045954             0942*  ; graphical cursor position. Codes 4-7 use the position data provided
045954             0943*  ; as part of the command as an absolute position, setting the current
045954             0944*  ; graphical cursor position to the position given.
045954             0945*  
045954             0946*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
045954             0947*  ; current pixel colour. These operations cannot currently be supported
045954             0948*  ; by the graphics system the Agon VDP uses, so these codes are not
045954             0949*  ; supported. Support for these codes may be added in a future version
045954             0950*  ; of the VDP firmware.
045954             0951*  
045954             0952*  ; 16 colour palette constants
045954             0953*  c_black: equ 0
045954             0954*  c_red_dk: equ 1
045954             0955*  c_green_dk: equ 2
045954             0956*  c_yellow_dk: equ 3
045954             0957*  c_blue_dk: equ 4
045954             0958*  c_magenta_dk: equ 5
045954             0959*  c_cyan_dk: equ 6
045954             0960*  c_grey: equ 7
045954             0961*  c_grey_dk: equ 8
045954             0962*  c_red: equ 9
045954             0963*  c_green: equ 10
045954             0964*  c_yellow: equ 11
045954             0965*  c_blue: equ 12
045954             0966*  c_magenta: equ 13
045954             0967*  c_cyan: equ 14
045954             0968*  c_white: equ 15
045954             0969*  
045954             0970*  ; VDU 25, mode, x; y;: PLOT command
045954             0971*  ; inputs: a=mode, bc=x0, de=y0
045954             0972*  vdu_plot:
045954 32 6E 59 04 0973*      ld (@mode),a
045958 ED 43 6F 59 0974*      ld (@x0),bc
       04          
04595D ED 53 71 59 0975*      ld (@y0),de
       04          
045962 21 6D 59 04 0976*  	ld hl,@cmd
045966 01 06 00 00 0977*  	ld bc,@end-@cmd
04596A 5B DF       0978*  	rst.lil $18
04596C C9          0979*  	ret
04596D 19          0980*  @cmd:   db 25
04596E 00          0981*  @mode:  db 0
04596F 00 00       0982*  @x0: 	dw 0
045971 00 00       0983*  @y0: 	dw 0
045973 00          0984*  @end:   db 0 ; extra byte to soak up deu
045974             0985*  
045974             0986*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
045974             0987*  ; &E8-&EF 	232-239 	Bitmap plot 
045974             0988*  ; VDU 25, mode, x; y;: PLOT command
045974             0989*  ; inputs: bc=x0, de=y0
045974             0990*  ; prerequisites: vdu_buff_select
045974             0991*  vdu_plot_bmp:
045974 ED 43 8B 59 0992*      ld (@x0),bc
       04          
045979 ED 53 8D 59 0993*      ld (@y0),de
       04          
04597E 21 89 59 04 0994*  	ld hl,@cmd
045982 01 06 00 00 0995*  	ld bc,@end-@cmd
045986 5B DF       0996*  	rst.lil $18
045988 C9          0997*  	ret
045989 19          0998*  @cmd:   db 25
04598A ED          0999*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
04598B 00 00       1000*  @x0: 	dw 0x0000
04598D 00 00       1001*  @y0: 	dw 0x0000
04598F 00          1002*  @end:   db 0x00 ; padding
045990             1003*  
045990             1004*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
045990             1005*  ; &E8-&EF 	232-239 	Bitmap plot 
045990             1006*  ; VDU 25, mode, x; y;: PLOT command
045990             1007*  ; inputs: bc=x0, de=y0
045990             1008*  ; USING 16.8 FIXED POINT COORDINATES
045990             1009*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
045990             1010*  ;   the fractional portiion of the inputs are truncated
045990             1011*  ;   leaving only the 16-bit integer portion
045990             1012*  ; prerequisites: vdu_buff_select
045990             1013*  vdu_plot_bmp168:
045990             1014*  ; populate in the reverse of normal to keep the
045990             1015*  ; inputs from stomping on each other
045990 ED 53 AE 59 1016*      ld (@y0-1),de
       04          
045995 ED 43 AC 59 1017*      ld (@x0-1),bc
       04          
04599A 3E ED       1018*      ld a,plot_bmp+dr_abs_fg ; 0xED
04599C 32 AC 59 04 1019*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
0459A0 21 AB 59 04 1020*  	ld hl,@cmd
0459A4 01 06 00 00 1021*  	ld bc,@end-@cmd
0459A8 5B DF       1022*  	rst.lil $18
0459AA C9          1023*  	ret
0459AB 19          1024*  @cmd:   db 25
0459AC ED          1025*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0459AD 00 00       1026*  @x0: 	dw 0x0000
0459AF 00 00       1027*  @y0: 	dw 0x0000
0459B1             1028*  @end:  ; no padding required b/c we shifted de right
0459B1             1029*  
0459B1             1030*  ; draw a filled rectangle
0459B1             1031*  vdu_plot_rf:
0459B1 ED 43 D8 59 1032*      ld (@x0),bc
       04          
0459B6 ED 53 DA 59 1033*      ld (@y0),de
       04          
0459BB DD 22 DE 59 1034*      ld (@x1),ix
       04          
0459C0 FD 22 E0 59 1035*      ld (@y1),iy
       04          
0459C5 3E 19       1036*      ld a,25 ; we have to reload the 2nd plot command
0459C7 32 DC 59 04 1037*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0459CB 21 D6 59 04 1038*  	ld hl,@cmd0
0459CF 01 0C 00 00 1039*  	ld bc,@end-@cmd0
0459D3 5B DF       1040*  	rst.lil $18
0459D5 C9          1041*      ret
0459D6 19          1042*  @cmd0:  db 25 ; plot
0459D7 04          1043*  @arg0:  db plot_sl_both+mv_abs
0459D8 00 00       1044*  @x0:    dw 0x0000
0459DA 00 00       1045*  @y0:    dw 0x0000
0459DC 19          1046*  @cmd1:  db 25 ; plot
0459DD 65          1047*  @arg1:  db plot_rf+dr_abs_fg
0459DE 00 00       1048*  @x1:    dw 0x0000
0459E0 00 00       1049*  @y1:    dw 0x0000
0459E2 00          1050*  @end:   db 0x00 ; padding
0459E3             1051*  
0459E3             1052*  ; draw a filled circle
0459E3             1053*  vdu_plot_cf:
0459E3 ED 43 0A 5A 1054*      ld (@x0),bc
       04          
0459E8 ED 53 0C 5A 1055*      ld (@y0),de
       04          
0459ED DD 22 10 5A 1056*      ld (@x1),ix
       04          
0459F2 FD 22 12 5A 1057*      ld (@y1),iy
       04          
0459F7 3E 19       1058*      ld a,25 ; we have to reload the 2nd plot command
0459F9 32 0E 5A 04 1059*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0459FD 21 08 5A 04 1060*  	ld hl,@cmd0
045A01 01 0C 00 00 1061*  	ld bc,@end-@cmd0
045A05 5B DF       1062*  	rst.lil $18
045A07 C9          1063*      ret
045A08 19          1064*  @cmd0:  db 25 ; plot
045A09 04          1065*  @arg0:  db plot_sl_both+mv_abs
045A0A 00 00       1066*  @x0:    dw 0x0000
045A0C 00 00       1067*  @y0:    dw 0x0000
045A0E 19          1068*  @cmd1:  db 25 ; plot
045A0F 9D          1069*  @arg1:  db plot_cf+dr_abs_fg
045A10 00 00       1070*  @x1:    dw 0x0000
045A12 00 00       1071*  @y1:    dw 0x0000
045A14 00          1072*  @end:   db 0x00 ; padding
045A15             1073*  
045A15             1074*  ; #### from vdu_sprites.inc ####
045A15             1075*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
045A15             1076*  ; the VDP can support up to 256 sprites. They must be defined
045A15             1077*  ; contiguously, and so the first sprite is sprite 0.
045A15             1078*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
045A15             1079*  ; Once a selection of sprites have been defined, you can activate
045A15             1080*  ; them using the VDU 23, 27, 7, n command, where n is the number
045A15             1081*  ; of sprites to activate. This will activate the first n sprites,
045A15             1082*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
045A15             1083*  
045A15             1084*  ; A single sprite can have multiple "frames", referring to
045A15             1085*  ; different bitmaps.
045A15             1086*  ; (These bitmaps do not need to be the same size.)
045A15             1087*  ; This allows a sprite to include an animation sequence,
045A15             1088*  ; which can be stepped through one frame at a time, or picked
045A15             1089*  ; in any order.
045A15             1090*  
045A15             1091*  ; Any format of bitmap can be used as a sprite frame. It should
045A15             1092*  ; be noted however that "native" format bitmaps are not
045A15             1093*  ; recommended for use as sprite frames, as they cannot get
045A15             1094*  ; erased from the screen. (As noted above, the "native" bitmap
045A15             1095*  ; format is not really intended for general use.) This is part
045A15             1096*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
045A15             1097*  ; screen are now stored in RGBA2222 format.
045A15             1098*  
045A15             1099*  ; An "active" sprite can be hidden, so it will stop being drawn,
045A15             1100*  ; and then later shown again.
045A15             1101*  
045A15             1102*  ; Moving sprites around the screen is done by changing the
045A15             1103*  ; position of the sprite. This can be done either by setting
045A15             1104*  ; the absolute position of the sprite, or by moving the sprite
045A15             1105*  ; by a given number of pixels. (Sprites are positioned using
045A15             1106*  ; pixel coordinates, and not by the logical OS coordinate system.)
045A15             1107*  ; In the current sprite system, sprites will not update their
045A15             1108*  ; position on-screen until either another drawing operation is
045A15             1109*  ; performed or an explicit VDU 23, 27, 15 command is performed.
045A15             1110*  
045A15             1111*  ; Here are the sprite commands:
045A15             1112*  ;
045A15             1113*  ; VDU 23, 27, 4,  n: Select sprite n
045A15             1114*  ; inputs: a is the 8-bit sprite id
045A15             1115*  ; vdu_sprite_select:
045A15             1116*  
045A15             1117*  ; VDU 23, 27, 5:  Clear frames in current sprite
045A15             1118*  ; inputs: none
045A15             1119*  ; prerequisites: vdu_sprite_select
045A15             1120*  ; vdu_sprite_clear_frames:
045A15             1121*  
045A15             1122*  ; VDU 23, 27, 6,  n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
045A15             1123*  ; inputs: a is the 8-bit bitmap number
045A15             1124*  ; prerequisites: vdu_sprite_select
045A15             1125*  ; vdu_sprite_add_bmp:
045A15             1126*  
045A15             1127*  ; VDU 23, 27, 7,  n: Activate n sprites
045A15             1128*  ; inputs: a is the number of sprites to activate
045A15             1129*  ; vdu_sprite_activate:
045A15             1130*  
045A15             1131*  ; VDU 23, 27, 8:  Select next frame of current sprite
045A15             1132*  ; inputs: none
045A15             1133*  ; prerequisites: vdu_sprite_select
045A15             1134*  ; vdu_sprite_next_frame:
045A15             1135*  
045A15             1136*  ; VDU 23, 27, 9:  Select previous frame of current sprite
045A15             1137*  ; inputs: none
045A15             1138*  ; prerequisites: vdu_sprite_select
045A15             1139*  ; vdu_sprite_prev_frame:
045A15             1140*  
045A15             1141*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
045A15             1142*  ; inputs: a is frame number to select
045A15             1143*  ; prerequisites: vdu_sprite_select
045A15             1144*  ; vdu_sprite_select_frame:
045A15             1145*  
045A15             1146*  ; VDU 23, 27, 11: Show current sprite
045A15             1147*  ; inputs: none
045A15             1148*  ; prerequisites: vdu_sprite_select
045A15             1149*  ; vdu_sprite_show:
045A15             1150*  
045A15             1151*  ; VDU 23, 27, 12: Hide current sprite
045A15             1152*  ; inputs: none
045A15             1153*  ; prerequisites: vdu_sprite_select
045A15             1154*  ; vdu_sprite_hide:
045A15             1155*  
045A15             1156*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
045A15             1157*  ; inputs: bc is x coordinate, de is y coordinate
045A15             1158*  ; prerequisites: vdu_sprite_select
045A15             1159*  ; vdu_sprite_move_abs:
045A15             1160*  ;
045A15             1161*  ; USING 16.8 FIXED POINT COORDINATES
045A15             1162*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
045A15             1163*  ;   the fractional portiion of the inputs are truncated
045A15             1164*  ;   leaving only the 16-bit integer portion
045A15             1165*  ; prerequisites: vdu_sprite_select
045A15             1166*  ; vdu_sprite_move_abs168:
045A15             1167*  
045A15             1168*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
045A15             1169*  ; inputs: bc is x coordinate, de is y coordinate
045A15             1170*  ; prerequisites: vdu_sprite_select
045A15             1171*  ; vdu_sprite_move_rel:
045A15             1172*  ;
045A15             1173*  ; USING 16.8 FIXED POINT COORDINATES
045A15             1174*  ; inputs: ub.c is dx, ud.e is dy
045A15             1175*  ;   the fractional portiion of the inputs are truncated
045A15             1176*  ;   leaving only the 16-bit integer portion
045A15             1177*  ; prerequisites: vdu_sprite_select
045A15             1178*  ; vdu_sprite_move_rel168:
045A15             1179*  
045A15             1180*  ; VDU 23, 27, 15: Update the sprites in the GPU
045A15             1181*  ; inputs: none
045A15             1182*  ; vdu_sprite_update:
045A15             1183*  
045A15             1184*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
045A15             1185*  ; inputs: none
045A15             1186*  ; vdu_sprite_bmp_reset:
045A15             1187*  
045A15             1188*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
045A15             1189*  ; inputs: none
045A15             1190*  ; vdu_sprite_reset:
045A15             1191*  
045A15             1192*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
045A15             1193*  ; inputs: a is the GCOL paint mode
045A15             1194*  ; prerequisites: vdu_sprite_select
045A15             1195*  ; vdu_sprite_set_gcol:
045A15             1196*  
045A15             1197*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
045A15             1198*  ; inputs: hl=bufferId
045A15             1199*  ; prerequisites: vdu_sprite_select
045A15             1200*  ; vdu_sprite_add_buff:
045A15             1201*  
045A15             1202*  @dummy_label: ; dummy label to serve as a break from the above comments and the below code
045A15             1203*  
045A15             1204*  ; VDU 23, 27, 4, n: Select sprite n
045A15             1205*  ; inputs: a is the 8-bit sprite id
045A15             1206*  vdu_sprite_select:
045A15 32 27 5A 04 1207*      ld (@sprite),a
045A19 21 24 5A 04 1208*      ld hl,@cmd
045A1D 01 04 00 00 1209*      ld bc,@end-@cmd
045A21 5B DF       1210*      rst.lil $18
045A23 C9          1211*      ret
045A24 17 1B 04    1212*  @cmd:    db 23,27,4
045A27 00          1213*  @sprite: db 0x00
045A28             1214*  @end:
045A28             1215*  
045A28             1216*  ; VDU 23, 27, 5: Clear frames in current sprite
045A28             1217*  ; inputs: none
045A28             1218*  ; prerequisites: vdu_sprite_select
045A28             1219*  vdu_sprite_clear_frames:
045A28 21 33 5A 04 1220*      ld hl,@cmd
045A2C 01 03 00 00 1221*      ld bc,@end-@cmd
045A30 5B DF       1222*      rst.lil $18
045A32 C9          1223*      ret
045A33 17 1B 05    1224*  @cmd: db 23,27,5
045A36             1225*  @end:
045A36             1226*  
045A36             1227*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
045A36             1228*  ; inputs: a is the 8-bit bitmap number
045A36             1229*  ; prerequisites: vdu_sprite_select
045A36             1230*  vdu_sprite_add_bmp:
045A36 32 48 5A 04 1231*      ld (@bmp),a
045A3A 21 45 5A 04 1232*      ld hl,@cmd
045A3E 01 04 00 00 1233*      ld bc,@end-@cmd
045A42 5B DF       1234*      rst.lil $18
045A44 C9          1235*      ret
045A45 17 1B 06    1236*  @cmd: db 23,27,6
045A48 00          1237*  @bmp: db 0x00
045A49             1238*  @end:
045A49             1239*  
045A49             1240*  ; VDU 23, 27, 7, n: Activate n sprites
045A49             1241*  ; inputs: a is the number of sprites to activate
045A49             1242*  vdu_sprite_activate:
045A49 32 5B 5A 04 1243*      ld (@num),a
045A4D 21 58 5A 04 1244*      ld hl,@cmd
045A51 01 04 00 00 1245*      ld bc,@end-@cmd
045A55 5B DF       1246*      rst.lil $18
045A57 C9          1247*      ret
045A58 17 1B 07    1248*  @cmd: db 23,27,7
045A5B 00          1249*  @num: db 0x00
045A5C             1250*  @end:
045A5C             1251*  
045A5C             1252*  ; VDU 23, 27, 8: Select next frame of current sprite
045A5C             1253*  ; inputs: none
045A5C             1254*  ; prerequisites: vdu_sprite_select
045A5C             1255*  vdu_sprite_next_frame:
045A5C 21 67 5A 04 1256*      ld hl,@cmd
045A60 01 03 00 00 1257*      ld bc,@end-@cmd
045A64 5B DF       1258*      rst.lil $18
045A66 C9          1259*      ret
045A67 17 1B 08    1260*  @cmd: db 23,27,8
045A6A             1261*  @end:
045A6A             1262*  
045A6A             1263*  ; VDU 23, 27, 9: Select previous frame of current sprite
045A6A             1264*  ; inputs: none
045A6A             1265*  ; prerequisites: vdu_sprite_select
045A6A             1266*  vdu_sprite_prev_frame:
045A6A 21 75 5A 04 1267*      ld hl,@cmd
045A6E 01 03 00 00 1268*      ld bc,@end-@cmd
045A72 5B DF       1269*      rst.lil $18
045A74 C9          1270*      ret
045A75 17 1B 09    1271*  @cmd: db 23,27,9
045A78             1272*  @end:
045A78             1273*  
045A78             1274*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
045A78             1275*  ; inputs: a is frame number to select
045A78             1276*  ; prerequisites: vdu_sprite_select
045A78             1277*  vdu_sprite_select_frame:
045A78 32 8A 5A 04 1278*      ld (@frame),a
045A7C 21 87 5A 04 1279*      ld hl,@cmd
045A80 01 04 00 00 1280*      ld bc,@end-@cmd
045A84 5B DF       1281*      rst.lil $18
045A86 C9          1282*      ret
045A87 17 1B 0A    1283*  @cmd:    db 23,27,10
045A8A 00          1284*  @frame:  db 0x00
045A8B             1285*  @end:
045A8B             1286*  
045A8B             1287*  ; VDU 23, 27, 11: Show current sprite
045A8B             1288*  ; inputs: none
045A8B             1289*  ; prerequisites: vdu_sprite_select
045A8B             1290*  vdu_sprite_show:
045A8B 21 96 5A 04 1291*      ld hl,@cmd
045A8F 01 03 00 00 1292*      ld bc,@end-@cmd
045A93 5B DF       1293*      rst.lil $18
045A95 C9          1294*      ret
045A96 17 1B 0B    1295*  @cmd: db 23,27,11
045A99             1296*  @end:
045A99             1297*  
045A99             1298*  ; VDU 23, 27, 12: Hide current sprite
045A99             1299*  ; inputs: none
045A99             1300*  ; prerequisites: vdu_sprite_select
045A99             1301*  vdu_sprite_hide:
045A99 21 A4 5A 04 1302*      ld hl,@cmd
045A9D 01 03 00 00 1303*      ld bc,@end-@cmd
045AA1 5B DF       1304*      rst.lil $18
045AA3 C9          1305*      ret
045AA4 17 1B 0C    1306*  @cmd: db 23,27,12
045AA7             1307*  @end:
045AA7             1308*  
045AA7             1309*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
045AA7             1310*  ; inputs: bc is x coordinate, de is y coordinate
045AA7             1311*  ; prerequisites: vdu_sprite_select
045AA7             1312*  vdu_sprite_move_abs:
045AA7 ED 43 BF 5A 1313*      ld (@xpos),bc
       04          
045AAC ED 53 C1 5A 1314*      ld (@ypos),de
       04          
045AB1 21 BC 5A 04 1315*      ld hl,@cmd
045AB5 01 07 00 00 1316*      ld bc,@end-@cmd
045AB9 5B DF       1317*      rst.lil $18
045ABB C9          1318*      ret
045ABC 17 1B 0D    1319*  @cmd:  db 23,27,13
045ABF 00 00       1320*  @xpos: dw 0x0000
045AC1 00 00       1321*  @ypos: dw 0x0000
045AC3 00          1322*  @end:  db 0x00 ; padding
045AC4             1323*  
045AC4             1324*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
045AC4             1325*  ; inputs: bc is x coordinate, de is y coordinate
045AC4             1326*  ; prerequisites: vdu_sprite_select
045AC4             1327*  vdu_sprite_move_rel:
045AC4 ED 43 DC 5A 1328*      ld (@dx),bc
       04          
045AC9 ED 53 DE 5A 1329*      ld (@dy),de
       04          
045ACE 21 D9 5A 04 1330*      ld hl,@cmd
045AD2 01 07 00 00 1331*      ld bc,@end-@cmd
045AD6 5B DF       1332*      rst.lil $18
045AD8 C9          1333*      ret
045AD9 17 1B 0E    1334*  @cmd: db 23,27,14
045ADC 00 00       1335*  @dx:  dw 0x0000
045ADE 00 00       1336*  @dy:  dw 0x0000
045AE0 00          1337*  @end: db 0x00 ; padding
045AE1             1338*  
045AE1             1339*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
045AE1             1340*  ; USING 16.8 FIXED POINT COORDINATES
045AE1             1341*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
045AE1             1342*  ;   the fractional portiion of the inputs are truncated
045AE1             1343*  ;   leaving only the 16-bit integer portion
045AE1             1344*  ; prerequisites: vdu_sprite_select
045AE1             1345*  vdu_sprite_move_abs168:
045AE1             1346*  ; populate in the reverse of normal to keep the
045AE1             1347*  ; inputs from stomping on each other
045AE1 ED 53 00 5B 1348*      ld (@ypos-1),de
       04          
045AE6 ED 43 FE 5A 1349*      ld (@xpos-1),bc
       04          
045AEB 3E 0D       1350*      ld a,13       ; restore the final byte of the command
045AED 32 FE 5A 04 1351*      ld (@cmd+2),a ; string that got stomped on by bcu
045AF1 21 FC 5A 04 1352*      ld hl,@cmd
045AF5 01 07 00 00 1353*      ld bc,@end-@cmd
045AF9 5B DF       1354*      rst.lil $18
045AFB C9          1355*      ret
045AFC 17 1B 0D    1356*  @cmd:  db 23,27,13
045AFF 00 00       1357*  @xpos: dw 0x0000
045B01 00 00       1358*  @ypos: dw 0x0000
045B03             1359*  @end:  ; no padding required b/c we shifted de right
045B03             1360*  
045B03             1361*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
045B03             1362*  ; USING 16.8 FIXED POINT COORDINATES
045B03             1363*  ; inputs: ub.c is dx, ud.e is dy
045B03             1364*  ;   the fractional portiion of the inputs are truncated
045B03             1365*  ;   leaving only the 16-bit integer portion
045B03             1366*  ; prerequisites: vdu_sprite_select
045B03             1367*  vdu_sprite_move_rel168:
045B03             1368*  ; populate in the reverse of normal to keep the
045B03             1369*  ; inputs from stomping on each other
045B03 ED 53 22 5B 1370*      ld (@dy-1),de
       04          
045B08 ED 43 20 5B 1371*      ld (@dx-1),bc
       04          
045B0D 3E 0E       1372*      ld a,14       ; restore the final byte of the command
045B0F 32 20 5B 04 1373*      ld (@cmd+2),a ; string that got stomped on by bcu
045B13 21 1E 5B 04 1374*      ld hl,@cmd
045B17 01 07 00 00 1375*      ld bc,@end-@cmd
045B1B 5B DF       1376*      rst.lil $18
045B1D C9          1377*      ret
045B1E 17 1B 0E    1378*  @cmd:  db 23,27,14
045B21 00 00       1379*  @dx: dw 0x0000
045B23 00 00       1380*  @dy: dw 0x0000
045B25             1381*  @end:  ; no padding required b/c we shifted de right
045B25             1382*  
045B25             1383*  ; VDU 23, 27, 15: Update the sprites in the GPU
045B25             1384*  ; inputs: none
045B25             1385*  vdu_sprite_update:
045B25 21 30 5B 04 1386*      ld hl,@cmd
045B29 01 03 00 00 1387*      ld bc,@end-@cmd
045B2D 5B DF       1388*      rst.lil $18
045B2F C9          1389*      ret
045B30 17 1B 0F    1390*  @cmd: db 23,27,15
045B33             1391*  @end:
045B33             1392*  
045B33             1393*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
045B33             1394*  ; inputs: none
045B33             1395*  vdu_sprite_bmp_reset:
045B33 21 3E 5B 04 1396*      ld hl,@cmd
045B37 01 03 00 00 1397*      ld bc,@end-@cmd
045B3B 5B DF       1398*      rst.lil $18
045B3D C9          1399*      ret
045B3E 17 1B 10    1400*  @cmd: db 23,27,16
045B41             1401*  @end:
045B41             1402*  
045B41             1403*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
045B41             1404*  ; inputs: none
045B41             1405*  vdu_sprite_reset:
045B41 21 4C 5B 04 1406*      ld hl,@cmd
045B45 01 03 00 00 1407*      ld bc,@end-@cmd
045B49 5B DF       1408*      rst.lil $18
045B4B C9          1409*      ret
045B4C 17 1B 11    1410*  @cmd: db 23,27,17
045B4F             1411*  @end:
045B4F             1412*  
045B4F             1413*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
045B4F             1414*  ; inputs: a is the GCOL paint mode
045B4F             1415*  ; prerequisites: vdu_sprite_select
045B4F             1416*  vdu_sprite_set_gcol:
045B4F 32 61 5B 04 1417*      ld (@mode),a
045B53 21 5E 5B 04 1418*      ld hl,@cmd
045B57 01 04 00 00 1419*      ld bc,@end-@cmd
045B5B 5B DF       1420*      rst.lil $18
045B5D C9          1421*      ret
045B5E 17 1B 12    1422*  @cmd:  db 23,27,18
045B61 00          1423*  @mode: db 0x00
045B62             1424*  @end:
045B62             1425*  
045B62             1426*  ; VDU 23, 27, &26, n;: Add bitmap bufferId
045B62             1427*  ;     as a frame to current sprite using a 16-bit buffer ID
045B62             1428*  ; inputs: hl=bufferId
045B62             1429*  ; prerequisites: vdu_sprite_select
045B62             1430*  vdu_sprite_add_buff:
045B62 22 74 5B 04 1431*      ld (@bufferId),hl
045B66 21 71 5B 04 1432*      ld hl,@cmd
045B6A 01 05 00 00 1433*      ld bc,@end-@cmd
045B6E 5B DF       1434*      rst.lil $18
045B70 C9          1435*      ret
045B71 17 1B 26    1436*  @cmd:      db 23,27,0x26
045B74 00 00       1437*  @bufferId: dw 0x0000
045B76 00          1438*  @end:      db 0x00 ; padding
045B77             0056       include "nurples/src/asm/vdu_buff.inc"
045B77             0001*  ; VDP Buffered Commands API
045B77             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Buffered-Commands-API.html
045B77             0003*  
045B77             0004*  ; VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
045B77             0005*  ; This command is used to store a data block (a sequence of bytes)
045B77             0006*  ; in a buffer on the VDP. The exact nature of this data may vary.
045B77             0007*  ; It could be a sequence of VDU commands which can be executed
045B77             0008*  ; later, a bitmap, a sound sample, or just a sequence of bytes.
045B77             0009*  ; When used for a sequence of VDU commands, this effectively
045B77             0010*  ; allows for functions or stored procedures to be created.
045B77             0011*  
045B77             0012*  ; This is the most common command to use to send data to the VDP.
045B77             0013*  ; Typically you will call command 2 first to ensure that the
045B77             0014*  ; buffer is empty, and then make a series of calls to this command
045B77             0015*  ; to send data to the buffer.
045B77             0016*  
045B77             0017*  ; The bufferId is a 16-bit integer that identifies the buffer to
045B77             0018*  ; write to. Writing to the same buffer ID multiple times will add
045B77             0019*  ; new blocks to that buffer. This allows a buffer to be built up
045B77             0020*  ; over time, essentially allowing for a command to be sent across
045B77             0021*  ; to the VDP in multiple separate packets.
045B77             0022*  
045B77             0023*  ; Whilst the length of an individual block added using this command
045B77             0024*  ; is restricted to 65535 bytes (as the largest value that can be
045B77             0025*  ; sent in a 16-bit number) the total size of a buffer is not
045B77             0026*  ; restricted to this size, as multiple blocks can be added to a
045B77             0027*  ; buffer. Given how long it takes to send data to the VDP it is
045B77             0028*  ; advisable to send data across in smaller chunks, such as 1kb of
045B77             0029*  ; data or less at a time.
045B77             0030*  
045B77             0031*  ; As writing to a single buffer ID is cumulative with this command,
045B77             0032*  ; care should be taken to ensure that the buffer is cleared out
045B77             0033*  ; before writing to it.
045B77             0034*  
045B77             0035*  ; When building up a complex sequence of commands it is often
045B77             0036*  ; advisable to use multiple blocks within a buffer. Typically
045B77             0037*  ; this is easier to code, as otherwise working out exactly how
045B77             0038*  ; many bytes long a command sequence is can be can be onerously
045B77             0039*  ; difficult. It is also easier to modify a command sequences that
045B77             0040*  ; are broken up into multiple blocks.
045B77             0041*  
045B77             0042*  ; As mentioned above it is advisable to send large pieces of data,
045B77             0043*  ; such as bitmaps or sound samples, in smaller chunks. In between
045B77             0044*  ; each packet of data sent to a buffer, the user can then perform
045B77             0045*  ; other operations, such as updating the screen to indicate
045B77             0046*  ; progress. This allows for long-running operations to be performed
045B77             0047*  ; without blocking the screen, and larger amounts of data to be
045B77             0048*  ; transferred over to the VDP than may otherwise be practical given
045B77             0049*  ; the limitations of the eZ80.
045B77             0050*  
045B77             0051*  ; If a buffer ID of 65535 is used then this command will be
045B77             0052*  ; ignored, and the data discarded. This is because this buffer ID
045B77             0053*  ; is reserved for special functions.
045B77             0054*  
045B77             0055*  ; Using buffers for bitmaps
045B77             0056*  
045B77             0057*  ; Whilst it is advisable to send bitmaps over in multiple blocks,
045B77             0058*  ; they cannot be used if they are spread over multiple blocks.
045B77             0059*  ; To use a bitmap its data must be in a single contiguous block,
045B77             0060*  ; and this is achieved by using the consolidate command &0E.
045B77             0061*  
045B77             0062*  ; Once you have a block that is ready to be used for a bitmap,
045B77             0063*  ; the buffer must be selected, and then a bitmap created for that
045B77             0064*  ; buffer using the bitmap and sprites API. This is done with the
045B77             0065*  ; following commands:
045B77             0066*  
045B77             0067*  ; VDU 23, 27, &20, bufferId;              : REM Select bitmap (using a buffer ID)
045B77             0068*  ; VDU 23, 27, &21, width; height; format  : REM Create bitmap from buffer
045B77             0069*  
045B77             0070*  ; Until the create bitmap call has been made the buffer cannot
045B77             0071*  ; be used as a bitmap. That is because the system needs to
045B77             0072*  ; understand the dimensions of the bitmap, as well as the format
045B77             0073*  ; of the data. Usually this only needs to be done once. The format
045B77             0074*  ; is given as an 8-bit value, with the following values supported:
045B77             0075*  ; Value 	Type 	Description
045B77             0076*  ; 0 	RGBA8888 	RGBA, 8-bits per channel, with bytes ordered sequentially for red, green, blue and alpha
045B77             0077*  ; 1 	RGBA2222 	RGBA, 2-bits per channel, with bits ordered from highest bits as alpha, blue, green and red
045B77             0078*  ; 2 	Mono 	Monochrome, 1-bit per pixel
045B77             0079*  
045B77             0080*  ; The existing bitmap API uses an 8-bit number to select bitmaps,
045B77             0081*  ; and these are automatically stored in buffers numbered 64000-64255
045B77             0082*  ; (&FA00-&FAFF). Working out the buffer number for a bitmap is
045B77             0083*  ; simply a matter of adding 64000. All bitmaps created with that
045B77             0084*  ; API will be RGBA8888 format.
045B77             0085*  
045B77             0086*  ; There is one other additional call added to the bitmap and
045B77             0087*  ; sprites API, which allows for bitmaps referenced with a
045B77             0088*  ; buffer ID to be added to sprites. This is done with the
045B77             0089*  ; following command:
045B77             0090*  
045B77             0091*  ; VDU 23, 27, &26, bufferId;              : REM Add bitmap to the current sprite
045B77             0092*  
045B77             0093*  ; This command otherwise works identically to VDU 23, 27, 6.
045B77             0094*  
045B77             0095*  ; It should be noted that it is possible to modify the buffer
045B77             0096*  ; that a bitmap is stored in using the adjust buffer contents
045B77             0097*  ; and reverse contents commands (5 and 24 respectively). This
045B77             0098*  ; can allow you to do things such as changing colours in a bitmap,
045B77             0099*  ; or flipping an image horizontally or vertically. This will even
045B77             0100*  ; work on bitmaps that are being used inside sprites.
045B77             0101*  
045B77             0102*  ; Using commands targetting a buffer that create new blocks,
045B77             0103*  ; such as consolidate or split, will invalidate the bitmap
045B77             0104*  ; and remove it from use.
045B77             0105*  
045B77             0106*  ; Using buffers for sound samples
045B77             0107*  
045B77             0108*  ; Much like with bitmaps, it is advisable to send samples over
045B77             0109*  ; to the VDP in multiple blocks for the same reasons.
045B77             0110*  
045B77             0111*  ; In contrast to bitmaps, the sound system can play back samples
045B77             0112*  ; that are spread over multiple blocks, so there is no need to
045B77             0113*  ; consolidate buffers. As a result of this, the sample playback
045B77             0114*  ; system is also more tolerant of modifications being made to
045B77             0115*  ; the buffer after a sample has been created from it, even if
045B77             0116*  ; the sample is currently playing. It should be noted that
045B77             0117*  ; splitting a buffer may result in unexpected behaviour if
045B77             0118*  ; the sample is currently playing, such as skipping to other
045B77             0119*  ; parts of the sample.
045B77             0120*  
045B77             0121*  ; Once you have a buffer that contains block(s) that are ready
045B77             0122*  ; to be used for a sound sample, the following command must be
045B77             0123*  ; used to indicate that a sample should be created from that buffer:
045B77             0124*  
045B77             0125*  ; VDU 23, 0, &85, 0, 5, 2, bufferId; format
045B77             0126*  
045B77             0127*  ; The format parameter is an 8-bit value that indicates the
045B77             0128*  ; format of the sample data. The following values are supported:
045B77             0129*  ; Value 	Description
045B77             0130*  ; 0 	8-bit signed, 16KHz
045B77             0131*  ; 1 	8-bit unsigned, 16KHz
045B77             0132*  
045B77             0133*  ; Once a sample has been created in this way, the sample can
045B77             0134*  ; be selected for use on a channel using the following command:
045B77             0135*  
045B77             0136*  ; VDU 23, 0, &85, channel, 4, 8, bufferId;
045B77             0137*  
045B77             0138*  ; Samples uploaded using the existing load sample command
045B77             0139*  ; (VDU 23, 0, &85, sampleNumber, 5, 0, length; lengthHighByte, <sample data>)
045B77             0140*  ; are also stored in buffers automatically. A sample number using this system is in
045B77             0141*  ; the range of -1 to -128, but these are stored in the range 64256-64383 (&FB00-&FB7F).
045B77             0142*  ; To map a number to a buffer range, you need to negate it, subtract 1, and then add
045B77             0143*  ; it to 64256. This means sample number -1 is stored in buffer 64256, -2 is stored in
045B77             0144*  ; buffer 64257, and so on.
045B77             0145*  ; Command 1: Call a buffer
045B77             0146*  
045B77             0147*  ; VDU 23, 0 &A0, bufferId; 1
045B77             0148*  
045B77             0149*  ; This command will attempt to execute all of the commands
045B77             0150*  ; stored in the buffer with the given ID. If the buffer does
045B77             0151*  ; not exist, or is empty, then this command will do nothing.
045B77             0152*  
045B77             0153*  ; Essentially, this command passes the contents of the buffer
045B77             0154*  ; to the VDPs VDU command processor system, and executes them
045B77             0155*  ; as if they were sent directly to the VDP.
045B77             0156*  
045B77             0157*  ; As noted against command 0, it is possible to build up a
045B77             0158*  ; buffer over time by sending across multiple commands to write
045B77             0159*  ; to the same buffer ID. When calling a buffer with multiple
045B77             0160*  ; blocks, the blocks are executed in order.
045B77             0161*  
045B77             0162*  ; Care should be taken when using this command within a buffer,
045B77             0163*  ; as it is possible to create an infinite loop. For instance,
045B77             0164*  ; if a buffer contains a command to call itself, then this will
045B77             0165*  ; result in an infinite loop. This will cause the VDP to hang,
045B77             0166*  ; and the only way to recover from this is to reset the VDP.
045B77             0167*  
045B77             0168*  ; Using a bufferId of -1 (65535) will cause the current buffer
045B77             0169*  ; to be executed. This can be useful for creating loops within
045B77             0170*  ; a buffer. It will be ignored if used outside of a buffered
045B77             0171*  ; command sequence.
045B77             0172*  
045B77             0173*  ; Command 2: Clear a buffer
045B77             0174*  ; VDU 23, 0 &A0, bufferId; 2
045B77             0175*  
045B77             0176*  ; This command will clear the buffer with the given ID. If
045B77             0177*  ; the buffer does not exist then this command will do nothing.
045B77             0178*  
045B77             0179*  ; Please note that this clears out all of the blocks sent to
045B77             0180*  ; a buffer via command 0, not just the last one. i.e. if you
045B77             0181*  ; have built up a buffer over time by sending multiple commands
045B77             0182*  ; to write to the same buffer ID, this command will clear out
045B77             0183*  ; all of those commands.
045B77             0184*  
045B77             0185*  ; Calling this command with a bufferId value of -1 (65535) will
045B77             0186*  ; clear out all buffers.
045B77             0187*  
045B77             0188*  ; Command 3: Create a writeable buffer
045B77             0189*  ; VDU 23, 0 &A0, bufferId; 3, length;
045B77             0190*  ; This command will create a new writeable buffer with the given
045B77             0191*  ; ID. If a buffer with the given ID already exists then this
045B77             0192*  ; command will do nothing. This command is primarily intended
045B77             0193*  ; for use to create a buffer that can be used to capture output
045B77             0194*  ; using the set output stream command (see below), or to store
045B77             0195*  ; data that can be used for other commands.
045B77             0196*  
045B77             0197*  ; It is generally quite rare that you will want to use this
045B77             0198*  ; command. Typically you will instead want to use command 0
045B77             0199*  ; to write data to a buffer. It is not necessary to use this
045B77             0200*  ; command before using command 0, and indeed doing so will
045B77             0201*  ; lead to errors as you will end up with two blocks in the
045B77             0202*  ; buffer, the first of which will be empty. If you do wish
045B77             0203*  ; to use this command to create a buffer for data and then
045B77             0204*  ; write to it, you would need to use operation 2 of command 5,
045B77             0205*  ; the set operation in the buffer adjust command, to set a
045B77             0206*  ; sequence of bytes in the buffer to the data you want to write.
045B77             0207*  ; This is not recommended, as it is much easier to just use
045B77             0208*  ; command 0 to write a data block to a buffer.
045B77             0209*  
045B77             0210*  ; This new buffer will be a single empty single block upon
045B77             0211*  ; creation, containing zeros.
045B77             0212*  
045B77             0213*  ; The length parameter is a 16-bit integer that specifies
045B77             0214*  ; the maximum size of the buffer. This is the maximum number
045B77             0215*  ; of bytes that can be stored in the buffer. If the buffer
045B77             0216*  ; is full then no more data can be written to it, and subsequent
045B77             0217*  ; writes will be ignored.
045B77             0218*  
045B77             0219*  ; After creating a buffer with this command it is possible to
045B77             0220*  ; use command 0 to write further blocks to the buffer, however
045B77             0221*  ; this is probably not advisable.
045B77             0222*  
045B77             0223*  ; A bufferId of -1 (65535) and 0 will be ignored, as these
045B77             0224*  ; values have special meanings for writable buffers. See command 4.
045B77             0225*  
045B77             0226*  ; Command 4: Set output stream to a buffer
045B77             0227*  ; VDU 23, 0 &A0, bufferId; 4
045B77             0228*  
045B77             0229*  ; Sets then current output stream to the buffer with the given ID.
045B77             0230*  ; With two exceptions, noted below, this needs to be a writable
045B77             0231*  ; buffer created with command 3. If the buffer does not exist,
045B77             0232*  ; or the first block within the buffer is not writable, then
045B77             0233*  ; this command will do nothing.
045B77             0234*  
045B77             0235*  ; Following this command, any subsequent VDU commands that send
045B77             0236*  ; response packets will have those packets written to the specified
045B77             0237*  ; output buffer. This allows the user to capture the response
045B77             0238*  ; packets from a command sent to the VDP.
045B77             0239*  
045B77             0240*  ; By default, the output stream (for the main VDU command processor)
045B77             0241*  ; is the communications channel from the VDP to MOS running on the
045B77             0242*  ; eZ80.
045B77             0243*  
045B77             0244*  ; Passing a buffer ID of -1 (65535) to this command will
045B77             0245*  ; remove/detach the output buffer. From that point onwards,
045B77             0246*  ; any subsequent VDU commands that send response packets will
045B77             0247*  ; have those responses discarded/ignored.
045B77             0248*  
045B77             0249*  ; Passing a buffer ID of 0 to this command will set the output
045B77             0250*  ; buffer back to its original value for the current command stream.
045B77             0251*  ; Typically that will be the communications channel from the VDP to
045B77             0252*  ; MOS running on the eZ80, but this may not be the case if a nested
045B77             0253*  ; call has been made.
045B77             0254*  
045B77             0255*  ; When used inside a buffered command sequence, this command will
045B77             0256*  ; only affect the output stream for that sequence of commands, and
045B77             0257*  ; any other buffered command sequences that are called from within
045B77             0258*  ; that sequence. Once the buffered command sequence has completed,
045B77             0259*  ; the output stream will effectively be reset to its original value.
045B77             0260*  
045B77             0261*  ; It is strongly recommended to only use this command from within a
045B77             0262*  ; buffered command sequence. Whilst it is possible to use this
045B77             0263*  ; command from within a normal VDU command sequence, it is not
045B77             0264*  ; recommended as it may cause unexpected behaviour. If you do use
045B77             0265*  ; it in that context, it is very important to remember to restore
045B77             0266*  ; the original output channel using VDU 23, 0, &A0, 0; 4. (In the
045B77             0267*  ; future, this command may be disabled from being used outside of
045B77             0268*  ; a buffered command sequence.)
045B77             0269*  
045B77             0270*  ; At present, writable buffers can only be written to until the end
045B77             0271*  ; of the buffer has been reached; once that happens no more data
045B77             0272*  ; will be written to the buffer. It is not currently possible to
045B77             0273*  ; rewind an output stream. It is therefore advisable to ensure
045B77             0274*  ; that the buffer is large enough to capture all of the data that
045B77             0275*  ; is expected to be written to it. The only current way to rewind
045B77             0276*  ; an output stream would be to clear the buffer and create a new
045B77             0277*  ; one, and then call set output stream again with the newly created
045B77             0278*  ; buffer.
045B77             0279*  
045B77             0280*  ; Command 5: Adjust buffer contents
045B77             0281*  ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
045B77             0282*  
045B77             0283*  ; This command will adjust the contents of a buffer, at a given
045B77             0284*  ; offset. The exact nature of the adjustment will depend on the
045B77             0285*  ; operation used.
045B77             0286*  
045B77             0287*  ; Passing a bufferId of -1 (65535) to this command will adjust
045B77             0288*  ; the contents of the current buffer. This will only work if this
045B77             0289*  ; command is used within a buffered command sequence, otherwise the
045B77             0290*  ; command will not do anything.
045B77             0291*  
045B77             0292*  ; The basic set of adjustment operations are as follows:
045B77             0293*  ; Operation 	Description
045B77             0294*  ; 0 	NOT
045B77             0295*  ; 1 	Negate
045B77             0296*  ; 2 	Set value
045B77             0297*  ; 3 	Add
045B77             0298*  ; 4 	Add with carry
045B77             0299*  ; 5 	AND
045B77             0300*  ; 6 	OR
045B77             0301*  ; 7 	XOR
045B77             0302*  
045B77             0303*  ; All of these operations will modify a byte found at the given
045B77             0304*  ; offset in the buffer. The only exception to that is the Add with
045B77             0305*  ; carry operation, which will also store the carry value in the
045B77             0306*  ; byte at the next offset. With the exception of NOT and Negate,
045B77             0307*  ; each command requires an operand value to be specified.
045B77             0308*  
045B77             0309*  ; To flip the bits of a byte at offset 12 in buffer 3, you would
045B77             0310*  ; need to use the NOT operation, and so the following command would
045B77             0311*  ; be used:
045B77             0312*  
045B77             0313*  ; VDU 23, 0, &A0, 3; 5, 0, 12;
045B77             0314*  
045B77             0315*  ; To add 42 to the byte at offset 12 in buffer 3, you would need
045B77             0316*  ; to use the Add operation, and so the following command would be
045B77             0317*  ; used:
045B77             0318*  
045B77             0319*  ; VDU 23, 0, &A0, 3; 5, 3, 12; 42
045B77             0320*  
045B77             0321*  ; When using add with carry, the carry value is stored in the byte
045B77             0322*  ; at the next offset. So to add 42 to the byte at offset 12 in
045B77             0323*  ; buffer 3, and store the carry value in the byte at offset 13,
045B77             0324*  ; you would need to use the Add with carry operation, and so the
045B77             0325*  ; following command would be used:
045B77             0326*  
045B77             0327*  ; VDU 23, 0, &A0, 3; 5, 4, 12; 42
045B77             0328*  
045B77             0329*  ; Advanced operations
045B77             0330*  
045B77             0331*  ; Whilst these operations are useful, they are not particularly
045B77             0332*  ; powerful as they only operate one one byte at a time, with a
045B77             0333*  ; fixed operand value, and potentially cannot reach all bytes in
045B77             0334*  ; a buffer. To address this, the API supports a number of advanced
045B77             0335*  ; operations.
045B77             0336*  
045B77             0337*  ; The operation value used is an 8-bit value that can have bits
045B77             0338*  ; set to modify the behaviour of the operation. The following bits
045B77             0339*  ; are defined:
045B77             0340*  ; Bit 	Description
045B77             0341*  ; &10 	Use advanced offsets
045B77             0342*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
045B77             0343*  ; &40 	Multiple target values should be adjusted
045B77             0344*  ; &80 	Multiple operand values should be used
045B77             0345*  
045B77             0346*  ; These bits can be combined together to modify the behaviour of
045B77             0347*  ; the operation.
045B77             0348*  
045B77             0349*  ; Fundamentally, this command adjusts values of a buffer at a given
045B77             0350*  ; offset one byte at a time. When either of the multiple variants
045B77             0351*  ; are used, a 16-bit count must be provided to indicate how many
045B77             0352*  ; bytes should be altered.
045B77             0353*  
045B77             0354*  ; Advanced offsets are sent as a 24-bit value in little-endian
045B77             0355*  ; order, which can allow for buffers that are larger than 64kb
045B77             0356*  ; to be adjusted. If the top-bit of this 24-bit value is set, then
045B77             0357*  ; the 16-bit value immediately following the offset is used as a
045B77             0358*  ; block index number, and the remaining 23-bits of the offset value
045B77             0359*  ; are used as an offset within that block. When the advanced
045B77             0360*  ; offset mode bit has been set then all offsets associated with
045B77             0361*  ; this command must be sent as advanced offsets.
045B77             0362*  
045B77             0363*  ; The buffer-fetched value mode allows for the operand value to
045B77             0364*  ; be fetched from a buffer. The operand sent as part of the
045B77             0365*  ; command in this case is a pair of 16-bit values giving the
045B77             0366*  ; buffer ID and offset to indicate where the actual operand value
045B77             0367*  ; should be fetched from. An operand buffer ID of -1 (65535) will
045B77             0368*  ; be interpretted as meaning this buffer, and thus can only be
045B77             0369*  ; used inside a buffered command sequence. If the advanced offset
045B77             0370*  ; mode is used, then the operand value is an advanced offset value.
045B77             0371*  
045B77             0372*  ; The multiple target values mode allows for multiple bytes to
045B77             0373*  ; be adjusted at once. When this mode is used, the count value
045B77             0374*  ; must be provided to indicate how many bytes should be adjusted.
045B77             0375*  ; Unless the multiple operand values mode is also used, the
045B77             0376*  ; operand value is used for all bytes adjusted.
045B77             0377*  
045B77             0378*  ; The multiple operand values mode allows for multiple operand
045B77             0379*  ; values to be used. When this mode is used, the count value must
045B77             0380*  ; be provided to indicate how many operand values should be used.
045B77             0381*  ; This can allow, for instance, to add together several bytes in a
045B77             0382*  ; buffer. When this mode is used in conjunction with the multiple
045B77             0383*  ; target values mode, the number of operand values must match the
045B77             0384*  ; number of target values, and the operation happens one byte at a
045B77             0385*  ; time.
045B77             0386*  
045B77             0387*  ; Some examples of advanced operations are as follows:
045B77             0388*  
045B77             0389*  ; Flip the bits of 7 bytes in buffer 3 starting at offset 12:
045B77             0390*  
045B77             0391*  ; VDU 23, 0, &A0, 3; 5, &40, 12; 7;
045B77             0392*  
045B77             0393*  ; This uses operation 0 (NOT) with the multiple target values
045B77             0394*  ; modifier (&40).
045B77             0395*  
045B77             0396*  ; Add 42 to each of the 7 bytes in buffer 3 starting at offset 12:
045B77             0397*  
045B77             0398*  ; VDU 23, 0, &A0, 3; 5, &43, 12; 7; 42
045B77             0399*  
045B77             0400*  ; Set the byte at offset 12 in the fourth block of buffer 3 to 42:
045B77             0401*  
045B77             0402*  ; VDU 23, 0, &A0, 3; 5, &12, 12; &80, 4; 42
045B77             0403*  
045B77             0404*  ; This is using operation 2 (Set) with the advanced offsets
045B77             0405*  ; modifier (&10). As BBC BASIC doesnt natively understand how
045B77             0406*  ; to send 24-bit values it is sent as the 16-bit value 12; followed
045B77             0407*  ; by a byte with its top bit set &80 to complete the 24-bit offset
045B77             0408*  ; in little-endian order. As the top bit of the offset is set, this
045B77             0409*  ; indicates that the next 16-bit value will be a block index, 4;.
045B77             0410*  ; Finally the value to write is sent, 42.
045B77             0411*  
045B77             0412*  ; An operation like this could be used to set the position as part
045B77             0413*  ; of a draw command.
045B77             0414*  
045B77             0415*  ; Set the value in buffer 3 at offset 12 to the sum of the five
045B77             0416*  ; values 1, 2, 3, 4, 5:
045B77             0417*  
045B77             0418*  ; VDU 23, 0, &A0, 3; 5, 2, 12; 0  : REM clear out the value at
045B77             0419*  ; offset 12 (set it to 0)
045B77             0420*  ; VDU 23, 0, &A0, 3; 5, &83, 12; 5; 1, 2, 3, 4, 5
045B77             0421*  
045B77             0422*  ; AND together 7 bytes in buffer 3 starting at offset 12 with the
045B77             0423*  ; 7 bytes in buffer 4 starting at offset 42:
045B77             0424*  
045B77             0425*  ; VDU 23, 0, &A0, 3; 5, &E5, 12; 7; 4; 42;
045B77             0426*  
045B77             0427*  ; As we are working on a little-endian system, integers longer
045B77             0428*  ; than one byte are sent with their least significant byte first.
045B77             0429*  ; This means that the add with carry operation can be used to add
045B77             0430*  ; together integers of any size, so long as they are the same size.
045B77             0431*  ; To do this, both the multiple target values and multiple
045B77             0432*  ; operand values modes must be used.
045B77             0433*  
045B77             0434*  ; The following commands will add together a 16-bit, 24-bit,
045B77             0435*  ; 32-bit, and 40-bit integers, all targetting the value stored
045B77             0436*  ; in buffer 3 starting at offset 12, and all using the operand
045B77             0437*  ; value of 42:
045B77             0438*  
045B77             0439*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 2; 42;  : REM 2 bytes; a 16-bit integer
045B77             0440*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 3; 42; 0  : REM 3 bytes; a 24-bit integer
045B77             0441*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 4; 42; 0;  : REM 4 bytes; a 32-bit integer
045B77             0442*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 5; 42; 0; 0  : REM 5 bytes; a 40-bit integer
045B77             0443*  
045B77             0444*  ; Take note of how the operand value is padded out with zeros
045B77             0445*  ; to match the size of the target value. 42; is used as a base
045B77             0446*  ; to send a 16-bit value, with zeros added of either 8-bit or
045B77             0447*  ; 16-bits to pad it out to the required size. The carry value
045B77             0448*  ; will be stored at the next offset in the target buffer after
045B77             0449*  ; the complete target value. So for a 16-bit value, the carry
045B77             0450*  ; will be stored at offset 14, for a 24-bit value it will be stored
045B77             0451*  ; at offset 15, and so on.
045B77             0452*  
045B77             0453*  ; Command 6: Conditionally call a buffer
045B77             0454*  
045B77             0455*  ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
045B77             0456*  
045B77             0457*  ; This command will conditionally call a buffer if the condition
045B77             0458*  ; operation passes. This command works in a similar manner to the
045B77             0459*  ; Adjust buffer contents command.
045B77             0460*  
045B77             0461*  ; With this command a buffer ID of 65535 (-1) is always
045B77             0462*  ; interpretted as current buffer, and so can only be used
045B77             0463*  ; within a buffered command sequence. If used outside of a
045B77             0464*  ; buffered command sequence then this command will do nothing.
045B77             0465*  
045B77             0466*  ; The basic set of condition operations are as follows:
045B77             0467*  ; Operation 	Description
045B77             0468*  ; 0 	Exists (value is non-zero)
045B77             0469*  ; 1 	Not exists (value is zero)
045B77             0470*  ; 2 	Equal
045B77             0471*  ; 3 	Not equal
045B77             0472*  ; 4 	Less than
045B77             0473*  ; 5 	Greater than
045B77             0474*  ; 6 	Less than or equal
045B77             0475*  ; 7 	Greater than or equal
045B77             0476*  ; 8 	AND
045B77             0477*  ; 9 	OR
045B77             0478*  
045B77             0479*  ; The value that is being checked is fetched from the specified
045B77             0480*  ; check buffer ID and offset. With the exception of Exists and
045B77             0481*  ; Not exists, each command requires an operand value to be
045B77             0482*  ; specified to check against.
045B77             0483*  
045B77             0484*  ; The operation value used is an 8-bit value that can have bits
045B77             0485*  ; set to modify the behaviour of the operation. The following bits
045B77             0486*  ; are defined:
045B77             0487*  ; Bit value 	Description
045B77             0488*  ; &10 	Use advanced offsets
045B77             0489*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
045B77             0490*  
045B77             0491*  ; These modifiers can be combined together to modify the behaviour
045B77             0492*  ; of the operation.
045B77             0493*  
045B77             0494*  ; At this time, unlike with the adjust command, multiple target
045B77             0495*  ; values and multiple operand values are not supported. All
045B77             0496*  ; comparisons are therefore only conducted on single 8-bit values.
045B77             0497*  ; (If comparisons of 16-bit values are required, multiple calls
045B77             0498*  ; can be combined.) Support for them may be added in the future.
045B77             0499*  
045B77             0500*  ; The AND and OR operations are logical operations, and so the
045B77             0501*  ; operand value is used as a boolean value. Any non-zero value is
045B77             0502*  ; considered to be true, and zero is considered to be false. These
045B77             0503*  ; operations therefore are most useful when used with buffer-fetched
045B77             0504*  ; operand values (operations &28, &29, &38 and &39).
045B77             0505*  
045B77             0506*  ; Some examples of condition operations are as follows:
045B77             0507*  
045B77             0508*  ; Call buffer 7 if the value in buffer 12 at offset 5 exists
045B77             0509*  ; (is non-zero):
045B77             0510*  
045B77             0511*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
045B77             0512*  
045B77             0513*  ; Call buffer 8 if the value in buffer 12 at offset 5 does not
045B77             0514*  ; exist (is zero):
045B77             0515*  
045B77             0516*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
045B77             0517*  
045B77             0518*  ; Combining the above two examples is effectively equivalent to
045B77             0519*  ; if the value exists, call buffer 7, otherwise call buffer 8:
045B77             0520*  
045B77             0521*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
045B77             0522*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
045B77             0523*  
045B77             0524*  ; Call buffer 3 if the value in buffer 4 at offset 12 is equal to 42:
045B77             0525*  
045B77             0526*  ; VDU 23, 0, &A0, 3; 6, 2, 4; 12; 42
045B77             0527*  
045B77             0528*  ; Call buffer 5 if the value in buffer 2 at offset 7 is less than
045B77             0529*  ; the value in buffer 2 at offset 8:
045B77             0530*  
045B77             0531*  ; VDU 23, 0, &A0, 5; 6, &24, 2; 7; 2; 8;
045B77             0532*  
045B77             0533*  ; Command 7: Jump to a buffer
045B77             0534*  
045B77             0535*  ; VDU 23, 0, &A0, bufferId; 7
045B77             0536*  
045B77             0537*  ; This command will jump to the buffer with the given ID. If
045B77             0538*  ; the buffer does not exist, or is empty, then this command will
045B77             0539*  ; do nothing.
045B77             0540*  
045B77             0541*  ; This essentially works the same as the call command (command 1),
045B77             0542*  ;  except that it does not return to the caller. This command is
045B77             0543*  ;  therefore useful for creating loops.
045B77             0544*  
045B77             0545*  ; Using this command to jump to buffer 65535 (buffer ID -1) is
045B77             0546*  ; treated as a jump to end of current buffer. This will return
045B77             0547*  ; execution to the caller, and can be useful for exiting a loop.
045B77             0548*  
045B77             0549*  ; ## Command 8: Conditional Jump to a buffer
045B77             0550*  
045B77             0551*  ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
045B77             0552*  
045B77             0553*  ; This command operates in a similar manner to the Conditionally
045B77             0554*  ; call a buffer command (command 6), except that it will jump to
045B77             0555*  ; the buffer if the condition operation passes.
045B77             0556*  
045B77             0557*  ; As with the Jump to a buffer command (command 7), a jump to
045B77             0558*  ; buffer 65535 is treated as a jump to end of current buffer.
045B77             0559*  ; Command 9: Jump to an offset in a buffer
045B77             0560*  
045B77             0561*  ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
045B77             0562*  
045B77             0563*  ; This command will jump to the given offset in the buffer with the
045B77             0564*  ; given ID. If the buffer does not exist, or is empty, then this
045B77             0565*  ; command will do nothing.
045B77             0566*  
045B77             0567*  ; The offset in this command is always an advanced offset, given
045B77             0568*  ; as a 24-bit value in little-endian order. As with other uses of
045B77             0569*  ; advanced offsets, if the top-bit is set in the high byte of the
045B77             0570*  ; offset value, a block number must also be provided.
045B77             0571*  
045B77             0572*  ; When jumping to an offset, using buffer ID 65535 is treated as
045B77             0573*  ; meaning jump within current buffer. This can be useful for
045B77             0574*  ; creating loops within a buffer, or when building up command
045B77             0575*  ; sequences that may be copied across multiple buffers.
045B77             0576*  
045B77             0577*  ; Jumping to an offset that is beyond the end of the buffer is
045B77             0578*  ; equivalent to jumping to the end of the buffer.
045B77             0579*  ; Command 10: Conditional jump to an offset in a buffer
045B77             0580*  
045B77             0581*  ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
045B77             0582*  
045B77             0583*  ; A conditional jump with an offset works in a similar manner to
045B77             0584*  ; the Conditional call a buffer command (command 6), except that
045B77             0585*  ; it will jump to the given offset in the buffer if the condition
045B77             0586*  ; operation passes.
045B77             0587*  
045B77             0588*  ; As with the Jump to an offset in a buffer command (command 9),
045B77             0589*  ; the offset in this command is always an advanced offset, given
045B77             0590*  ; as a 24-bit value in little-endian order, and the usual advanced
045B77             0591*  ; offset rules apply. And similarly, using buffer ID 65535 is
045B77             0592*  ; treated as meaning jump within current buffer.
045B77             0593*  ; Command 11: Call buffer with an offset
045B77             0594*  
045B77             0595*  ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
045B77             0596*  
045B77             0597*  ; Works just like Call a buffer (command 1), except that it also
045B77             0598*  ; accepts an advanced offset.
045B77             0599*  
045B77             0600*  ; Command 12: Conditional call buffer with an offset
045B77             0601*  
045B77             0602*  ; VDU 23, 0, &A0, bufferId; 12, offset; offsetHighByte, [blockNumber;] [arguments]
045B77             0603*  
045B77             0604*  ; Works just like the Conditional call a buffer command
045B77             0605*  ; (command 6), except that it also accepts an advanced offset.
045B77             0606*  
045B77             0607*  ; Command 13: Copy blocks from multiple buffers into a single buffer
045B77             0608*  
045B77             0609*  ; VDU 23, 0, &A0, targetBufferId; 13, sourceBufferId1; sourceBufferId2; ... 65535;
045B77             0610*  
045B77             0611*  ; This command will copy the contents of multiple buffers into a
045B77             0612*  ; single buffer. The buffers to copy from are specified as a list
045B77             0613*  ; of buffer IDs, terminated by a buffer ID of -1 (65535). The
045B77             0614*  ; buffers are copied in the order they are specified.
045B77             0615*  
045B77             0616*  ; This is a block-wise copy, so the blocks from the source buffers
045B77             0617*  ; are copied into the target buffer. The blocks are copied in the
045B77             0618*  ; order they are found in the source buffers.
045B77             0619*  
045B77             0620*  ; The target buffer will be overwritten with the contents of the
045B77             0621*  ; source buffers. This will not be done however until after all the
045B77             0622*  ; data has been gathered and copied. The target buffer can therefore
045B77             0623*  ; included in the list of the source buffers.
045B77             0624*  
045B77             0625*  ; If a source buffer that does not exist is specified, or a source
045B77             0626*  ; buffer that is empty is specified, then that buffer will be ignored. If no source buffers are specified, or all of the source buffers are empty, then the target buffer will be cleared out.
045B77             0627*  
045B77             0628*  ; The list of source buffers can contain repeated buffer IDs. If a
045B77             0629*  ; buffer ID is repeated, then the blocks from that buffer will be
045B77             0630*  ; copied multiple times into the target buffer.
045B77             0631*  
045B77             0632*  ; If there is insufficient memory available on the VDP to complete
045B77             0633*  ; this command then it will fail, and the target buffer will be
045B77             0634*  ; left unchanged.
045B77             0635*  
045B77             0636*  
045B77             0637*  ; Command 14: Consolidate blocks in a buffer
045B77             0638*  
045B77             0639*  ; VDU 23, 0, &A0, bufferId; 14
045B77             0640*  
045B77             0641*  ; Takes all the blocks in a buffer and consolidates them into a
045B77             0642*  ; single block. This is useful for bitmaps, as it allows for a
045B77             0643*  ; bitmap to be built up over time in multiple blocks, and then
045B77             0644*  ; consolidated into a single block for use as a bitmap.
045B77             0645*  
045B77             0646*  ; If there is insufficient memory available on the VDP to complete
045B77             0647*  ; this command then it will fail, and the buffer will be left
045B77             0648*  ; unchanged.
045B77             0649*  
045B77             0650*  ; Command 15: Split a buffer into multiple blocks
045B77             0651*  
045B77             0652*  ; VDU 23, 0, &A0, bufferId; 15, blockSize;
045B77             0653*  
045B77             0654*  ; Splits a buffer into multiple blocks. The blockSize parameter
045B77             0655*  ; is a 16-bit integer that specifies the target size of each block.
045B77             0656*  ; If the source data is not a multiple of the block size then the
045B77             0657*  ; last block will be smaller than the specified block size.
045B77             0658*  
045B77             0659*  ; If this command is used on a buffer that is already split into
045B77             0660*  ; multiple blocks, then the blocks will be consolidated first,
045B77             0661*  ; and then re-split into the new block size.
045B77             0662*  
045B77             0663*  ; If there is insufficient memory available on the VDP to complete
045B77             0664*  ; this command then it will fail, and the buffer will be left
045B77             0665*  ; unchanged.
045B77             0666*  ; Command 16: Split a buffer into multiple blocks and spread across
045B77             0667*  ; multiple buffers
045B77             0668*  
045B77             0669*  ; VDU 23, 0, &A0, bufferId; 16, blockSize; [targetBufferId1;] [targetBufferId2;] ... 65535;
045B77             0670*  
045B77             0671*  ; Splits a buffer into multiple blocks, as per command 15, but
045B77             0672*  ; then spreads the resultant blocks across the target buffers.
045B77             0673*  ; The target buffers are specified as a list of buffer IDs,
045B77             0674*  ; terminated by a buffer ID of -1 (65535).
045B77             0675*  
045B77             0676*  ; The blocks are spread across the target buffers in the order
045B77             0677*  ; they are specified, and the spread will loop around the buffers
045B77             0678*  ; until all the blocks have been distributed. The target buffers
045B77             0679*  ; will be cleared out before the blocks are spread across them.
045B77             0680*  
045B77             0681*  ; What this means is that if the source buffer is, lets say,
045B77             0682*  ; 100 bytes in size and we split using a block size of 10 bytes
045B77             0683*  ; then we will end up with 10 blocks. If we then spread those
045B77             0684*  ; blocks across 3 target buffers, then the first buffer will
045B77             0685*  ; contain blocks 1, 4, 7 and 10, the second buffer will contain
045B77             0686*  ; blocks 2, 5 and 8, and the third buffer will contain
045B77             0687*  ; blocks 3, 6 and 9.
045B77             0688*  
045B77             0689*  ; This command attempts to ensure that, in the event of
045B77             0690*  ; insufficient memory being available on the VDP to complete
045B77             0691*  ; the command, it will leave the targets as they were before
045B77             0692*  ; the command was executed. However this may not always be
045B77             0693*  ; possible. The first step of this command is to consolidate
045B77             0694*  ; the source buffer into a single block, and this may fail from
045B77             0695*  ; insufficient memory. If that happens then all the buffers will
045B77             0696*  ; be left as they were. After this however the target buffers
045B77             0697*  ; will be cleared. If there is insufficient memory to successfully
045B77             0698*  ; split the buffer into multiple blocks then the call will exit,
045B77             0699*  ; and the target buffers will be left empty.
045B77             0700*  ; Command 17: Split a buffer and spread across blocks, starting
045B77             0701*  ; at target buffer ID
045B77             0702*  
045B77             0703*  ; VDU 23, 0, &A0, bufferId; 17, blockSize; targetBufferId;
045B77             0704*  
045B77             0705*  ; As per the above two commands, this will split a buffer into
045B77             0706*  ; multiple blocks. It will then spread the blocks across buffers
045B77             0707*  ; starting at the target buffer ID, incrementing the target buffer
045B77             0708*  ; ID until all the blocks have been distributed.
045B77             0709*  
045B77             0710*  ; Target blocks will be cleared before a block is stored in them.
045B77             0711*  ; Each target will contain a single block. The exception to this
045B77             0712*  ; is if the target buffer ID reaches 65534, as it is not possible
045B77             0713*  ; to store a block in buffer 65535. In this case, multiple blocks
045B77             0714*  ; will be placed into buffer 65534.
045B77             0715*  
045B77             0716*  ; With this command if there is insufficient memory available on
045B77             0717*  ; the VDP to complete the command then it will fail, and the target
045B77             0718*  ; buffers will be left unchanged.
045B77             0719*  
045B77             0720*  ; Command 18: Split a buffer into blocks by width
045B77             0721*  
045B77             0722*  ; VDU 23, 0, &A0, bufferId; 18, width; blockCount;
045B77             0723*  
045B77             0724*  ; This command splits a buffer into a given number of blocks by
045B77             0725*  ; first of all splitting the buffer into blocks of a given width
045B77             0726*  ; (number of bytes), and then consolidating those blocks into the
045B77             0727*  ; given number of blocks.
045B77             0728*  
045B77             0729*  ; This is useful for splitting a bitmap into a number of separate
045B77             0730*  ; columns, which can then be manipulated individually. This can be
045B77             0731*  ; useful for dealing with sprite sheets.
045B77             0732*  ; Command 19: Split by width into blocks and spread across target
045B77             0733*  ; buffers
045B77             0734*  
045B77             0735*  ; VDU 23, 0, &A0, bufferId; 19, width; [targetBufferId1;] [targetBufferId2;] ... 65535;
045B77             0736*  
045B77             0737*  ; This command essentially operates the same as command 18, but the
045B77             0738*  ; block count is determined by the number of target buffers specified. The blocks are spread across the target buffers in the order they are specified, with one block placed in each target.
045B77             0739*  
045B77             0740*  ; Command 20: Split by width into blocks and spread across blocks
045B77             0741*  ; starting at target buffer ID
045B77             0742*  
045B77             0743*  ; VDU 23, 0, &A0, bufferId; 20, width; blockCount; targetBufferId;
045B77             0744*  
045B77             0745*  ; This command essentially operates the same as command 18, but
045B77             0746*  ; the generated blocks are spread across blocks starting at the
045B77             0747*  ; target buffer ID, as per command 17.
045B77             0748*  
045B77             0749*  ; Command 21: Spread blocks from a buffer across multiple target
045B77             0750*  ; buffers
045B77             0751*  
045B77             0752*  ; VDU 23, 0, &A0, bufferId; 21, [targetBufferId1;] [targetBufferId2;] ... 65535;
045B77             0753*  
045B77             0754*  ; Spreads the blocks from a buffer across multiple target buffers.
045B77             0755*  ; The target buffers are specified as a list of buffer IDs,
045B77             0756*  ; terminated by a buffer ID of -1 (65535). The blocks are spread
045B77             0757*  ; across the target buffers in the order they are specified, and
045B77             0758*  ; the spread will loop around the buffers until all the blocks have
045B77             0759*  ; been distributed.
045B77             0760*  
045B77             0761*  ; It should be noted that this command does not copy the blocks,
045B77             0762*  ; and nor does it move them. Unless the source buffer has been
045B77             0763*  ; included in the list of targets, it will remain completely
045B77             0764*  ; intact. The blocks distributed across the target buffers will
045B77             0765*  ; point to the same memory as the blocks in the source buffer.
045B77             0766*  ; Operations to modify data in the source buffer will also modify
045B77             0767*  ; the data in the target buffers. Clearing the source buffer
045B77             0768*  ; however will not clear the target buffers.
045B77             0769*  
045B77             0770*  ; Command 22: Spread blocks from a buffer across blocks starting
045B77             0771*  ; at target buffer ID
045B77             0772*  
045B77             0773*  ; VDU 23, 0, &A0, bufferId; 22, targetBufferId;
045B77             0774*  
045B77             0775*  ; Spreads the blocks from a buffer across blocks starting at
045B77             0776*  ; the target buffer ID.
045B77             0777*  
045B77             0778*  ; This essentially works the same as command 21, and the same
045B77             0779*  ; notes about copying and moving blocks apply. Blocks are spread
045B77             0780*  ; in the same manner as commands 17 and 20.
045B77             0781*  
045B77             0782*  ; Command 23: Reverse the order of blocks in a buffer
045B77             0783*  
045B77             0784*  ; VDU 23, 0, &A0, bufferId; 23
045B77             0785*  
045B77             0786*  ; Reverses the order of the blocks in a buffer.
045B77             0787*  ; Command 24: Reverse the order of data of blocks within a buffer
045B77             0788*  
045B77             0789*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
045B77             0790*  
045B77             0791*  ; Reverses the order of the data within the blocks of a buffer.
045B77             0792*  ; The options parameter is an 8-bit value that can have bits set
045B77             0793*  ; to modify the behaviour of the operation. The following bits
045B77             0794*  ; are defined:
045B77             0795*  ; Bit value 	Description
045B77             0796*  ; 1 	Values are 16-bits in size
045B77             0797*  ; 2 	Values are 32-bits in size
045B77             0798*  ; 3 (1+2) 	If both value size bits are set, then the value size is sent as a 16-bit value
045B77             0799*  ; 4 	Reverse data of the value size within chunk of data of the specified size, sent as a 16-bit value
045B77             0800*  ; 8 	Reverse blocks
045B77             0801*  
045B77             0802*  ; These modifiers can be combined together to modify the behaviour
045B77             0803*  ; of the operation.
045B77             0804*  
045B77             0805*  ; If no value size is set in the options (i.e. the value of the
045B77             0806*  ; bottom two bits of the options is zero) then the value size is
045B77             0807*  ; assumed to be 8-bits.
045B77             0808*  
045B77             0809*  ; It is probably easiest to understand what this operation is
045B77             0810*  ; capable of by going through some examples of how it can be used
045B77             0811*  ; to manipulate bitmaps. The VDP supports two different formats
045B77             0812*  ; of color bitmap, either RGBA8888 which uses 4-bytes per pixel,
045B77             0813*  ; i.e. 32-bit values, or RGBA2222 which uses a single byte per
045B77             0814*  ; pixel.
045B77             0815*  
045B77             0816*  ; The simplest example is rotating an RGBA2222 bitmap by 180
045B77             0817*  ; degrees, which can be done by just reversing the order of
045B77             0818*  ; bytes in the buffer:
045B77             0819*  
045B77             0820*  ; VDU 23, 0, &A0, bufferId; 24, 0
045B77             0821*  
045B77             0822*  ; Rotating an RGBA8888 bitmap by 180 degrees is in principle a
045B77             0823*  ; little more complex, as each pixel is made up of 4 bytes.
045B77             0824*  ; However with this command it is still a simple operation, as
045B77             0825*  ; we can just reverse the order of the 32-bit values that make
045B77             0826*  ; up the bitmap by using an options value of 2:
045B77             0827*  
045B77             0828*  ; VDU 23, 0, &A0, bufferId; 24, 2
045B77             0829*  
045B77             0830*  ; Mirroring a bitmap around the x-axis is a matter of reversing
045B77             0831*  ; the order of rows of pixels. To do this we can set a custom
045B77             0832*  ; value size that corresponds to our bitmap width. For an RGBA2222
045B77             0833*  ; bitmap we can just set a custom value size to our bitmap width:
045B77             0834*  
045B77             0835*  ; VDU 23, 0, &A0, bufferId; 24, 3, width
045B77             0836*  
045B77             0837*  ; As an RGBA8888 bitmap uses 4 bytes per pixel we need to multiply
045B77             0838*  ; our width by 4:
045B77             0839*  
045B77             0840*  ; VDU 23, 0, &A0, bufferId; 24, 3, width * 4
045B77             0841*  
045B77             0842*  ; To mirror a bitmap around the y-axis, we need to reverse the
045B77             0843*  ; order of pixels within each row. For an RGBA2222 bitmap we can
045B77             0844*  ; just set a custom chunk size to our bitmap width:
045B77             0845*  
045B77             0846*  ; VDU 23, 0, &A0, bufferId; 24, 4, width
045B77             0847*  
045B77             0848*  ; For an RGBA8888 bitmap we need to set our options to indicate
045B77             0849*  ; 32-bit values as well as a custom chunk size:
045B77             0850*  
045B77             0851*  ; VDU 23, 0, &A0, bufferId; 24, 6, width * 4
045B77             0852*  
045B77             0853*  ; Command 25: Copy blocks from multiple buffers by reference
045B77             0854*  
045B77             0855*  ; VDU 23, 0, &A0, targetBufferId; 25, sourceBufferId1; sourceBufferId2; ...; 65535;
045B77             0856*  
045B77             0857*  ; This command is essentially a version of command 13 that copies
045B77             0858*  ; blocks by reference rather than by value. The parameters for
045B77             0859*  ; this command are the same as for command 13, and the same rules
045B77             0860*  ; apply.
045B77             0861*  
045B77             0862*  ; If the target buffer is included in the list of source buffers
045B77             0863*  ; then it will be skipped to prevent a reference loop.
045B77             0864*  
045B77             0865*  ; Copying by reference means that the blocks in the target buffer
045B77             0866*  ; will point to the same memory as the blocks in the source
045B77             0867*  ; buffers. Operations to modify data blocks in the source buffers
045B77             0868*  ; will therefore also modify those blocks in the target buffer.
045B77             0869*  ; Clearing the source buffers will not clear the target buffer -
045B77             0870*  ; it will still point to the original data blocks. Data blocks
045B77             0871*  ; are only freed from memory when no buffers are left with any
045B77             0872*  ; references to them.
045B77             0873*  
045B77             0874*  ; Buffers that get consolidated become new blocks, so will lose
045B77             0875*  ; their links to the original blocks, thus after a consolidate
045B77             0876*  ; operation modifications to the original blocks will no longer be
045B77             0877*  ; reflected in the consolidated buffer.
045B77             0878*  
045B77             0879*  ; This command is useful to construct a single buffer from multiple
045B77             0880*  ; sources without the copy overhead, which can be costly. For
045B77             0881*  ; example, this can be useful for constructing a bitmap from
045B77             0882*  ; multiple constituent parts before consolidating it into a
045B77             0883*  ; single block. In such an example, using command 13 instead
045B77             0884*  ; would first make a copy of the contents of the source buffers,
045B77             0885*  ; and then consolidate them into a single block. Using this
045B77             0886*  ; command does not make that first copy, and so would be faster.
045B77             0887*  
045B77             0888*  ; This command is also useful for creating multiple buffers that
045B77             0889*  ; all point to the same data.
045B77             0890*  
045B77             0891*  ; Command 26: Copy blocks from multiple buffers and consolidate
045B77             0892*  
045B77             0893*  ; VDU 23, 0, &A0, targetBufferId; 26, sourceBufferId1; sourceBufferId2; ...; 65535;
045B77             0057       ; include "nurples/src/asm/vdu_plot.inc"
045B77             0058   	; include "nurples/src/asm/vdu_sprites.inc"
045B77             0059   	; include "nurples/src/asm/vdp.inc"
045B77             0060   	include "nurples/src/asm/div_168_signed.inc"
045B77             0001*  ; 24-bit integer and 16.8 fixed point division routines
045B77             0002*  ; by Brandon R. Gates (BeeGee747)
045B77             0003*  ; have undergone cursory testing and seem to be generating
045B77             0004*  ; correct results (assuming no overflows) but seem very inefficient,
045B77             0005*  ; so they have been published for review and improvement
045B77             0006*  ; see: https://discord.com/channels/1158535358624039014/1158536711148675072/1212136741608099910
045B77             0007*  ;
045B77             0008*  ; ---------------------------------------------------------
045B77             0009*  ; GLOBAL SCRATCH VARIABLES
045B77             0010*  ; ---------------------------------------------------------
045B77             0011*  uaf: ds 4 ; 32-bit scratch
045B7B             0012*  uhl: ds 4 ; the extra byte at the end
045B7F             0013*  ubc: ds 4 ; is padding for overflow
045B83             0014*  ude: ds 4 ; when shifting up registers
045B87             0015*  uix: ds 4
045B8B             0016*  uiy: ds 4
045B8F             0017*  usp: ds 4
045B93             0018*  upc: ds 4
045B97             0019*  
045B97             0020*  ; ---------------------------------------------------------
045B97             0021*  ; BEGIN DIVISION ROUTINES
045B97             0022*  ; ---------------------------------------------------------
045B97             0023*  ;
045B97             0024*  ; perform signed division of 16.8 fixed place values
045B97             0025*  ; with an signed 16.8 fixed place result
045B97             0026*  ; inputs: ub.c is dividend,ud.e is divisor
045B97             0027*  ; outputs: uh.l is quotient
045B97             0028*  ; destroys: a,bc
045B97             0029*  ; note: uses carry flag to test for sign of operands and result
045B97             0030*  ;       which can be confusing and should perhaps be changed
045B97             0031*  ; note2: helper functions abs_hlu and neg_hlu have been modified
045B97             0032*  ;       to return accurate flags according to the origional signs
045B97             0033*  ;       (or zero) of this function's inputs
045B97             0034*  sdiv168:
045B97             0035*  ; make everything positive and save signs
045B97 C5          0036*      push bc         ; get bc to hl
045B98 E1          0037*      pop hl          ; for the next call
045B99 CD 3E 5C 04 0038*      call abs_hlu    ; sets sign flag if hlu was negative, zero if zero
045B9D CA D0 5B 04 0039*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
045BA1 F5          0040*      push af         ; save sign of bc
045BA2 E5          0041*      push hl         ; now put abs(hl)
045BA3 C1          0042*      pop bc          ; back into bc = abs(bc)
045BA4 EB          0043*      ex de,hl        ; now we do de same way
045BA5 CD 3E 5C 04 0044*      call abs_hlu
045BA9 CA D2 5B 04 0045*      jp z,@div_by_zero  ; if de was zero, answer is undefined and we're done
045BAD EB          0046*      ex de,hl        ; hl back to de = abs(de)
045BAE             0047*  ; determine sign of result
045BAE F2 B9 5B 04 0048*      jp p,@de_pos    ; sign positive,de is positive
045BB2 F1          0049*      pop af          ; get back sign of bc
045BB3 FA C2 5B 04 0050*      jp m,@result_pos  ; bc and de negative, result is positive
045BB7 18 05       0051*      jr @result_neg
045BB9             0052*  @de_pos:
045BB9 F1          0053*      pop af          ; get back sign of bc
045BBA F2 C2 5B 04 0054*      jp p,@result_pos   ; bc and de are both positive so result is positive
045BBE             0055*                      ; fall through to result_neg
045BBE             0056*  @result_neg:
045BBE AF          0057*      xor a           ; zero a and clear carry
045BBF 3D          0058*      dec a           ; set sign flag to negative
045BC0 18 02       0059*      jr @do_div
045BC2             0060*  @result_pos:
045BC2 AF          0061*      xor a           ; zero a and clear carry
045BC3 3C          0062*      inc a           ; set sign flag to negative
045BC4             0063*                      ; fall through to do_div
045BC4             0064*  @do_div:
045BC4 F5          0065*      push af         ; save sign of result
045BC5 CD D5 5B 04 0066*      call udiv168
045BC9 F1          0067*      pop af          ; get back sign of result
045BCA F0          0068*      ret p           ; result is positive so nothing to do
045BCB CD 4E 5C 04 0069*      call neg_hlu    ; result is negative so negate it
045BCF C9          0070*      ret
045BD0             0071*  @is_zero:           ; result is zero
045BD0 AF          0072*      xor a           ; sets zero flag, which we want,
045BD1             0073*                      ; sets pv flag which we might not (zero is parity even)
045BD1             0074*                      ; resets all others which is okay
045BD1 C9          0075*      ret
045BD2             0076*  @div_by_zero:       ; result is undefined, which isn't defined in binary
045BD2             0077*                      ; so we'll just return zero until i can think of something better
045BD2 F1          0078*      pop af          ; dummy pop
045BD3 AF          0079*      xor a           ; sets zero flag, which is ok,
045BD4             0080*                      ; sets pv flag which could be interpreted as overflow, which is good
045BD4             0081*                      ; resets all others which is okay
045BD4 C9          0082*      ret
045BD5             0083*  
045BD5             0084*  ; ; perform unsigned division of 16.8 fixed place values
045BD5             0085*  ; ; with an unsigned 16.8 fixed place result
045BD5             0086*  ; ; inputs: ub.c is dividend,ud.e is divisor
045BD5             0087*  ; ; outputs: uh.l is quotient
045BD5             0088*  ; ; destroys: a,bc
045BD5             0089*  ; udiv168:
045BD5             0090*  ; ; get the 16-bit integer part of the quotient
045BD5             0091*  ;     ; call div_24
045BD5             0092*  ;     call udiv24
045BD5             0093*  ;     ; call dumpRegistersHex
045BD5             0094*  ; ; load quotient to upper three bytes of output
045BD5             0095*  ;     ld (div168_out+1),bc
045BD5             0096*  ; ; TODO: THIS MAY BE BUGGED
045BD5             0097*  ; ; check remainder for zero, and if it is
045BD5             0098*  ; ; we can skip calculating the fractional part
045BD5             0099*  ;     add hl,de
045BD5             0100*  ;     or a
045BD5             0101*  ;     sbc hl,de
045BD5             0102*  ;     jr nz,@div256
045BD5             0103*  ;     xor a
045BD5             0104*  ;     jr @write_frac
045BD5             0105*  ; ; END TODO
045BD5             0106*  ; @div256:
045BD5             0107*  ; ; divide divisor by 256
045BD5             0108*  ;     push hl ; save remainder
045BD5             0109*  ; ; TODO: it feels like this could be more efficient
045BD5             0110*  ;     ld (ude),de
045BD5             0111*  ;     ld a,d
045BD5             0112*  ;     ld (ude),a
045BD5             0113*  ;     ld a,(ude+2)
045BD5             0114*  ;     ld (ude+1),a
045BD5             0115*  ;     xor a
045BD5             0116*  ;     ld (ude+2),a
045BD5             0117*  ;     ld hl,(ude) ; (just for now, we want it in de eventually)
045BD5             0118*  ; ; TODO: THIS MAY BE BUGGED
045BD5             0119*  ; ; now we check the shifted divisor for zero, and if it is
045BD5             0120*  ; ; we again set the fractional part to zero
045BD5             0121*  ;     add hl,de
045BD5             0122*  ;     or a
045BD5             0123*  ;     sbc hl,de
045BD5             0124*  ;     ex de,hl ; now de is where it's supposed to be
045BD5             0125*  ;     pop hl ; get remainder back
045BD5             0126*  ; ; TODO: THIS MAY BE BUGGED
045BD5             0127*  ;     jr nz,@div_frac
045BD5             0128*  ;     xor a
045BD5             0129*  ;     jr @write_frac
045BD5             0130*  ; ; END TODO
045BD5             0131*  ; ; now divide the remainder by the shifted divisor
045BD5             0132*  ; @div_frac:
045BD5             0133*  ;     push hl ; my kingdom for ld bc,hl
045BD5             0134*  ;     pop bc  ; or even ex bc,hl
045BD5             0135*  ;     ; call div_24
045BD5             0136*  ;     call udiv24
045BD5             0137*  ; ; load low byte of quotient to low byte of output
045BD5             0138*  ;     ld a,c
045BD5             0139*  ; @write_frac:
045BD5             0140*  ;     ld (div168_out),a
045BD5             0141*  ; ; load hl with return value
045BD5             0142*  ;     ld hl,(div168_out)
045BD5             0143*  ; ; load a with any overflow
045BD5             0144*  ;     ld a,(div168_out+3)
045BD5             0145*  ;     ret ; uh.l is the 16.8 result
045BD5             0146*  ; div168_out: ds 4 ; the extra byte is for overflow
045BD5             0147*  
045BD5             0148*  ; perform unsigned division of fixed place values
045BD5             0149*  ; with an unsigned 16.8 fixed place result
045BD5             0150*  ; inputs: b.c is 8.8 dividend, ud.e is 16.8 divisor
045BD5             0151*  ; outputs: uh.l is the 16.8 quotient ub.c is the 16.8 remainder
045BD5             0152*  ; destroys: a,bc
045BD5             0153*  udiv168:
045BD5             0154*  ; shift dividend left 8 bits
045BD5 ED 43 80 5B 0155*      ld (ubc+1),bc
       04          
045BDA AF          0156*      xor a
045BDB 32 7F 5B 04 0157*      ld (ubc),a
045BDF ED 4B 7F 5B 0158*      ld bc,(ubc)
       04          
045BE4 CD 6B 5C 04 0159*      call udiv24
045BE8             0160*  ; flip-flop outptuts to satisfy downstream consumers
045BE8             0161*  ; TODO: this is a hack and should be fixed
045BE8             0162*  ; (so says copilot ... but it's not wrong)
045BE8 E5          0163*      push hl
045BE9 C5          0164*      push bc
045BEA E1          0165*      pop hl
045BEB C1          0166*      pop bc
045BEC C9          0167*      ret
045BED             0168*  
045BED             0169*  ; this is an adaptation of Div16 extended to 24 bits
045BED             0170*  ; from https://map.grauw.nl/articles/mult_div_shifts.php
045BED             0171*  ; it works by shifting each byte of the dividend left into carry 8 times
045BED             0172*  ; and adding the dividend into hl if the carry is set
045BED             0173*  ; thus hl accumulates a remainder depending on the result of each iteration
045BED             0174*  ; ---------------------------------------------------------
045BED             0175*  ; Divide 24-bit unsigned values
045BED             0176*  ;   with 24-bit unsigned result
045BED             0177*  ;   and 24-bit remainder
045BED             0178*  ; In: Divide ubc by ude
045BED             0179*  ; Out: ubc = result, uhl = remainder
045BED             0180*  ; Destroys: a,hl,bc
045BED             0181*  div_24:
045BED 21 00 00 00 0182*      ld hl,0     ; Clear accumulator for remainder
045BF1             0183*  ; put dividend in scratch so we can get at all its bytes
045BF1 ED 43 7F 5B 0184*      ld (ubc),bc ; scratch ubc also accumulates the quotient
       04          
045BF6 3A 81 5B 04 0185*      ld a,(ubc+2); grab the upper byte of the dividend
045BFA 06 08       0186*      ld b,8      ; loop counter for 8 bits in a byte
045BFC             0187*  @loop0:
045BFC 17          0188*      rla         ; shift the next bit of dividend into the carry flag
045BFD ED 6A       0189*      adc hl,hl   ; shift the remainder left one bit and add carry if any
045BFF ED 52       0190*      sbc hl,de   ; subtract divisor from remainder
045C01 30 01       0191*      jr nc,@noadd0   ; if no carry,remainder is <= divisor
045C03             0192*                  ; meaning remainder is divisible by divisor
045C03 19          0193*      add hl,de   ; otherwise add divisor back to remainder
045C04             0194*                  ; reversing the previous subtraction
045C04             0195*  @noadd0:
045C04 10 F6       0196*      djnz @loop0 ; repeat for all 8 bits
045C06 17          0197*      rla         ; now we shift a left one more time
045C07 2F          0198*      cpl         ; then flip its bits for some reason
045C08 32 81 5B 04 0199*      ld (ubc+2),a; magically this is the upper byte of the quotient
045C0C 3A 80 5B 04 0200*      ld a,(ubc+1); now we pick up the middle byte of the dividend
045C10 06 08       0201*      ld b,8      ; set up the next loop and do it all again ...
045C12             0202*  @loop1:
045C12 17          0203*      rla
045C13 ED 6A       0204*      adc hl,hl
045C15 ED 52       0205*      sbc hl,de
045C17 30 01       0206*      jr nc,@noadd1
045C19 19          0207*      add hl,de
045C1A             0208*  @noadd1:
045C1A 10 F6       0209*      djnz @loop1
045C1C 17          0210*      rla
045C1D 2F          0211*      cpl
045C1E 32 80 5B 04 0212*      ld (ubc+1),a ; writing the middle byte of quotient
045C22 3A 7F 5B 04 0213*      ld a,(ubc)
045C26 06 08       0214*      ld b,8
045C28             0215*  @loop2:          ; compute low byte of quotient
045C28 17          0216*      rla
045C29 ED 6A       0217*      adc hl,hl
045C2B ED 52       0218*      sbc hl,de
045C2D 30 01       0219*      jr nc,@noadd2
045C2F 19          0220*      add hl,de
045C30             0221*  @noadd2:
045C30 10 F6       0222*      djnz @loop2
045C32 17          0223*      rla
045C33 2F          0224*      cpl
045C34 32 7F 5B 04 0225*      ld (ubc),a  ; ... write low byte of quotient
045C38 ED 4B 7F 5B 0226*      ld bc,(ubc) ; load quotient into bc for return
       04          
045C3D C9          0227*      ret         ; hl already contains remainder so we're done
045C3E             0228*  
045C3E             0229*  ; ---------------------------------------------------------
045C3E             0230*  ; BEGIN HELPER ROUTINES
045C3E             0231*  ; ---------------------------------------------------------
045C3E             0232*  ;
045C3E             0233*  ; absolute value of hlu
045C3E             0234*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
045C3E             0235*  ;         s1,z0,pv0,n1,c0 if hlu was negative
045C3E             0236*  ;         s0,z1,pv0,n1,c0 if hlu was zero
045C3E             0237*  ;         s0,z0,pv0,n1,c0 if hlu was positive
045C3E             0238*  ; destroys: a
045C3E             0239*  abs_hlu:
045C3E 19          0240*      add hl,de
045C3F B7          0241*      or a
045C40 ED 52       0242*      sbc hl,de
045C42 FA 47 5C 04 0243*      jp m,@is_neg
045C46 C9          0244*      ret         ; hlu is positive or zero so we're done
045C47             0245*  @is_neg:
045C47 F5          0246*      push af     ; otherwise, save current flags for return
045C48 CD 4E 5C 04 0247*      call neg_hlu ; negate hlu
045C4C F1          0248*      pop af      ; get back flags
045C4D C9          0249*      ret
045C4E             0250*  
045C4E             0251*  ; flip the sign of hlu
045C4E             0252*  ; inputs: hlu
045C4E             0253*  ; returns: 0-hlu, flags set appropriately for the result:
045C4E             0254*  ;         s1,z0,pv0,n1,c1 if result is negative
045C4E             0255*  ;         s0,z1,pv0,n1,c0 if result is zero
045C4E             0256*  ;         s0,z0,pv0,n1,c1 if result is positive
045C4E             0257*  ; destroys a
045C4E             0258*  neg_hlu:
045C4E D5          0259*      push de     ; save de
045C4F EB          0260*      ex de,hl    ; put hl into de
045C50 21 00 00 00 0261*      ld hl,0     ; clear hl
045C54 AF          0262*      xor a       ; clear carry
045C55 ED 52       0263*      sbc hl,de   ; 0-hlu = -hlu
045C57 D1          0264*      pop de      ; get de back
045C58 C9          0265*      ret         ; easy peasy
045C59             0266*  
045C59             0267*  ; -----------------------------------------------------------------------
045C59             0268*  ; https://github.com/sijnstra/agon-projects/blob/main/calc24/arith24.asm
045C59             0269*  ;------------------------------------------------------------------------
045C59             0270*  ;  arith24.asm
045C59             0271*  ;  24-bit ez80 arithmetic routines
045C59             0272*  ;  Copyright (c) Shawn Sijnstra 2024
045C59             0273*  ;  MIT license
045C59             0274*  ;
045C59             0275*  ;  This library was created as a tool to help make ez80
045C59             0276*  ;  24-bit native assembly routines for simple mathematical problems
045C59             0277*  ;  more widely available.
045C59             0278*  ;
045C59             0279*  ;------------------------------------------------------------------------
045C59             0280*  
045C59             0281*  ;------------------------------------------------------------------------
045C59             0282*  ; umul24:	HLU = BCU*DEU (unsigned)
045C59             0283*  ; Preserves AF, BCU, DEU
045C59             0284*  ; Uses a fast multiply routine.
045C59             0285*  ;------------------------------------------------------------------------
045C59             0286*  ; modified to take BCU as multiplier instead of HLU
045C59             0287*  umul24:
045C59             0288*  	; push	DE
045C59             0289*  	; push	BC
045C59             0290*  	; push	AF
045C59             0291*  	; push	HL
045C59             0292*  	; pop		BC
045C59 3E 18       0293*      ld	 	a,24 ; No. of bits to process
045C5B 21 00 00 00 0294*      ld	 	hl,0 ; Result
045C5F             0295*  umul24_lp:
045C5F 29          0296*  	add	hl,hl
045C60 EB          0297*  	ex	de,hl
045C61 29          0298*  	add	hl,hl
045C62 EB          0299*  	ex	de,hl
045C63 30 01       0300*  	jr	nc,umul24_nc
045C65 09          0301*  	add	hl,bc
045C66             0302*  umul24_nc:
045C66 3D          0303*  	dec	a
045C67 20 F6       0304*  	jr	nz,umul24_lp
045C69 0B          0305*      dec bc ; debug
045C6A             0306*  	; pop	af
045C6A             0307*  	; pop	bc
045C6A             0308*  	; pop	de
045C6A C9          0309*  	ret
045C6B             0310*  
045C6B             0311*  
045C6B             0312*  ;------------------------------------------------------------------------
045C6B             0313*  ; udiv24
045C6B             0314*  ; Unsigned 24-bit division
045C6B             0315*  ; Divides BCU by DEU. Gives result in BCU, remainder in HLU.
045C6B             0316*  ;
045C6B             0317*  ; Uses AF BC DE HL
045C6B             0318*  ; Uses Restoring Division algorithm
045C6B             0319*  ;------------------------------------------------------------------------
045C6B             0320*  ; modified to take BCU as dividend instead of HLU
045C6B             0321*  ; and give BCU as quotient instead of DEU
045C6B             0322*  ; -----------------------------------------------------------------------
045C6B             0323*  udiv24:
045C6B             0324*  	; push	hl
045C6B             0325*  	; pop		bc	;move dividend to BCU
045C6B 21 00 00 00 0326*  	ld		hl,0	;result
045C6F A7          0327*  	and		a
045C70 ED 52       0328*  	sbc		hl,de	;test for div by 0
045C72 C8          0329*  	ret		z		;it's zero, carry flag is clear
045C73 19          0330*  	add		hl,de	;HL is 0 again
045C74 3E 18       0331*  	ld		a,24	;number of loops through.
045C76             0332*  udiv1:
045C76 C5          0333*  	push	bc	;complicated way of doing this because of lack of access to top bits
045C77 E3          0334*  	ex		(sp),hl
045C78 37          0335*  	scf
045C79 ED 6A       0336*  	adc	hl,hl
045C7B E3          0337*  	ex	(sp),hl
045C7C C1          0338*  	pop	bc		;we now have bc = (bc * 2) + 1
045C7D             0339*  
045C7D ED 6A       0340*  	adc	hl,hl
045C7F A7          0341*  	and	a		;is this the bug
045C80 ED 52       0342*  	sbc	hl,de
045C82 30 02       0343*  	jr	nc,udiv2
045C84 19          0344*  	add	hl,de
045C85             0345*  ;	dec	c
045C85 0B          0346*  	dec	bc
045C86             0347*  udiv2:
045C86 3D          0348*  	dec	a
045C87 20 ED       0349*  	jr	nz,udiv1
045C89 37          0350*  	scf		;flag used for div0 error
045C8A             0351*  	; push	bc
045C8A             0352*  	; pop		de	;remainder
045C8A C9          0353*  	ret
045C8B             0354*  
045C8B             0355*  
045C8B             0356*  
045C8B             0357*  ;------------------------------------------------------------------------
045C8B             0358*  ; neg24
045C8B             0359*  ; Returns: HLU = 0-HLU
045C8B             0360*  ; preserves all other registers
045C8B             0361*  ;------------------------------------------------------------------------
045C8B             0362*  neg24:
045C8B D5          0363*  	push	de
045C8C EB          0364*  	ex		de,hl
045C8D 21 00 00 00 0365*  	ld		hl,0
045C91 B7          0366*  	or		a
045C92 ED 52       0367*  	sbc		hl,de
045C94 D1          0368*  	pop		de
045C95 C9          0369*  	ret
045C96             0370*  
045C96             0371*  ;------------------------------------------------------------------------
045C96             0372*  ; or_hlu_deu: 24 bit bitwise OR
045C96             0373*  ; Returns: hlu = hlu OR deu
045C96             0374*  ; preserves all other registers
045C96             0375*  ;------------------------------------------------------------------------
045C96             0376*  or_hlu_deu:
045C96 22 52 5D 04 0377*  	ld	(bitbuf1),hl
045C9A ED 53 55 5D 0378*  	ld	(bitbuf2),de
       04          
045C9F D5          0379*  	push	de	;preserve DEU
045CA0 C5          0380*  	push	bc	;preserve BCU
045CA1 06 03       0381*  	ld		b,3
045CA3 21 52 5D 04 0382*  	ld	hl,bitbuf1
045CA7 11 52 5D 04 0383*  	ld	de,bitbuf1
045CAB             0384*  orloop_24:
045CAB 1A          0385*  	ld	a,(de)
045CAC B6          0386*  	or	(hl)
045CAD 12          0387*  	ld	(de),a
045CAE 13          0388*  	inc	de
045CAF 23          0389*  	inc	hl
045CB0 10 F9       0390*  	djnz	orloop_24
045CB2 2A 55 5D 04 0391*  	ld	hl,(bitbuf2)
045CB6 C1          0392*  	pop		bc	;restore BC
045CB7 D1          0393*  	pop		de	;restore DE
045CB8             0394*  
045CB8             0395*  ;------------------------------------------------------------------------
045CB8             0396*  ; and_hlu_deu: 24 bit bitwise AND
045CB8             0397*  ; Returns: hlu = hlu AND deu
045CB8             0398*  ; preserves all other registers
045CB8             0399*  ;------------------------------------------------------------------------
045CB8             0400*  and_hlu_deu:
045CB8 22 52 5D 04 0401*  	ld	(bitbuf1),hl
045CBC ED 53 55 5D 0402*  	ld	(bitbuf2),de
       04          
045CC1 D5          0403*  	push	de	;preserve DEU
045CC2 C5          0404*  	push	bc	;preserve BCU
045CC3 06 03       0405*  	ld		b,3
045CC5 21 52 5D 04 0406*  	ld	hl,bitbuf1
045CC9 11 52 5D 04 0407*  	ld	de,bitbuf1
045CCD             0408*  andloop_24:
045CCD 1A          0409*  	ld	a,(de)
045CCE A6          0410*  	and	(hl)
045CCF 12          0411*  	ld	(de),a
045CD0 13          0412*  	inc	de
045CD1 23          0413*  	inc	hl
045CD2 10 F9       0414*  	djnz	andloop_24
045CD4 2A 55 5D 04 0415*  	ld	hl,(bitbuf2)
045CD8 C1          0416*  	pop		bc	;restore BC
045CD9 D1          0417*  	pop		de	;restore DE
045CDA             0418*  
045CDA             0419*  ;------------------------------------------------------------------------
045CDA             0420*  ; xor_hlu_deu: 24 bit bitwise XOR
045CDA             0421*  ; Returns: hlu = hlu XOR deu
045CDA             0422*  ; preserves all other registers
045CDA             0423*  ;------------------------------------------------------------------------
045CDA             0424*  xor_hlu_deu:
045CDA 22 52 5D 04 0425*  	ld	(bitbuf1),hl
045CDE ED 53 55 5D 0426*  	ld	(bitbuf2),de
       04          
045CE3 D5          0427*  	push	de	;preserve DEU
045CE4 C5          0428*  	push	bc	;preserve BCU
045CE5 06 03       0429*  	ld		b,3
045CE7 21 52 5D 04 0430*  	ld	hl,bitbuf1
045CEB 11 52 5D 04 0431*  	ld	de,bitbuf1
045CEF             0432*  xorloop_24:
045CEF 1A          0433*  	ld	a,(de)
045CF0 AE          0434*  	xor	(hl)
045CF1 12          0435*  	ld	(de),a
045CF2 13          0436*  	inc	de
045CF3 23          0437*  	inc	hl
045CF4 10 F9       0438*  	djnz	xorloop_24
045CF6 2A 55 5D 04 0439*  	ld	hl,(bitbuf2)
045CFA C1          0440*  	pop		bc	;restore BC
045CFB D1          0441*  	pop		de	;restore DE
045CFC             0442*  
045CFC             0443*  ;------------------------------------------------------------------------
045CFC             0444*  ; shl_hlu: 24 bit shift left hlu by deu positions
045CFC             0445*  ; Returns: hlu = hlu << deu
045CFC             0446*  ;		   de = 0
045CFC             0447*  ; NOTE: only considers deu up to 16 bits.
045CFC             0448*  ; preserves all other registers
045CFC             0449*  ;------------------------------------------------------------------------
045CFC             0450*  shl_hlu:
045CFC 7A          0451*  	ld		a,d		;up to 16 bit.
045CFD B3          0452*  	or		e
045CFE C8          0453*  	ret		z		;we're done
045CFF 29          0454*  	add		hl,hl	;shift HLU left
045D00 1B          0455*  	dec		de
045D01 18 F9       0456*  	jr		shl_hlu
045D03             0457*  
045D03             0458*  ;------------------------------------------------------------------------
045D03             0459*  ; shr_hlu: 24 bit shift right hlu by deu positions
045D03             0460*  ; Returns: hlu = hlu >> deu
045D03             0461*  ;		   de = 0
045D03             0462*  ; NOTE: only considers deu up to 16 bits.
045D03             0463*  ; preserves all other registers
045D03             0464*  ;------------------------------------------------------------------------
045D03             0465*  shr_hlu:
045D03 22 52 5D 04 0466*  	ld		(bitbuf1),hl
045D07 21 54 5D 04 0467*  	ld		hl,bitbuf1+2
045D0B             0468*  shr_loop:
045D0B 7A          0469*  	ld		a,d		;up to 16 bit.
045D0C B3          0470*  	or		e
045D0D 28 0D       0471*  	jr		z,shr_done		;we're done
045D0F             0472*  ;carry is clear from or instruction
045D0F CB 1E       0473*  	rr		(hl)
045D11 2B          0474*  	dec		hl
045D12 CB 1E       0475*  	rr		(hl)
045D14 2B          0476*  	dec		hl
045D15 CB 1E       0477*  	rr		(hl)
045D17 23          0478*  	inc		hl
045D18 23          0479*  	inc		hl
045D19 1B          0480*  	dec		de
045D1A 18 EF       0481*  	jr		shr_loop
045D1C             0482*  shr_done:
045D1C 2A 52 5D 04 0483*  	ld		hl,(bitbuf1)	;collect result
045D20 C9          0484*  	ret
045D21             0485*  
045D21             0486*  ;------------------------------------------------------------------------
045D21             0487*  ; divide hlu by 2, inspired by above
045D21             0488*  ;------------------------------------------------------------------------
045D21             0489*  hlu_div2:
045D21 22 52 5D 04 0490*  	ld		(bitbuf1),hl
045D25 21 54 5D 04 0491*  	ld		hl,bitbuf1+2
045D29 CB 1E       0492*  	rr		(hl)
045D2B 2B          0493*  	dec		hl
045D2C CB 1E       0494*  	rr		(hl)
045D2E 2B          0495*  	dec		hl
045D2F CB 1E       0496*  	rr		(hl)
045D31 23          0497*  	inc		hl
045D32 23          0498*  	inc		hl
045D33 2A 52 5D 04 0499*      ld hl,(bitbuf1)
045D37 C9          0500*      ret
045D38             0501*  
045D38             0502*  ; this is my little hack to divide by 16
045D38             0503*  hlu_div16:
045D38 AF          0504*      xor a
045D39 29          0505*      add hl,hl
045D3A 17          0506*      rla
045D3B 29          0507*      add hl,hl
045D3C 17          0508*      rla
045D3D 29          0509*      add hl,hl
045D3E 17          0510*      rla
045D3F 29          0511*      add hl,hl
045D40 17          0512*      rla
045D41 22 4E 5D 04 0513*      ld (@scratch),hl
045D45 32 51 5D 04 0514*      ld (@scratch+3),a
045D49 2A 4F 5D 04 0515*      ld hl,(@scratch+1)
045D4D C9          0516*      ret
045D4E             0517*  @scratch: ds 4
045D52             0518*  
045D52             0519*  ;------------------------------------------------------------------------
045D52             0520*  ; Scratch area for calculations
045D52             0521*  ;------------------------------------------------------------------------
045D52 00 00 00    0522*  bitbuf1:	dw24	0	;bit manipulation buffer 1
045D55 00 00 00    0523*  bitbuf2:	dw24	0	;bit manipulation buffer 2
045D58             0524*  
045D58             0525*  
045D58             0526*  ; -----------------------------------------------------------------------
045D58             0527*  ; EEMES TUTORIALS
045D58             0528*  ; -----------------------------------------------------------------------
045D58             0529*  ; https://tutorials.eeems.ca/Z80ASM/part4.htm
045D58             0530*  ; DEHL=BC*DE
045D58             0531*  Mul16:
045D58 21 00 00 00 0532*      ld hl,0
045D5C 3E 10       0533*      ld a,16
045D5E             0534*  Mul16Loop:
045D5E 29          0535*      add hl,hl
045D5F CB 13       0536*      rl e
045D61 CB 12       0537*      rl d
045D63 D2 6D 5D 04 0538*      jp nc,NoMul16
045D67 09          0539*      add hl,bc
045D68 D2 6D 5D 04 0540*      jp nc,NoMul16
045D6C 13          0541*      inc de
045D6D             0542*  NoMul16:
045D6D 3D          0543*      dec a
045D6E C2 5E 5D 04 0544*      jp nz,Mul16Loop
045D72 C9          0545*      ret
045D73             0546*  
045D73             0547*  ; DEUHLU=BCU*DEU
045D73             0548*  umul2448:
045D73 21 00 00 00 0549*      ld hl,0
045D77 3E 18       0550*      ld a,24
045D79             0551*  umul2448Loop:
045D79 29          0552*      add hl,hl
045D7A EB          0553*      ex de,hl
045D7B ED 6A       0554*      adc hl,hl
045D7D EB          0555*      ex de,hl
045D7E D2 88 5D 04 0556*      jp nc,Noumul2448
045D82 09          0557*      add hl,bc
045D83 D2 88 5D 04 0558*      jp nc,Noumul2448
045D87 13          0559*      inc de
045D88             0560*  Noumul2448:
045D88 3D          0561*      dec a
045D89 C2 79 5D 04 0562*      jp nz,umul2448Loop
045D8D C9          0563*      ret
045D8E             0564*  
045D8E             0565*  umul168:
045D8E CD 73 5D 04 0566*      call umul2448
045D92             0567*  
045D92             0568*      ; call dumpUDEUHLHex
045D92             0569*  
045D92             0570*  ; UDEU.HL is the 32.16 fixed result
045D92             0571*  ; we want UH.L to be the 16.8 fixed result
045D92             0572*  ; so we divide by 256 by shiftng down a byte
045D92             0573*  ; easiest way is to write deu and hlu to scratch
045D92 ED 53 A7 5D 0574*      ld (umul168out+3),de
       04          
045D97 22 A4 5D 04 0575*      ld (umul168out),hl
045D9B             0576*  ; then load hlu from scratch shfited forward a byte
045D9B 2A A5 5D 04 0577*      ld hl,(umul168out+1)
045D9F 3A A9 5D 04 0578*      ld a,(umul168out+5) ; send a back with any overflow
045DA3 C9          0579*      ret
045DA4             0580*  umul168out: ds 6
045DAA             0581*  
045DAA             0582*  ; perform signed multiplication of 16.8 fixed place values
045DAA             0583*  ; with an signed 16.8 fixed place result
045DAA             0584*  ; inputs: ub.c and ud.e are the operands
045DAA             0585*  ; outputs: uh.l is the product
045DAA             0586*  ; destroys: a,bc
045DAA             0587*  ; TODO: make flags appropriate to the sign of the result
045DAA             0588*  smul168:
045DAA             0589*  ; make everything positive and save signs
045DAA C5          0590*      push bc         ; get bc to hl
045DAB E1          0591*      pop hl          ; for the next call
045DAC CD 3E 5C 04 0592*      call abs_hlu    ; sets sign flag if ubc was negative, zero if zero
045DB0             0593*  
045DB0             0594*      ; call dumpFlags ; passes
045DB0             0595*  
045DB0 CA E3 5D 04 0596*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
045DB4 F5          0597*      push af         ; save sign of bc
045DB5 E5          0598*      push hl         ; now put abs(hl)
045DB6 C1          0599*      pop bc          ; back into bc = abs(bc)
045DB7 EB          0600*      ex de,hl        ; now we do de same way
045DB8 CD 3E 5C 04 0601*      call abs_hlu    ; sets sign flag if ude was negative, zero if zero
045DBC             0602*  
045DBC             0603*      ; call dumpFlags ; passes
045DBC             0604*  
045DBC CA E3 5D 04 0605*      jp z,@is_zero  ; if de was zero, answer is zero and we're done
045DC0 EB          0606*      ex de,hl        ; hl back to de = abs(de)
045DC1             0607*  ; determine sign of result
045DC1 F2 CC 5D 04 0608*      jp p,@de_pos    ; sign positive,de is positive
045DC5             0609*  
045DC5             0610*      ; call dumpFlags ; correctly doesnt make it here
045DC5             0611*  
045DC5 F1          0612*      pop af          ; get back sign of bc
045DC6             0613*  
045DC6             0614*      ; call dumpFlags ; correctly doesn't make it here
045DC6             0615*  
045DC6 FA D5 5D 04 0616*      jp m,@result_pos  ; bc and de negative, result is positive
045DCA             0617*  
045DCA             0618*      ; call dumpFlags  ; corectly doesn't make it here
045DCA             0619*  
045DCA 18 05       0620*      jr @result_neg
045DCC             0621*  @de_pos:
045DCC F1          0622*      pop af          ; get back sign of bc
045DCD             0623*  
045DCD             0624*      ; call dumpFlags  ; passes
045DCD             0625*  
045DCD F2 D5 5D 04 0626*      jp p,@result_pos   ; bc and de are both positive so result is positive
045DD1             0627*  
045DD1             0628*      ; call dumpFlags ; correctly makes it here
045DD1             0629*  
045DD1             0630*                      ; fall through to result_neg
045DD1             0631*  @result_neg:
045DD1 AF          0632*      xor a           ; zero a and clear carry
045DD2 3D          0633*      dec a           ; set sign flag to negative
045DD3             0634*  
045DD3             0635*      ; call dumpFlags ; passes
045DD3             0636*  
045DD3 18 02       0637*      jr @do_mul
045DD5             0638*  @result_pos:
045DD5 AF          0639*      xor a           ; zero a and clear carry
045DD6 3C          0640*      inc a           ; set sign flag to positive
045DD7             0641*                      ; fall through to do_mul
045DD7             0642*  
045DD7             0643*      ; call dumpFlags ; correctly doesn't make it here
045DD7             0644*  
045DD7             0645*  @do_mul:
045DD7 F5          0646*      push af         ; save sign of result
045DD8 CD 8E 5D 04 0647*      call umul168
045DDC F1          0648*      pop af          ; get back sign of result
045DDD             0649*  
045DDD             0650*      ; call dumpFlags ; passes
045DDD             0651*  
045DDD F0          0652*      ret p           ; result is positive so nothing to do
045DDE             0653*  
045DDE             0654*      ; call dumpRegistersHex ; passes
045DDE             0655*  
045DDE CD 4E 5C 04 0656*      call neg_hlu    ; result is negative so negate it
045DE2             0657*  
045DE2             0658*      ; call dumpRegistersHex ; passes
045DE2 C9          0659*      ret
045DE3             0660*  @is_zero:           ; result is zero
045DE3 AF          0661*      xor a           ; sets zero flag, which we want,
045DE4             0662*                      ; sets pv flag which we might not (zero is parity even)
045DE4             0663*                      ; resets all others which is okay
045DE4 C9          0664*      ret
045DE5             0061   	include "nurples/src/asm/maths24.inc"
045DE5             0001*  ; http://www.z80.info/pseudo-random.txt
045DE5             0002*  rand_8:
045DE5 C5          0003*      push bc
045DE6 3A F9 5D 04 0004*      ld a,(r_seed)
045DEA 4F          0005*      ld c,a
045DEB             0006*  
045DEB 0F          0007*      rrca ; multiply by 32
045DEC 0F          0008*      rrca
045DED 0F          0009*      rrca
045DEE EE 1F       0010*      xor 0x1f
045DF0             0011*  
045DF0 81          0012*      add a,c
045DF1 DE FF       0013*      sbc a,255 ; carry
045DF3             0014*  
045DF3 32 F9 5D 04 0015*      ld (r_seed),a
045DF7 C1          0016*      pop bc
045DF8 C9          0017*      ret
045DF9 50          0018*  r_seed: defb $50
045DFA             0019*  
045DFA             0020*  ; tests the sign of 24-bit register hlu
045DFA             0021*  ; returns: a in [-1,0,1]
045DFA             0022*  ;   sign and zero flags as expected
045DFA             0023*  ;   hl is untouched
045DFA             0024*  ; GPT-4 wrote most of this. the or l was inspired. it did bit 7,a instead of h
045DFA             0025*  ; and it left the zero flag set after ld a,1,which i fixed by anding it
045DFA             0026*  get_sign_hlu:
045DFA             0027*      ; Load the upper byte of HLU into A
045DFA E5          0028*      push hl
045DFB DD 21 00 00 0029*      ld ix,0
       00          
045E00 DD 39       0030*      add ix,sp
045E02 DD 7E 02    0031*      ld a,(ix+2)
045E05 E1          0032*      pop hl
045E06             0033*  
045E06 B5          0034*      or l                ; OR with the low byte to check if HL is zero
045E07 C8          0035*      ret z               ; Return if HL is zero
045E08             0036*  
045E08 3E FF       0037*      ld a,-1             ; Send A back as -1 if the sign flag is set
045E0A CB 7C       0038*      bit 7,h            ; Test the sign bit (7th bit) of the high byte
045E0C C0          0039*      ret nz              ; If set,HL is negative,return with the sign flag set
045E0D             0040*  
045E0D 3E 01       0041*      ld a,1             ; Otherwise,HL is positive
045E0F A7          0042*      and a               ; Reset the zero flag
045E10 C9          0043*      ret                 ; Return with A set to 1
045E11             0044*  
045E11             0045*  ; 16.8 fixed inputs / outputs
045E11             0046*  ; takes: uh.l as angle in degrees 256
045E11             0047*  ;        ud.e as radius
045E11             0048*  ; returns ub.c as dx, ud.e as dy
045E11             0049*  ;        displacements from origin (0,0)
045E11             0050*  ; destroys: everything except indexes
045E11             0051*  polar_to_cartesian:
045E11             0052*  ; back up input parameters
045E11 22 7B 5B 04 0053*      ld (uhl),hl
045E15 ED 53 83 5B 0054*      ld (ude),de
       04          
045E1A             0055*  ; compute dx = sin(uh.l) * ud.e
045E1A CD 49 5E 04 0056*      call sin168
045E1E E5          0057*      push hl
045E1F C1          0058*      pop bc ; ub.c = sin(uh.l)
045E20 ED 5B 83 5B 0059*  	ld de,(ude) ; get radius back
       04          
045E25 CD AA 5D 04 0060*  	call smul168 ; uh.l = ub.c * ud.e = dx
045E29 E5          0061*      push hl ; store dx for output
045E2A             0062*  ; compute dy = -cos(uh.l) * ud.e
045E2A 2A 7B 5B 04 0063*      ld hl,(uhl)
045E2E CD 44 5E 04 0064*      call cos168
045E32 CD 4E 5C 04 0065*  	call neg_hlu ; invert dy for screen coords convention
045E36 E5          0066*      push hl
045E37 C1          0067*      pop bc ; ub.c = -cos(uh.l)
045E38 ED 5B 83 5B 0068*      ld de,(ude) ; get radius back
       04          
045E3D CD AA 5D 04 0069*      call smul168 ; uh.l = ub.c * ud.e = dy
045E41 EB          0070*      ex de,hl    ; de = dy for output
045E42 C1          0071*      pop bc      ; bc = dx for output
045E43             0072*  ; and out
045E43 C9          0073*      ret
045E44             0074*  
045E44             0075*  ; fixed 16.8 routine
045E44             0076*  ; cos(uh.l) --> uh.l
045E44             0077*  ; destroys: de
045E44             0078*  cos168:
045E44             0079*  ; for cos we simply increment the angle by 90 degrees
045E44             0080*  ; or 0x004000 in 16.8 degrees256
045E44             0081*  ; which makes it a sin problem
045E44 11 00 40 00 0082*      ld de,0x004000
045E48 19          0083*      add hl,de ; modulo 256 happens below
045E49             0084*  ; fall through to sin168
045E49             0085*  ; ---------------------
045E49             0086*  ; fixed 16.8 routine
045E49             0087*  ; sin(uh.l) --> uh.l
045E49             0088*  ; destroys: de
045E49             0089*  sin168:
045E49             0090*  ; h contains the integer portion of our angle
045E49             0091*  ; we multiply it by three to get our lookup table index
045E49 2E 03       0092*      ld l,3
045E4B ED 6C       0093*      mlt hl ; gosh that is handy
045E4D 11 00 00 00 0094*      ld de,0 ; clear deu
045E51 54          0095*      ld d,h ; copy hl to de
045E52 5D          0096*      ld e,l ; de contains our index
045E53 21 5A 60 04 0097*      ld hl,sin_lut_168 ; grab the lut address
045E57 19          0098*      add hl,de ; bump hl by the index
045E58 ED 27       0099*      ld hl,(hl) ; don't try this on a z80!
045E5A C9          0100*      ret ; and out
045E5B             0101*  
045E5B             0102*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
045E5B             0103*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
045E5B             0104*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
045E5B             0105*  ;         also populates scratch locations dx168 and dy168
045E5B             0106*  ; destroys: a,hl,bc,de
045E5B             0107*  dxy168:
045E5B             0108*  ; compute dx = x1-x0
045E5B AF          0109*      xor a ; clear carry
045E5C DD E5       0110*      push ix ; move ix to hl via the stack
045E5E E1          0111*      pop hl ; hl = x1
045E5F ED 42       0112*      sbc hl,bc ; hl = dx
045E61 22 B6 5E 04 0113*      ld (dx168),hl ; dx to scratch
045E65             0114*  ; compute dy = y1-y0
045E65 AF          0115*      xor a ; clear carry
045E66 FD E5       0116*      push iy ; move iy to hl via the stack
045E68 E1          0117*      pop hl ; hl = y1
045E69 ED 52       0118*      sbc hl,de ; hl = dy
045E6B 22 BC 5E 04 0119*      ld (dy168),hl ; dy to scratch
045E6F             0120*  ; populate output registers and return
045E6F EB          0121*      ex de,hl        ; ud.e = dy
045E70 ED 4B B6 5E 0122*      ld bc,(dx168)   ; ub.c = dx
       04          
045E75 C9          0123*      ret
045E76             0124*  
045E76             0125*  ; compute the euclidian distance between two cartesian coordinates
045E76             0126*  ; using the formula d = sqrt(dx^2+dy^2
045E76             0127*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
045E76             0128*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
045E76             0129*  ; output; uh.l is the 16.8 fixed format distance
045E76             0130*  ;       dx168/y are the 16.8 fixed format dx and dy
045E76             0131*  ; destroys: a,hl,bc,de
045E76             0132*  distance168:
045E76             0133*  ; compute dx = x1-x0
045E76 AF          0134*      xor a ; clear carry
045E77 DD E5       0135*      push ix ; move ix to hl via the stack
045E79 E1          0136*      pop hl ; hl = x1
045E7A ED 42       0137*      sbc hl,bc ; hl = dx
045E7C 22 B6 5E 04 0138*      ld (dx168),hl ; dx to scratch
045E80             0139*  ; ; test dx for overflow
045E80             0140*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
045E80             0141*  ; 	ex de,hl
045E80             0142*  ; 	sbc hl,de ; test for overflow
045E80             0143*  ; 	push af ; carry indicates overflow
045E80             0144*  ; compute dy = y1-y0
045E80 AF          0145*      xor a ; clear carry
045E81 FD E5       0146*      push iy ; move iy to hl via the stack
045E83 E1          0147*      pop hl ; hl = y1
045E84 ED 52       0148*      sbc hl,de ; hl = dy
045E86 22 BC 5E 04 0149*      ld (dy168),hl ; dy to scratch
045E8A             0150*  ; ; test dy for overflow
045E8A             0151*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
045E8A             0152*  ; 	ex de,hl
045E8A             0153*  ; 	sbc hl,de ; test for overflow
045E8A             0154*  ; 	push af ; carry indicates overflow
045E8A             0155*  ; compute dy^2
045E8A 2A BC 5E 04 0156*  	ld hl,(dy168)
045E8E CD 3E 5C 04 0157*      call abs_hlu  ; make dy positive so we can use unsigned multiply
045E92             0158*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
045E92 E5          0159*      push hl ; load hl/2 to bc via the stack
045E93 C1          0160*      pop bc ; bc = dy/2
045E94 EB          0161*      ex de,hl ; de = dy/2
045E95 CD 8E 5D 04 0162*      call umul168 ; uh.l = dy^2/2
045E99 E5          0163*      push hl ; dy^2/2 to the stack
045E9A             0164*  ; compute dx^2
045E9A 2A B6 5E 04 0165*      ld hl,(dx168) ; get back dx
045E9E CD 3E 5C 04 0166*      call abs_hlu  ; make dx positive so we can use unsigned multiply
045EA2             0167*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
045EA2 E5          0168*      push hl ; load hl/2 to bc via the stack
045EA3 C1          0169*      pop bc ; bc = dx/2
045EA4 EB          0170*      ex de,hl ; de = dx/2
045EA5 CD 8E 5D 04 0171*      call umul168 ; uh.l = dx^2/2
045EA9             0172*  ; commpute dy^2+dx^2
045EA9 D1          0173*      pop de ; get back dx^2/2
045EAA 19          0174*      add hl,de ; hl = dx^2/2+dy^2/2
045EAB             0175*  ; compute sqrt(dx^2/2+dy^2/2)
045EAB CD 6F 5F 04 0176*      call sqrt168 ; uh.l = distance/2
045EAF             0177*      ; add hl,hl ; hl = distance
045EAF             0178*  ; ; check for overflow
045EAF             0179*  ; 	pop af ; get back the overflow flags
045EAF             0180*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
045EAF             0181*  ; 	ld b,a ; save the overflow flag
045EAF             0182*  ; 	pop af ; get back the overflow flags
045EAF             0183*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
045EAF             0184*  ; 	add a,b ; if a != 0 then we had overflow
045EAF             0185*  ;     ret z ; no overflow we're done
045EAF             0186*  ; @overflow:
045EAF             0187*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
045EAF C9          0188*  	ret
045EB0             0189*  @scratch: ds 6
045EB6             0190*  dx168: ds 6
045EBC             0191*  dy168: ds 6
045EC2             0192*  
045EC2             0193*  ; atan2(ub.c,ud.e) --> uh.l
045EC2             0194*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
045EC2             0195*  ;   whether inputs are integers or fractional doesn't matter
045EC2             0196*  ;   so long as the sign bit of the upper byte is correct
045EC2             0197*  ; output: uh.l is the 16.8 fixed angle in degrees 256
045EC2             0198*  ; angles are COMPASS HEADINGS based on
045EC2             0199*  ; screen coordinate conventions,where the y axis is flipped
045EC2             0200*  ; #E0 315      0       45 #20
045EC2             0201*  ;        -x,-y | +x,-y
045EC2             0202*  ; #C0 270------+------ 90 #40
045EC2             0203*  ;        -x,+y | +x,+y
045EC2             0204*  ; #A0 225   180 #80   135 #60
045EC2             0205*  atan2_168game:
045EC2             0206*  ; get signs and make everything positive
045EC2             0207*  ; get abs(x) and store its original sign
045EC2 C5          0208*      push bc
045EC3 E1          0209*      pop hl
045EC4 CD 3E 5C 04 0210*      call abs_hlu ; if x was negative this also sets the sign flag
045EC8 E5          0211*      push hl ; store abs(x)
045EC9 C1          0212*      pop bc ; bc = abs(x)
045ECA F5          0213*      push af ; store sign of x
045ECB             0214*  ; get abs(y) and store its original sign
045ECB EB          0215*      ex de,hl ; hl = y
045ECC CD 3E 5C 04 0216*      call abs_hlu ; if y was negative this also sets the sign flag
045ED0 EB          0217*      ex de,hl ; de = abs(y)
045ED1 F5          0218*      push af ; store sign of y
045ED2             0219*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
045ED2             0220*  ; this ensures that our lookup value is between 0 and 1 inclusive
045ED2 AF          0221*      xor a ; clear the carry flag
045ED3 D5          0222*      push de
045ED4 E1          0223*      pop hl
045ED5 ED 42       0224*      sbc hl,bc
045ED7 F5          0225*      push af ; save sign of de - bc
045ED8 F2 E1 5E 04 0226*      jp p,@1 ; bc <= de, so we skip ahead
045EDC             0227*  ; otherwise we swap bc and de
045EDC C5          0228*      push bc
045EDD E1          0229*      pop hl
045EDE EB          0230*      ex de,hl
045EDF E5          0231*      push hl
045EE0 C1          0232*      pop bc
045EE1             0233*  @1:
045EE1             0234*  ; now we're ready to snag our preliminary result
045EE1 CD 4F 5F 04 0235*      call atan_168game ; uh.l comes back with prelim result
045EE5             0236*  ; now we adjust uh.l based on sign of de - bc
045EE5 F1          0237*      pop af
045EE6 F2 F2 5E 04 0238*      jp p,@2 ; bc <= de,so we skip ahead
045EEA EB          0239*      ex de,hl
045EEB 21 00 40 00 0240*      ld hl,0x004000 ; 90 degrees
045EEF AF          0241*      xor a ; clear the carry flag
045EF0 ED 52       0242*      sbc hl,de ; subtract result from 90 degrees
045EF2             0243*      ; ld de,0 ; prep to clear hlu
045EF2             0244*      ; ld d,h
045EF2             0245*      ; ld e,l
045EF2             0246*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
045EF2             0247*      ; fall through
045EF2             0248*  @2:
045EF2             0249*  ; now the fun part of adjusting the result
045EF2             0250*  ; based on which quadrant (x,y) is in
045EF2             0251*  ; #E0 315      0       45 #20
045EF2             0252*  ;        -x,-y | +x,-y
045EF2             0253*  ; #C0 270------+------ 90 #40
045EF2             0254*  ;        -x,+y | +x,+y
045EF2             0255*  ; #A0 225   180 #80   135 #60
045EF2 F1          0256*      pop af ; sign of y
045EF3 CA 30 5F 04 0257*      jp z,@y_zero
045EF7 F2 10 5F 04 0258*      jp p,@y_pos
045EFB             0259*  ; y neg,check x
045EFB F1          0260*      pop af ; sign of x
045EFC CA 0A 5F 04 0261*      jp z,@y_neg_x_zero
045F00 F2 0F 5F 04 0262*      jp p,@y_neg_x_pos
045F04             0263*  ; y neg,x neg
045F04             0264*  ; angle is 270-360
045F04             0265*  ; negating the intermediate does the trick
045F04 CD 4E 5C 04 0266*      call neg_hlu
045F08 18 31       0267*      jr @zero_hlu
045F0A             0268*  
045F0A             0269*  @y_neg_x_zero:
045F0A             0270*  ; y neg,x zero
045F0A             0271*  ; angle is 0
045F0A 21 00 00 00 0272*      ld hl,0
045F0E C9          0273*      ret
045F0F             0274*  @y_neg_x_pos:
045F0F             0275*  ; y neg,x pos
045F0F             0276*  ; angle is 0 to 90
045F0F             0277*  ; so we're good
045F0F C9          0278*      ret
045F10             0279*  
045F10             0280*  @y_pos:
045F10 F1          0281*      pop af ; sign of x
045F11 CA 20 5F 04 0282*      jp z,@y_pos_x_zero
045F15 F2 25 5F 04 0283*      jp p,@y_pos_x_pos
045F19             0284*  ; y pos,x neg
045F19             0285*  ; angle is 180-270
045F19             0286*  ; so we add 180 to intermediate
045F19 11 00 80 00 0287*      ld de,0x008000
045F1D 19          0288*      add hl,de
045F1E 18 1B       0289*      jr @zero_hlu
045F20             0290*  @y_pos_x_zero:
045F20             0291*  ; y pos,x zero
045F20             0292*  ; angle is 180
045F20 21 00 80 00 0293*      ld hl,0x008000
045F24 C9          0294*      ret
045F25             0295*  @y_pos_x_pos:
045F25             0296*  ; y pos,x pos
045F25             0297*  ; angle is 90-180
045F25             0298*  ; neg the intermediate and add 180 degrees
045F25 CD 4E 5C 04 0299*      call neg_hlu
045F29 11 00 80 00 0300*      ld de,0x008000
045F2D 19          0301*      add hl,de
045F2E 18 0B       0302*      jr @zero_hlu
045F30             0303*  
045F30             0304*  @y_zero:
045F30 F1          0305*      pop af ; sign of x
045F31 FA 36 5F 04 0306*      jp m,@y_zero_x_neg
045F35             0307*  ; y zero,x pos
045F35             0308*  ; angle is 90,nothing to do
045F35 C9          0309*      ret
045F36             0310*  @y_zero_x_neg:
045F36             0311*  ; y zero ,x neg
045F36             0312*  ; angle is 270
045F36 21 00 C0 00 0313*      ld hl,0x00C000
045F3A C9          0314*      ret
045F3B             0315*  @zero_hlu:
045F3B AF          0316*      xor a
045F3C 22 49 5F 04 0317*      ld (@scratch),hl
045F40 32 4B 5F 04 0318*      ld (@scratch+2),a
045F44 2A 49 5F 04 0319*      ld hl,(@scratch)
045F48 C9          0320*      ret
045F49             0321*  @scratch: ds 6
045F4F             0322*  
045F4F             0323*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
045F4F             0324*  ; output: uh.l is the 16.8 fixed format angle
045F4F             0325*  ; destroys: a,hl,bc,de
045F4F             0326*  ; the following note was written by github copilot:
045F4F             0327*  ; note: this routine is a bit of a hack
045F4F             0328*  ;      but it works
045F4F             0329*  ;      and it's fast
045F4F             0330*  ;      and it's small
045F4F             0331*  ;      and it's accurate
045F4F             0332*  ;      and it's easy to understand
045F4F             0333*  ;      and it's easy to modify
045F4F             0334*  ;      and it's easy to use
045F4F             0335*  ;      and it's easy to remember
045F4F             0336*  ;      and it's easy to love
045F4F             0337*  ;      and it's easy to hate
045F4F             0338*  ;      and it's easy to ignore
045F4F             0339*  ;      and it's easy to forget
045F4F             0340*  ;      and it's easy to remember
045F4F             0341*  ;      and it's easy to forget
045F4F             0342*  ;      and it's easy to remember
045F4F             0343*  ;      (ok the bot is stuck in a loop)
045F4F             0344*  ; REAL NOTE: only works for angles from 0 to 45 degrees
045F4F             0345*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
045F4F             0346*  atan_168game:
045F4F             0347*  ; because we use compass headings instead of geometric angles
045F4F             0348*  ; we compute dx/dy which is 1/tan(theta) in the maths world
045F4F             0349*  ; we can do faster unsigned division here because we know dx and dy are positive
045F4F CD D5 5B 04 0350*  	call udiv168 ; uh.l = dx/dy
045F53             0351*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
045F53             0352*  ; ; test uh.l for 0
045F53             0353*  ;     add hl,de
045F53             0354*  ;     or a
045F53             0355*  ;     sbc hl,de
045F53             0356*  ;     jr z,@is_zero
045F53             0357*  ; ; test uh.l for 1
045F53             0358*  ;     xor a ; clear carry
045F53             0359*  ;     ex de,hl
045F53             0360*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
045F53             0361*  ;     sbc hl,de
045F53             0362*  ;     jr z,@is_45
045F53             0363*  ; ; END TODO
045F53             0364*  
045F53             0365*  ; no special cases so we move on
045F53             0366*  ; l contains the fractional portion of tan(uh.l)
045F53             0367*  ; we multiply it by three to get our lookup table index
045F53 26 03       0368*      ld h,3
045F55 ED 6C       0369*      mlt hl ; gosh that is handy
045F57 11 00 00 00 0370*      ld de,0 ; clear deu
045F5B 54          0371*      ld d,h ; copy hl to de
045F5C 5D          0372*      ld e,l ; de contains our index
045F5D 21 5A 63 04 0373*      ld hl,atan_lut_168 ; grab the lut address
045F61 19          0374*      add hl,de ; bump hl by the index
045F62 ED 27       0375*      ld hl,(hl) ; don't try this on a z80!
045F64 C9          0376*      ret ; and out
045F65             0377*  @is_45:
045F65 21 00 20 00 0378*      ld hl,0x002000 ; 45 degrees decimal
045F69 C9          0379*      ret
045F6A             0380*  ; for the case tan(0)
045F6A             0381*  @is_zero:
045F6A 21 00 00 00 0382*      ld hl,0x000000
045F6E C9          0383*      ret
045F6F             0384*  
045F6F             0385*  ; Expects  ADL mode
045F6F             0386*  ; Inputs:  UH.L
045F6F             0387*  ; Outputs: UH.L is the 16.8 square root
045F6F             0388*  ;          UD.E is the difference inputHL-DE^2
045F6F             0389*  ;          c flag reset
045F6F             0390*  sqrt168:
045F6F CD 79 5F 04 0391*      call sqrt24
045F73 EB          0392*      ex de,hl
045F74 29          0393*      add hl,hl
045F75 29          0394*      add hl,hl
045F76 29          0395*      add hl,hl
045F77 29          0396*      add hl,hl
045F78 C9          0397*      ret
045F79             0398*  
045F79             0399*  ; Expects  ADL mode
045F79             0400*  ; Inputs:  HL
045F79             0401*  ; Outputs: DE is the integer square root
045F79             0402*  ;          HL is the difference inputHL-DE^2
045F79             0403*  ;          c flag reset
045F79             0404*  sqrt24:
045F79 AF          0405*      xor a
045F7A 45          0406*      ld b,l
045F7B C5          0407*      push bc
045F7C 47          0408*      ld b,a
045F7D 57          0409*      ld d,a
045F7E 4F          0410*      ld c,a
045F7F 6F          0411*      ld l,a
045F80 5F          0412*      ld e,a
045F81             0413*  
045F81             0414*      ;Iteration 1
045F81 29          0415*      add hl,hl
045F82 CB 11       0416*      rl c
045F84 29          0417*      add hl,hl
045F85 CB 11       0418*      rl c
045F87 91          0419*      sub c
045F88 30 04       0420*      jr nc,$+6
045F8A 1C          0421*      inc e
045F8B 1C          0422*      inc e
045F8C 2F          0423*      cpl
045F8D 4F          0424*      ld c,a
045F8E             0425*  
045F8E             0426*      ;Iteration 2
045F8E 29          0427*      add hl,hl
045F8F CB 11       0428*      rl c
045F91 29          0429*      add hl,hl
045F92 CB 11       0430*      rl c
045F94 CB 13       0431*      rl e
045F96 7B          0432*      ld a,e
045F97 91          0433*      sub c
045F98 30 04       0434*      jr nc,$+6
045F9A 1C          0435*      inc e
045F9B 1C          0436*      inc e
045F9C 2F          0437*      cpl
045F9D 4F          0438*      ld c,a
045F9E             0439*  
045F9E             0440*      ;Iteration 3
045F9E 29          0441*      add hl,hl
045F9F CB 11       0442*      rl c
045FA1 29          0443*      add hl,hl
045FA2 CB 11       0444*      rl c
045FA4 CB 13       0445*      rl e
045FA6 7B          0446*      ld a,e
045FA7 91          0447*      sub c
045FA8 30 04       0448*      jr nc,$+6
045FAA 1C          0449*      inc e
045FAB 1C          0450*      inc e
045FAC 2F          0451*      cpl
045FAD 4F          0452*      ld c,a
045FAE             0453*  
045FAE             0454*      ;Iteration 4
045FAE 29          0455*      add hl,hl
045FAF CB 11       0456*      rl c
045FB1 29          0457*      add hl,hl
045FB2 CB 11       0458*      rl c
045FB4 CB 13       0459*      rl e
045FB6 7B          0460*      ld a,e
045FB7 91          0461*      sub c
045FB8 30 04       0462*      jr nc,$+6
045FBA 1C          0463*      inc e
045FBB 1C          0464*      inc e
045FBC 2F          0465*      cpl
045FBD 4F          0466*      ld c,a
045FBE             0467*  
045FBE             0468*      ;Iteration 5
045FBE 29          0469*      add hl,hl
045FBF CB 11       0470*      rl c
045FC1 29          0471*      add hl,hl
045FC2 CB 11       0472*      rl c
045FC4 CB 13       0473*      rl e
045FC6 7B          0474*      ld a,e
045FC7 91          0475*      sub c
045FC8 30 04       0476*      jr nc,$+6
045FCA 1C          0477*      inc e
045FCB 1C          0478*      inc e
045FCC 2F          0479*      cpl
045FCD 4F          0480*      ld c,a
045FCE             0481*  
045FCE             0482*      ;Iteration 6
045FCE 29          0483*      add hl,hl
045FCF CB 11       0484*      rl c
045FD1 29          0485*      add hl,hl
045FD2 CB 11       0486*      rl c
045FD4 CB 13       0487*      rl e
045FD6 7B          0488*      ld a,e
045FD7 91          0489*      sub c
045FD8 30 04       0490*      jr nc,$+6
045FDA 1C          0491*      inc e
045FDB 1C          0492*      inc e
045FDC 2F          0493*      cpl
045FDD 4F          0494*      ld c,a
045FDE             0495*  
045FDE             0496*      ;Iteration 7
045FDE 29          0497*      add hl,hl
045FDF CB 11       0498*      rl c
045FE1 29          0499*      add hl,hl
045FE2 CB 11       0500*      rl c
045FE4 CB 10       0501*      rl b
045FE6 EB          0502*      ex de,hl
045FE7 29          0503*      add hl,hl
045FE8 E5          0504*      push hl
045FE9 ED 42       0505*      sbc hl,bc
045FEB 30 06       0506*      jr nc,$+8
045FED 7C          0507*      ld a,h
045FEE 2F          0508*      cpl
045FEF 47          0509*      ld b,a
045FF0 7D          0510*      ld a,l
045FF1 2F          0511*      cpl
045FF2 4F          0512*      ld c,a
045FF3 E1          0513*      pop hl
045FF4 30 02       0514*      jr nc,$+4
045FF6 23          0515*      inc hl
045FF7 23          0516*      inc hl
045FF8 EB          0517*      ex de,hl
045FF9             0518*  
045FF9             0519*      ;Iteration 8
045FF9 29          0520*      add hl,hl
045FFA 69          0521*      ld l,c
045FFB 60          0522*      ld h,b
045FFC ED 6A       0523*      adc hl,hl
045FFE ED 6A       0524*      adc hl,hl
046000 EB          0525*      ex de,hl
046001 29          0526*      add hl,hl
046002 ED 52       0527*      sbc hl,de
046004 19          0528*      add hl,de
046005 EB          0529*      ex de,hl
046006 30 04       0530*      jr nc,$+6
046008 ED 52       0531*      sbc hl,de
04600A 13          0532*      inc de
04600B 13          0533*      inc de
04600C             0534*  
04600C             0535*      ;Iteration 9
04600C F1          0536*      pop af
04600D 17          0537*      rla
04600E ED 6A       0538*      adc hl,hl
046010 17          0539*      rla
046011 ED 6A       0540*      adc hl,hl
046013 EB          0541*      ex de,hl
046014 29          0542*      add hl,hl
046015 ED 52       0543*      sbc hl,de
046017 19          0544*      add hl,de
046018 EB          0545*      ex de,hl
046019 30 04       0546*      jr nc,$+6
04601B ED 52       0547*      sbc hl,de
04601D 13          0548*      inc de
04601E 13          0549*      inc de
04601F             0550*  
04601F             0551*      ;Iteration 10
04601F 17          0552*      rla
046020 ED 6A       0553*      adc hl,hl
046022 17          0554*      rla
046023 ED 6A       0555*      adc hl,hl
046025 EB          0556*      ex de,hl
046026 29          0557*      add hl,hl
046027 ED 52       0558*      sbc hl,de
046029 19          0559*      add hl,de
04602A EB          0560*      ex de,hl
04602B 30 04       0561*      jr nc,$+6
04602D ED 52       0562*      sbc hl,de
04602F 13          0563*      inc de
046030 13          0564*      inc de
046031             0565*  
046031             0566*      ;Iteration 11
046031 17          0567*      rla
046032 ED 6A       0568*      adc hl,hl
046034 17          0569*      rla
046035 ED 6A       0570*      adc hl,hl
046037 EB          0571*      ex de,hl
046038 29          0572*      add hl,hl
046039 ED 52       0573*      sbc hl,de
04603B 19          0574*      add hl,de
04603C EB          0575*      ex de,hl
04603D 30 04       0576*      jr nc,$+6
04603F ED 52       0577*      sbc hl,de
046041 13          0578*      inc de
046042 13          0579*      inc de
046043             0580*  
046043             0581*      ;Iteration 11
046043 17          0582*      rla
046044 ED 6A       0583*      adc hl,hl
046046 17          0584*      rla
046047 ED 6A       0585*      adc hl,hl
046049 EB          0586*      ex de,hl
04604A 29          0587*      add hl,hl
04604B ED 52       0588*      sbc hl,de
04604D 19          0589*      add hl,de
04604E EB          0590*      ex de,hl
04604F 30 04       0591*      jr nc,$+6
046051 ED 52       0592*      sbc hl,de
046053 13          0593*      inc de
046054 13          0594*      inc de
046055             0595*  
046055 CB 1A       0596*      rr d
046057 CB 1B       0597*      rr e
046059 C9          0598*      ret
04605A             0599*  
04605A             0600*  sin_lut_168:
04605A 00 00 00    0601*  	dl 0x000000 ; 0.000 00, 0.000
04605D 06 00 00    0602*  	dl 0x000006 ; 1.406 01, 0.025
046060 0C 00 00    0603*  	dl 0x00000C ; 2.813 02, 0.049
046063 12 00 00    0604*  	dl 0x000012 ; 4.219 03, 0.074
046066 19 00 00    0605*  	dl 0x000019 ; 5.625 04, 0.098
046069 1F 00 00    0606*  	dl 0x00001F ; 7.031 05, 0.122
04606C 25 00 00    0607*  	dl 0x000025 ; 8.438 06, 0.147
04606F 2B 00 00    0608*  	dl 0x00002B ; 9.844 07, 0.171
046072 31 00 00    0609*  	dl 0x000031 ; 11.250 08, 0.195
046075 38 00 00    0610*  	dl 0x000038 ; 12.656 09, 0.219
046078 3E 00 00    0611*  	dl 0x00003E ; 14.063 0A, 0.243
04607B 44 00 00    0612*  	dl 0x000044 ; 15.469 0B, 0.267
04607E 4A 00 00    0613*  	dl 0x00004A ; 16.875 0C, 0.290
046081 50 00 00    0614*  	dl 0x000050 ; 18.281 0D, 0.314
046084 56 00 00    0615*  	dl 0x000056 ; 19.688 0E, 0.337
046087 5C 00 00    0616*  	dl 0x00005C ; 21.094 0F, 0.360
04608A 61 00 00    0617*  	dl 0x000061 ; 22.500 10, 0.383
04608D 67 00 00    0618*  	dl 0x000067 ; 23.906 11, 0.405
046090 6D 00 00    0619*  	dl 0x00006D ; 25.313 12, 0.428
046093 73 00 00    0620*  	dl 0x000073 ; 26.719 13, 0.450
046096 78 00 00    0621*  	dl 0x000078 ; 28.125 14, 0.471
046099 7E 00 00    0622*  	dl 0x00007E ; 29.531 15, 0.493
04609C 83 00 00    0623*  	dl 0x000083 ; 30.938 16, 0.514
04609F 88 00 00    0624*  	dl 0x000088 ; 32.344 17, 0.535
0460A2 8E 00 00    0625*  	dl 0x00008E ; 33.750 18, 0.556
0460A5 93 00 00    0626*  	dl 0x000093 ; 35.156 19, 0.576
0460A8 98 00 00    0627*  	dl 0x000098 ; 36.563 1A, 0.596
0460AB 9D 00 00    0628*  	dl 0x00009D ; 37.969 1B, 0.615
0460AE A2 00 00    0629*  	dl 0x0000A2 ; 39.375 1C, 0.634
0460B1 A7 00 00    0630*  	dl 0x0000A7 ; 40.781 1D, 0.653
0460B4 AB 00 00    0631*  	dl 0x0000AB ; 42.188 1E, 0.672
0460B7 B0 00 00    0632*  	dl 0x0000B0 ; 43.594 1F, 0.690
0460BA B5 00 00    0633*  	dl 0x0000B5 ; 45.000 20, 0.707
0460BD B9 00 00    0634*  	dl 0x0000B9 ; 46.406 21, 0.724
0460C0 BD 00 00    0635*  	dl 0x0000BD ; 47.813 22, 0.741
0460C3 C1 00 00    0636*  	dl 0x0000C1 ; 49.219 23, 0.757
0460C6 C5 00 00    0637*  	dl 0x0000C5 ; 50.625 24, 0.773
0460C9 C9 00 00    0638*  	dl 0x0000C9 ; 52.031 25, 0.788
0460CC CD 00 00    0639*  	dl 0x0000CD ; 53.438 26, 0.803
0460CF D1 00 00    0640*  	dl 0x0000D1 ; 54.844 27, 0.818
0460D2 D4 00 00    0641*  	dl 0x0000D4 ; 56.250 28, 0.831
0460D5 D8 00 00    0642*  	dl 0x0000D8 ; 57.656 29, 0.845
0460D8 DB 00 00    0643*  	dl 0x0000DB ; 59.063 2A, 0.858
0460DB DE 00 00    0644*  	dl 0x0000DE ; 60.469 2B, 0.870
0460DE E1 00 00    0645*  	dl 0x0000E1 ; 61.875 2C, 0.882
0460E1 E4 00 00    0646*  	dl 0x0000E4 ; 63.281 2D, 0.893
0460E4 E7 00 00    0647*  	dl 0x0000E7 ; 64.688 2E, 0.904
0460E7 EA 00 00    0648*  	dl 0x0000EA ; 66.094 2F, 0.914
0460EA EC 00 00    0649*  	dl 0x0000EC ; 67.500 30, 0.924
0460ED EE 00 00    0650*  	dl 0x0000EE ; 68.906 31, 0.933
0460F0 F1 00 00    0651*  	dl 0x0000F1 ; 70.313 32, 0.942
0460F3 F3 00 00    0652*  	dl 0x0000F3 ; 71.719 33, 0.950
0460F6 F4 00 00    0653*  	dl 0x0000F4 ; 73.125 34, 0.957
0460F9 F6 00 00    0654*  	dl 0x0000F6 ; 74.531 35, 0.964
0460FC F8 00 00    0655*  	dl 0x0000F8 ; 75.938 36, 0.970
0460FF F9 00 00    0656*  	dl 0x0000F9 ; 77.344 37, 0.976
046102 FB 00 00    0657*  	dl 0x0000FB ; 78.750 38, 0.981
046105 FC 00 00    0658*  	dl 0x0000FC ; 80.156 39, 0.985
046108 FD 00 00    0659*  	dl 0x0000FD ; 81.563 3A, 0.989
04610B FE 00 00    0660*  	dl 0x0000FE ; 82.969 3B, 0.992
04610E FE 00 00    0661*  	dl 0x0000FE ; 84.375 3C, 0.995
046111 FF 00 00    0662*  	dl 0x0000FF ; 85.781 3D, 0.997
046114 FF 00 00    0663*  	dl 0x0000FF ; 87.188 3E, 0.999
046117 FF 00 00    0664*  	dl 0x0000FF ; 88.594 3F, 1.000
04611A 00 01 00    0665*  	dl 0x000100 ; 90.000 40, 1.000
04611D FF 00 00    0666*  	dl 0x0000FF ; 91.406 41, 1.000
046120 FF 00 00    0667*  	dl 0x0000FF ; 92.813 42, 0.999
046123 FF 00 00    0668*  	dl 0x0000FF ; 94.219 43, 0.997
046126 FE 00 00    0669*  	dl 0x0000FE ; 95.625 44, 0.995
046129 FE 00 00    0670*  	dl 0x0000FE ; 97.031 45, 0.992
04612C FD 00 00    0671*  	dl 0x0000FD ; 98.438 46, 0.989
04612F FC 00 00    0672*  	dl 0x0000FC ; 99.844 47, 0.985
046132 FB 00 00    0673*  	dl 0x0000FB ; 101.250 48, 0.981
046135 F9 00 00    0674*  	dl 0x0000F9 ; 102.656 49, 0.976
046138 F8 00 00    0675*  	dl 0x0000F8 ; 104.063 4A, 0.970
04613B F6 00 00    0676*  	dl 0x0000F6 ; 105.469 4B, 0.964
04613E F4 00 00    0677*  	dl 0x0000F4 ; 106.875 4C, 0.957
046141 F3 00 00    0678*  	dl 0x0000F3 ; 108.281 4D, 0.950
046144 F1 00 00    0679*  	dl 0x0000F1 ; 109.688 4E, 0.942
046147 EE 00 00    0680*  	dl 0x0000EE ; 111.094 4F, 0.933
04614A EC 00 00    0681*  	dl 0x0000EC ; 112.500 50, 0.924
04614D EA 00 00    0682*  	dl 0x0000EA ; 113.906 51, 0.914
046150 E7 00 00    0683*  	dl 0x0000E7 ; 115.313 52, 0.904
046153 E4 00 00    0684*  	dl 0x0000E4 ; 116.719 53, 0.893
046156 E1 00 00    0685*  	dl 0x0000E1 ; 118.125 54, 0.882
046159 DE 00 00    0686*  	dl 0x0000DE ; 119.531 55, 0.870
04615C DB 00 00    0687*  	dl 0x0000DB ; 120.938 56, 0.858
04615F D8 00 00    0688*  	dl 0x0000D8 ; 122.344 57, 0.845
046162 D4 00 00    0689*  	dl 0x0000D4 ; 123.750 58, 0.831
046165 D1 00 00    0690*  	dl 0x0000D1 ; 125.156 59, 0.818
046168 CD 00 00    0691*  	dl 0x0000CD ; 126.563 5A, 0.803
04616B C9 00 00    0692*  	dl 0x0000C9 ; 127.969 5B, 0.788
04616E C5 00 00    0693*  	dl 0x0000C5 ; 129.375 5C, 0.773
046171 C1 00 00    0694*  	dl 0x0000C1 ; 130.781 5D, 0.757
046174 BD 00 00    0695*  	dl 0x0000BD ; 132.188 5E, 0.741
046177 B9 00 00    0696*  	dl 0x0000B9 ; 133.594 5F, 0.724
04617A B5 00 00    0697*  	dl 0x0000B5 ; 135.000 60, 0.707
04617D B0 00 00    0698*  	dl 0x0000B0 ; 136.406 61, 0.690
046180 AB 00 00    0699*  	dl 0x0000AB ; 137.813 62, 0.672
046183 A7 00 00    0700*  	dl 0x0000A7 ; 139.219 63, 0.653
046186 A2 00 00    0701*  	dl 0x0000A2 ; 140.625 64, 0.634
046189 9D 00 00    0702*  	dl 0x00009D ; 142.031 65, 0.615
04618C 98 00 00    0703*  	dl 0x000098 ; 143.438 66, 0.596
04618F 93 00 00    0704*  	dl 0x000093 ; 144.844 67, 0.576
046192 8E 00 00    0705*  	dl 0x00008E ; 146.250 68, 0.556
046195 88 00 00    0706*  	dl 0x000088 ; 147.656 69, 0.535
046198 83 00 00    0707*  	dl 0x000083 ; 149.063 6A, 0.514
04619B 7E 00 00    0708*  	dl 0x00007E ; 150.469 6B, 0.493
04619E 78 00 00    0709*  	dl 0x000078 ; 151.875 6C, 0.471
0461A1 73 00 00    0710*  	dl 0x000073 ; 153.281 6D, 0.450
0461A4 6D 00 00    0711*  	dl 0x00006D ; 154.688 6E, 0.428
0461A7 67 00 00    0712*  	dl 0x000067 ; 156.094 6F, 0.405
0461AA 61 00 00    0713*  	dl 0x000061 ; 157.500 70, 0.383
0461AD 5C 00 00    0714*  	dl 0x00005C ; 158.906 71, 0.360
0461B0 56 00 00    0715*  	dl 0x000056 ; 160.313 72, 0.337
0461B3 50 00 00    0716*  	dl 0x000050 ; 161.719 73, 0.314
0461B6 4A 00 00    0717*  	dl 0x00004A ; 163.125 74, 0.290
0461B9 44 00 00    0718*  	dl 0x000044 ; 164.531 75, 0.267
0461BC 3E 00 00    0719*  	dl 0x00003E ; 165.938 76, 0.243
0461BF 38 00 00    0720*  	dl 0x000038 ; 167.344 77, 0.219
0461C2 31 00 00    0721*  	dl 0x000031 ; 168.750 78, 0.195
0461C5 2B 00 00    0722*  	dl 0x00002B ; 170.156 79, 0.171
0461C8 25 00 00    0723*  	dl 0x000025 ; 171.563 7A, 0.147
0461CB 1F 00 00    0724*  	dl 0x00001F ; 172.969 7B, 0.122
0461CE 19 00 00    0725*  	dl 0x000019 ; 174.375 7C, 0.098
0461D1 12 00 00    0726*  	dl 0x000012 ; 175.781 7D, 0.074
0461D4 0C 00 00    0727*  	dl 0x00000C ; 177.188 7E, 0.049
0461D7 06 00 00    0728*  	dl 0x000006 ; 178.594 7F, 0.025
0461DA 00 00 00    0729*  	dl 0x000000 ; 180.000 80, 0.000
0461DD FA FF FF    0730*  	dl 0xFFFFFA ; 181.406 81, -0.025
0461E0 F4 FF FF    0731*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0461E3 EE FF FF    0732*  	dl 0xFFFFEE ; 184.219 83, -0.074
0461E6 E7 FF FF    0733*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0461E9 E1 FF FF    0734*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0461EC DB FF FF    0735*  	dl 0xFFFFDB ; 188.438 86, -0.147
0461EF D5 FF FF    0736*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0461F2 CF FF FF    0737*  	dl 0xFFFFCF ; 191.250 88, -0.195
0461F5 C8 FF FF    0738*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0461F8 C2 FF FF    0739*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0461FB BC FF FF    0740*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0461FE B6 FF FF    0741*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
046201 B0 FF FF    0742*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
046204 AA FF FF    0743*  	dl 0xFFFFAA ; 199.688 8E, -0.337
046207 A4 FF FF    0744*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
04620A 9F FF FF    0745*  	dl 0xFFFF9F ; 202.500 90, -0.383
04620D 99 FF FF    0746*  	dl 0xFFFF99 ; 203.906 91, -0.405
046210 93 FF FF    0747*  	dl 0xFFFF93 ; 205.313 92, -0.428
046213 8D FF FF    0748*  	dl 0xFFFF8D ; 206.719 93, -0.450
046216 88 FF FF    0749*  	dl 0xFFFF88 ; 208.125 94, -0.471
046219 82 FF FF    0750*  	dl 0xFFFF82 ; 209.531 95, -0.493
04621C 7D FF FF    0751*  	dl 0xFFFF7D ; 210.938 96, -0.514
04621F 78 FF FF    0752*  	dl 0xFFFF78 ; 212.344 97, -0.535
046222 72 FF FF    0753*  	dl 0xFFFF72 ; 213.750 98, -0.556
046225 6D FF FF    0754*  	dl 0xFFFF6D ; 215.156 99, -0.576
046228 68 FF FF    0755*  	dl 0xFFFF68 ; 216.563 9A, -0.596
04622B 63 FF FF    0756*  	dl 0xFFFF63 ; 217.969 9B, -0.615
04622E 5E FF FF    0757*  	dl 0xFFFF5E ; 219.375 9C, -0.634
046231 59 FF FF    0758*  	dl 0xFFFF59 ; 220.781 9D, -0.653
046234 55 FF FF    0759*  	dl 0xFFFF55 ; 222.188 9E, -0.672
046237 50 FF FF    0760*  	dl 0xFFFF50 ; 223.594 9F, -0.690
04623A 4B FF FF    0761*  	dl 0xFFFF4B ; 225.000 A0, -0.707
04623D 47 FF FF    0762*  	dl 0xFFFF47 ; 226.406 A1, -0.724
046240 43 FF FF    0763*  	dl 0xFFFF43 ; 227.813 A2, -0.741
046243 3F FF FF    0764*  	dl 0xFFFF3F ; 229.219 A3, -0.757
046246 3B FF FF    0765*  	dl 0xFFFF3B ; 230.625 A4, -0.773
046249 37 FF FF    0766*  	dl 0xFFFF37 ; 232.031 A5, -0.788
04624C 33 FF FF    0767*  	dl 0xFFFF33 ; 233.438 A6, -0.803
04624F 2F FF FF    0768*  	dl 0xFFFF2F ; 234.844 A7, -0.818
046252 2C FF FF    0769*  	dl 0xFFFF2C ; 236.250 A8, -0.831
046255 28 FF FF    0770*  	dl 0xFFFF28 ; 237.656 A9, -0.845
046258 25 FF FF    0771*  	dl 0xFFFF25 ; 239.063 AA, -0.858
04625B 22 FF FF    0772*  	dl 0xFFFF22 ; 240.469 AB, -0.870
04625E 1F FF FF    0773*  	dl 0xFFFF1F ; 241.875 AC, -0.882
046261 1C FF FF    0774*  	dl 0xFFFF1C ; 243.281 AD, -0.893
046264 19 FF FF    0775*  	dl 0xFFFF19 ; 244.688 AE, -0.904
046267 16 FF FF    0776*  	dl 0xFFFF16 ; 246.094 AF, -0.914
04626A 14 FF FF    0777*  	dl 0xFFFF14 ; 247.500 B0, -0.924
04626D 12 FF FF    0778*  	dl 0xFFFF12 ; 248.906 B1, -0.933
046270 0F FF FF    0779*  	dl 0xFFFF0F ; 250.313 B2, -0.942
046273 0D FF FF    0780*  	dl 0xFFFF0D ; 251.719 B3, -0.950
046276 0C FF FF    0781*  	dl 0xFFFF0C ; 253.125 B4, -0.957
046279 0A FF FF    0782*  	dl 0xFFFF0A ; 254.531 B5, -0.964
04627C 08 FF FF    0783*  	dl 0xFFFF08 ; 255.938 B6, -0.970
04627F 07 FF FF    0784*  	dl 0xFFFF07 ; 257.344 B7, -0.976
046282 05 FF FF    0785*  	dl 0xFFFF05 ; 258.750 B8, -0.981
046285 04 FF FF    0786*  	dl 0xFFFF04 ; 260.156 B9, -0.985
046288 03 FF FF    0787*  	dl 0xFFFF03 ; 261.563 BA, -0.989
04628B 02 FF FF    0788*  	dl 0xFFFF02 ; 262.969 BB, -0.992
04628E 02 FF FF    0789*  	dl 0xFFFF02 ; 264.375 BC, -0.995
046291 01 FF FF    0790*  	dl 0xFFFF01 ; 265.781 BD, -0.997
046294 01 FF FF    0791*  	dl 0xFFFF01 ; 267.188 BE, -0.999
046297 01 FF FF    0792*  	dl 0xFFFF01 ; 268.594 BF, -1.000
04629A 00 FF FF    0793*  	dl 0xFFFF00 ; 270.000 C0, -1.000
04629D 01 FF FF    0794*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0462A0 01 FF FF    0795*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0462A3 01 FF FF    0796*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0462A6 02 FF FF    0797*  	dl 0xFFFF02 ; 275.625 C4, -0.995
0462A9 02 FF FF    0798*  	dl 0xFFFF02 ; 277.031 C5, -0.992
0462AC 03 FF FF    0799*  	dl 0xFFFF03 ; 278.438 C6, -0.989
0462AF 04 FF FF    0800*  	dl 0xFFFF04 ; 279.844 C7, -0.985
0462B2 05 FF FF    0801*  	dl 0xFFFF05 ; 281.250 C8, -0.981
0462B5 07 FF FF    0802*  	dl 0xFFFF07 ; 282.656 C9, -0.976
0462B8 08 FF FF    0803*  	dl 0xFFFF08 ; 284.063 CA, -0.970
0462BB 0A FF FF    0804*  	dl 0xFFFF0A ; 285.469 CB, -0.964
0462BE 0C FF FF    0805*  	dl 0xFFFF0C ; 286.875 CC, -0.957
0462C1 0D FF FF    0806*  	dl 0xFFFF0D ; 288.281 CD, -0.950
0462C4 0F FF FF    0807*  	dl 0xFFFF0F ; 289.688 CE, -0.942
0462C7 12 FF FF    0808*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0462CA 14 FF FF    0809*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0462CD 16 FF FF    0810*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0462D0 19 FF FF    0811*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0462D3 1C FF FF    0812*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0462D6 1F FF FF    0813*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0462D9 22 FF FF    0814*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0462DC 25 FF FF    0815*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0462DF 28 FF FF    0816*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0462E2 2C FF FF    0817*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0462E5 2F FF FF    0818*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0462E8 33 FF FF    0819*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0462EB 37 FF FF    0820*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0462EE 3B FF FF    0821*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0462F1 3F FF FF    0822*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0462F4 43 FF FF    0823*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0462F7 47 FF FF    0824*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0462FA 4B FF FF    0825*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0462FD 50 FF FF    0826*  	dl 0xFFFF50 ; 316.406 E1, -0.690
046300 55 FF FF    0827*  	dl 0xFFFF55 ; 317.813 E2, -0.672
046303 59 FF FF    0828*  	dl 0xFFFF59 ; 319.219 E3, -0.653
046306 5E FF FF    0829*  	dl 0xFFFF5E ; 320.625 E4, -0.634
046309 63 FF FF    0830*  	dl 0xFFFF63 ; 322.031 E5, -0.615
04630C 68 FF FF    0831*  	dl 0xFFFF68 ; 323.438 E6, -0.596
04630F 6D FF FF    0832*  	dl 0xFFFF6D ; 324.844 E7, -0.576
046312 72 FF FF    0833*  	dl 0xFFFF72 ; 326.250 E8, -0.556
046315 78 FF FF    0834*  	dl 0xFFFF78 ; 327.656 E9, -0.535
046318 7D FF FF    0835*  	dl 0xFFFF7D ; 329.063 EA, -0.514
04631B 82 FF FF    0836*  	dl 0xFFFF82 ; 330.469 EB, -0.493
04631E 88 FF FF    0837*  	dl 0xFFFF88 ; 331.875 EC, -0.471
046321 8D FF FF    0838*  	dl 0xFFFF8D ; 333.281 ED, -0.450
046324 93 FF FF    0839*  	dl 0xFFFF93 ; 334.688 EE, -0.428
046327 99 FF FF    0840*  	dl 0xFFFF99 ; 336.094 EF, -0.405
04632A 9F FF FF    0841*  	dl 0xFFFF9F ; 337.500 F0, -0.383
04632D A4 FF FF    0842*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
046330 AA FF FF    0843*  	dl 0xFFFFAA ; 340.313 F2, -0.337
046333 B0 FF FF    0844*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
046336 B6 FF FF    0845*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
046339 BC FF FF    0846*  	dl 0xFFFFBC ; 344.531 F5, -0.267
04633C C2 FF FF    0847*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
04633F C8 FF FF    0848*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
046342 CF FF FF    0849*  	dl 0xFFFFCF ; 348.750 F8, -0.195
046345 D5 FF FF    0850*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
046348 DB FF FF    0851*  	dl 0xFFFFDB ; 351.563 FA, -0.147
04634B E1 FF FF    0852*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
04634E E7 FF FF    0853*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
046351 EE FF FF    0854*  	dl 0xFFFFEE ; 355.781 FD, -0.074
046354 F4 FF FF    0855*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
046357 FA FF FF    0856*  	dl 0xFFFFFA ; 358.594 FF, -0.025
04635A             0857*  
04635A             0858*  atan_lut_168:
04635A 00 00 00    0859*  	dl 0x000000 ; 000000, 0.000
04635D 28 00 00    0860*  	dl 0x000028 ; 000001, 0.224
046360 51 00 00    0861*  	dl 0x000051 ; 000002, 0.448
046363 7A 00 00    0862*  	dl 0x00007A ; 000003, 0.671
046366 A2 00 00    0863*  	dl 0x0000A2 ; 000004, 0.895
046369 CB 00 00    0864*  	dl 0x0000CB ; 000005, 1.119
04636C F4 00 00    0865*  	dl 0x0000F4 ; 000006, 1.343
04636F 1D 01 00    0866*  	dl 0x00011D ; 000007, 1.566
046372 45 01 00    0867*  	dl 0x000145 ; 000008, 1.790
046375 6E 01 00    0868*  	dl 0x00016E ; 000009, 2.013
046378 97 01 00    0869*  	dl 0x000197 ; 00000A, 2.237
04637B BF 01 00    0870*  	dl 0x0001BF ; 00000B, 2.460
04637E E8 01 00    0871*  	dl 0x0001E8 ; 00000C, 2.684
046381 11 02 00    0872*  	dl 0x000211 ; 00000D, 2.907
046384 39 02 00    0873*  	dl 0x000239 ; 00000E, 3.130
046387 62 02 00    0874*  	dl 0x000262 ; 00000F, 3.353
04638A 8B 02 00    0875*  	dl 0x00028B ; 000010, 3.576
04638D B3 02 00    0876*  	dl 0x0002B3 ; 000011, 3.799
046390 DC 02 00    0877*  	dl 0x0002DC ; 000012, 4.022
046393 04 03 00    0878*  	dl 0x000304 ; 000013, 4.245
046396 2D 03 00    0879*  	dl 0x00032D ; 000014, 4.467
046399 55 03 00    0880*  	dl 0x000355 ; 000015, 4.690
04639C 7E 03 00    0881*  	dl 0x00037E ; 000016, 4.912
04639F A6 03 00    0882*  	dl 0x0003A6 ; 000017, 5.134
0463A2 CE 03 00    0883*  	dl 0x0003CE ; 000018, 5.356
0463A5 F7 03 00    0884*  	dl 0x0003F7 ; 000019, 5.578
0463A8 1F 04 00    0885*  	dl 0x00041F ; 00001A, 5.799
0463AB 48 04 00    0886*  	dl 0x000448 ; 00001B, 6.021
0463AE 70 04 00    0887*  	dl 0x000470 ; 00001C, 6.242
0463B1 98 04 00    0888*  	dl 0x000498 ; 00001D, 6.463
0463B4 C0 04 00    0889*  	dl 0x0004C0 ; 00001E, 6.684
0463B7 E8 04 00    0890*  	dl 0x0004E8 ; 00001F, 6.905
0463BA 11 05 00    0891*  	dl 0x000511 ; 000020, 7.125
0463BD 39 05 00    0892*  	dl 0x000539 ; 000021, 7.345
0463C0 61 05 00    0893*  	dl 0x000561 ; 000022, 7.565
0463C3 89 05 00    0894*  	dl 0x000589 ; 000023, 7.785
0463C6 B1 05 00    0895*  	dl 0x0005B1 ; 000024, 8.005
0463C9 D9 05 00    0896*  	dl 0x0005D9 ; 000025, 8.224
0463CC 01 06 00    0897*  	dl 0x000601 ; 000026, 8.443
0463CF 28 06 00    0898*  	dl 0x000628 ; 000027, 8.662
0463D2 50 06 00    0899*  	dl 0x000650 ; 000028, 8.881
0463D5 78 06 00    0900*  	dl 0x000678 ; 000029, 9.099
0463D8 A0 06 00    0901*  	dl 0x0006A0 ; 00002A, 9.317
0463DB C7 06 00    0902*  	dl 0x0006C7 ; 00002B, 9.535
0463DE EF 06 00    0903*  	dl 0x0006EF ; 00002C, 9.752
0463E1 16 07 00    0904*  	dl 0x000716 ; 00002D, 9.970
0463E4 3E 07 00    0905*  	dl 0x00073E ; 00002E, 10.187
0463E7 65 07 00    0906*  	dl 0x000765 ; 00002F, 10.403
0463EA 8D 07 00    0907*  	dl 0x00078D ; 000030, 10.620
0463ED B4 07 00    0908*  	dl 0x0007B4 ; 000031, 10.836
0463F0 DB 07 00    0909*  	dl 0x0007DB ; 000032, 11.051
0463F3 03 08 00    0910*  	dl 0x000803 ; 000033, 11.267
0463F6 2A 08 00    0911*  	dl 0x00082A ; 000034, 11.482
0463F9 51 08 00    0912*  	dl 0x000851 ; 000035, 11.697
0463FC 78 08 00    0913*  	dl 0x000878 ; 000036, 11.911
0463FF 9F 08 00    0914*  	dl 0x00089F ; 000037, 12.125
046402 C6 08 00    0915*  	dl 0x0008C6 ; 000038, 12.339
046405 ED 08 00    0916*  	dl 0x0008ED ; 000039, 12.553
046408 13 09 00    0917*  	dl 0x000913 ; 00003A, 12.766
04640B 3A 09 00    0918*  	dl 0x00093A ; 00003B, 12.978
04640E 61 09 00    0919*  	dl 0x000961 ; 00003C, 13.191
046411 87 09 00    0920*  	dl 0x000987 ; 00003D, 13.403
046414 AE 09 00    0921*  	dl 0x0009AE ; 00003E, 13.614
046417 D4 09 00    0922*  	dl 0x0009D4 ; 00003F, 13.825
04641A FB 09 00    0923*  	dl 0x0009FB ; 000040, 14.036
04641D 21 0A 00    0924*  	dl 0x000A21 ; 000041, 14.247
046420 47 0A 00    0925*  	dl 0x000A47 ; 000042, 14.457
046423 6D 0A 00    0926*  	dl 0x000A6D ; 000043, 14.666
046426 94 0A 00    0927*  	dl 0x000A94 ; 000044, 14.876
046429 BA 0A 00    0928*  	dl 0x000ABA ; 000045, 15.085
04642C E0 0A 00    0929*  	dl 0x000AE0 ; 000046, 15.293
04642F 05 0B 00    0930*  	dl 0x000B05 ; 000047, 15.501
046432 2B 0B 00    0931*  	dl 0x000B2B ; 000048, 15.709
046435 51 0B 00    0932*  	dl 0x000B51 ; 000049, 15.916
046438 77 0B 00    0933*  	dl 0x000B77 ; 00004A, 16.123
04643B 9C 0B 00    0934*  	dl 0x000B9C ; 00004B, 16.329
04643E C2 0B 00    0935*  	dl 0x000BC2 ; 00004C, 16.535
046441 E7 0B 00    0936*  	dl 0x000BE7 ; 00004D, 16.740
046444 0C 0C 00    0937*  	dl 0x000C0C ; 00004E, 16.945
046447 32 0C 00    0938*  	dl 0x000C32 ; 00004F, 17.150
04644A 57 0C 00    0939*  	dl 0x000C57 ; 000050, 17.354
04644D 7C 0C 00    0940*  	dl 0x000C7C ; 000051, 17.558
046450 A1 0C 00    0941*  	dl 0x000CA1 ; 000052, 17.761
046453 C6 0C 00    0942*  	dl 0x000CC6 ; 000053, 17.964
046456 EB 0C 00    0943*  	dl 0x000CEB ; 000054, 18.166
046459 0F 0D 00    0944*  	dl 0x000D0F ; 000055, 18.368
04645C 34 0D 00    0945*  	dl 0x000D34 ; 000056, 18.569
04645F 58 0D 00    0946*  	dl 0x000D58 ; 000057, 18.770
046462 7D 0D 00    0947*  	dl 0x000D7D ; 000058, 18.970
046465 A1 0D 00    0948*  	dl 0x000DA1 ; 000059, 19.170
046468 C6 0D 00    0949*  	dl 0x000DC6 ; 00005A, 19.370
04646B EA 0D 00    0950*  	dl 0x000DEA ; 00005B, 19.569
04646E 0E 0E 00    0951*  	dl 0x000E0E ; 00005C, 19.767
046471 32 0E 00    0952*  	dl 0x000E32 ; 00005D, 19.965
046474 56 0E 00    0953*  	dl 0x000E56 ; 00005E, 20.163
046477 7A 0E 00    0954*  	dl 0x000E7A ; 00005F, 20.360
04647A 9E 0E 00    0955*  	dl 0x000E9E ; 000060, 20.556
04647D C1 0E 00    0956*  	dl 0x000EC1 ; 000061, 20.752
046480 E5 0E 00    0957*  	dl 0x000EE5 ; 000062, 20.947
046483 08 0F 00    0958*  	dl 0x000F08 ; 000063, 21.142
046486 2C 0F 00    0959*  	dl 0x000F2C ; 000064, 21.337
046489 4F 0F 00    0960*  	dl 0x000F4F ; 000065, 21.531
04648C 72 0F 00    0961*  	dl 0x000F72 ; 000066, 21.724
04648F 95 0F 00    0962*  	dl 0x000F95 ; 000067, 21.917
046492 B8 0F 00    0963*  	dl 0x000FB8 ; 000068, 22.109
046495 DB 0F 00    0964*  	dl 0x000FDB ; 000069, 22.301
046498 FE 0F 00    0965*  	dl 0x000FFE ; 00006A, 22.493
04649B 21 10 00    0966*  	dl 0x001021 ; 00006B, 22.683
04649E 44 10 00    0967*  	dl 0x001044 ; 00006C, 22.874
0464A1 66 10 00    0968*  	dl 0x001066 ; 00006D, 23.063
0464A4 89 10 00    0969*  	dl 0x001089 ; 00006E, 23.253
0464A7 AB 10 00    0970*  	dl 0x0010AB ; 00006F, 23.441
0464AA CD 10 00    0971*  	dl 0x0010CD ; 000070, 23.629
0464AD EF 10 00    0972*  	dl 0x0010EF ; 000071, 23.817
0464B0 11 11 00    0973*  	dl 0x001111 ; 000072, 24.004
0464B3 33 11 00    0974*  	dl 0x001133 ; 000073, 24.191
0464B6 55 11 00    0975*  	dl 0x001155 ; 000074, 24.376
0464B9 77 11 00    0976*  	dl 0x001177 ; 000075, 24.562
0464BC 99 11 00    0977*  	dl 0x001199 ; 000076, 24.747
0464BF BA 11 00    0978*  	dl 0x0011BA ; 000077, 24.931
0464C2 DC 11 00    0979*  	dl 0x0011DC ; 000078, 25.115
0464C5 FD 11 00    0980*  	dl 0x0011FD ; 000079, 25.298
0464C8 1E 12 00    0981*  	dl 0x00121E ; 00007A, 25.481
0464CB 3F 12 00    0982*  	dl 0x00123F ; 00007B, 25.663
0464CE 60 12 00    0983*  	dl 0x001260 ; 00007C, 25.844
0464D1 81 12 00    0984*  	dl 0x001281 ; 00007D, 26.025
0464D4 A2 12 00    0985*  	dl 0x0012A2 ; 00007E, 26.206
0464D7 C3 12 00    0986*  	dl 0x0012C3 ; 00007F, 26.386
0464DA E4 12 00    0987*  	dl 0x0012E4 ; 000080, 26.565
0464DD 04 13 00    0988*  	dl 0x001304 ; 000081, 26.744
0464E0 25 13 00    0989*  	dl 0x001325 ; 000082, 26.922
0464E3 45 13 00    0990*  	dl 0x001345 ; 000083, 27.100
0464E6 65 13 00    0991*  	dl 0x001365 ; 000084, 27.277
0464E9 85 13 00    0992*  	dl 0x001385 ; 000085, 27.453
0464EC A5 13 00    0993*  	dl 0x0013A5 ; 000086, 27.629
0464EF C5 13 00    0994*  	dl 0x0013C5 ; 000087, 27.805
0464F2 E5 13 00    0995*  	dl 0x0013E5 ; 000088, 27.979
0464F5 05 14 00    0996*  	dl 0x001405 ; 000089, 28.154
0464F8 24 14 00    0997*  	dl 0x001424 ; 00008A, 28.327
0464FB 44 14 00    0998*  	dl 0x001444 ; 00008B, 28.501
0464FE 63 14 00    0999*  	dl 0x001463 ; 00008C, 28.673
046501 83 14 00    1000*  	dl 0x001483 ; 00008D, 28.845
046504 A2 14 00    1001*  	dl 0x0014A2 ; 00008E, 29.017
046507 C1 14 00    1002*  	dl 0x0014C1 ; 00008F, 29.187
04650A E0 14 00    1003*  	dl 0x0014E0 ; 000090, 29.358
04650D FF 14 00    1004*  	dl 0x0014FF ; 000091, 29.527
046510 1E 15 00    1005*  	dl 0x00151E ; 000092, 29.697
046513 3C 15 00    1006*  	dl 0x00153C ; 000093, 29.865
046516 5B 15 00    1007*  	dl 0x00155B ; 000094, 30.033
046519 79 15 00    1008*  	dl 0x001579 ; 000095, 30.201
04651C 98 15 00    1009*  	dl 0x001598 ; 000096, 30.368
04651F B6 15 00    1010*  	dl 0x0015B6 ; 000097, 30.534
046522 D4 15 00    1011*  	dl 0x0015D4 ; 000098, 30.700
046525 F2 15 00    1012*  	dl 0x0015F2 ; 000099, 30.865
046528 10 16 00    1013*  	dl 0x001610 ; 00009A, 31.030
04652B 2E 16 00    1014*  	dl 0x00162E ; 00009B, 31.194
04652E 4C 16 00    1015*  	dl 0x00164C ; 00009C, 31.357
046531 6A 16 00    1016*  	dl 0x00166A ; 00009D, 31.520
046534 87 16 00    1017*  	dl 0x001687 ; 00009E, 31.682
046537 A5 16 00    1018*  	dl 0x0016A5 ; 00009F, 31.844
04653A C2 16 00    1019*  	dl 0x0016C2 ; 0000A0, 32.005
04653D DF 16 00    1020*  	dl 0x0016DF ; 0000A1, 32.166
046540 FC 16 00    1021*  	dl 0x0016FC ; 0000A2, 32.326
046543 19 17 00    1022*  	dl 0x001719 ; 0000A3, 32.486
046546 36 17 00    1023*  	dl 0x001736 ; 0000A4, 32.645
046549 53 17 00    1024*  	dl 0x001753 ; 0000A5, 32.803
04654C 70 17 00    1025*  	dl 0x001770 ; 0000A6, 32.961
04654F 8C 17 00    1026*  	dl 0x00178C ; 0000A7, 33.118
046552 A9 17 00    1027*  	dl 0x0017A9 ; 0000A8, 33.275
046555 C5 17 00    1028*  	dl 0x0017C5 ; 0000A9, 33.431
046558 E2 17 00    1029*  	dl 0x0017E2 ; 0000AA, 33.587
04655B FE 17 00    1030*  	dl 0x0017FE ; 0000AB, 33.742
04655E 1A 18 00    1031*  	dl 0x00181A ; 0000AC, 33.896
046561 36 18 00    1032*  	dl 0x001836 ; 0000AD, 34.050
046564 52 18 00    1033*  	dl 0x001852 ; 0000AE, 34.203
046567 6E 18 00    1034*  	dl 0x00186E ; 0000AF, 34.356
04656A 8A 18 00    1035*  	dl 0x00188A ; 0000B0, 34.509
04656D A5 18 00    1036*  	dl 0x0018A5 ; 0000B1, 34.660
046570 C1 18 00    1037*  	dl 0x0018C1 ; 0000B2, 34.811
046573 DC 18 00    1038*  	dl 0x0018DC ; 0000B3, 34.962
046576 F7 18 00    1039*  	dl 0x0018F7 ; 0000B4, 35.112
046579 13 19 00    1040*  	dl 0x001913 ; 0000B5, 35.262
04657C 2E 19 00    1041*  	dl 0x00192E ; 0000B6, 35.410
04657F 49 19 00    1042*  	dl 0x001949 ; 0000B7, 35.559
046582 64 19 00    1043*  	dl 0x001964 ; 0000B8, 35.707
046585 7F 19 00    1044*  	dl 0x00197F ; 0000B9, 35.854
046588 99 19 00    1045*  	dl 0x001999 ; 0000BA, 36.001
04658B B4 19 00    1046*  	dl 0x0019B4 ; 0000BB, 36.147
04658E CE 19 00    1047*  	dl 0x0019CE ; 0000BC, 36.293
046591 E9 19 00    1048*  	dl 0x0019E9 ; 0000BD, 36.438
046594 03 1A 00    1049*  	dl 0x001A03 ; 0000BE, 36.582
046597 1D 1A 00    1050*  	dl 0x001A1D ; 0000BF, 36.726
04659A 37 1A 00    1051*  	dl 0x001A37 ; 0000C0, 36.870
04659D 51 1A 00    1052*  	dl 0x001A51 ; 0000C1, 37.013
0465A0 6B 1A 00    1053*  	dl 0x001A6B ; 0000C2, 37.155
0465A3 85 1A 00    1054*  	dl 0x001A85 ; 0000C3, 37.297
0465A6 9F 1A 00    1055*  	dl 0x001A9F ; 0000C4, 37.439
0465A9 B9 1A 00    1056*  	dl 0x001AB9 ; 0000C5, 37.579
0465AC D2 1A 00    1057*  	dl 0x001AD2 ; 0000C6, 37.720
0465AF EC 1A 00    1058*  	dl 0x001AEC ; 0000C7, 37.859
0465B2 05 1B 00    1059*  	dl 0x001B05 ; 0000C8, 37.999
0465B5 1E 1B 00    1060*  	dl 0x001B1E ; 0000C9, 38.137
0465B8 37 1B 00    1061*  	dl 0x001B37 ; 0000CA, 38.276
0465BB 50 1B 00    1062*  	dl 0x001B50 ; 0000CB, 38.413
0465BE 69 1B 00    1063*  	dl 0x001B69 ; 0000CC, 38.550
0465C1 82 1B 00    1064*  	dl 0x001B82 ; 0000CD, 38.687
0465C4 9B 1B 00    1065*  	dl 0x001B9B ; 0000CE, 38.823
0465C7 B4 1B 00    1066*  	dl 0x001BB4 ; 0000CF, 38.959
0465CA CC 1B 00    1067*  	dl 0x001BCC ; 0000D0, 39.094
0465CD E5 1B 00    1068*  	dl 0x001BE5 ; 0000D1, 39.228
0465D0 FD 1B 00    1069*  	dl 0x001BFD ; 0000D2, 39.362
0465D3 16 1C 00    1070*  	dl 0x001C16 ; 0000D3, 39.496
0465D6 2E 1C 00    1071*  	dl 0x001C2E ; 0000D4, 39.629
0465D9 46 1C 00    1072*  	dl 0x001C46 ; 0000D5, 39.762
0465DC 5E 1C 00    1073*  	dl 0x001C5E ; 0000D6, 39.894
0465DF 76 1C 00    1074*  	dl 0x001C76 ; 0000D7, 40.025
0465E2 8E 1C 00    1075*  	dl 0x001C8E ; 0000D8, 40.156
0465E5 A5 1C 00    1076*  	dl 0x001CA5 ; 0000D9, 40.286
0465E8 BD 1C 00    1077*  	dl 0x001CBD ; 0000DA, 40.416
0465EB D5 1C 00    1078*  	dl 0x001CD5 ; 0000DB, 40.546
0465EE EC 1C 00    1079*  	dl 0x001CEC ; 0000DC, 40.675
0465F1 04 1D 00    1080*  	dl 0x001D04 ; 0000DD, 40.803
0465F4 1B 1D 00    1081*  	dl 0x001D1B ; 0000DE, 40.931
0465F7 32 1D 00    1082*  	dl 0x001D32 ; 0000DF, 41.059
0465FA 49 1D 00    1083*  	dl 0x001D49 ; 0000E0, 41.186
0465FD 60 1D 00    1084*  	dl 0x001D60 ; 0000E1, 41.312
046600 77 1D 00    1085*  	dl 0x001D77 ; 0000E2, 41.438
046603 8E 1D 00    1086*  	dl 0x001D8E ; 0000E3, 41.564
046606 A5 1D 00    1087*  	dl 0x001DA5 ; 0000E4, 41.689
046609 BB 1D 00    1088*  	dl 0x001DBB ; 0000E5, 41.814
04660C D2 1D 00    1089*  	dl 0x001DD2 ; 0000E6, 41.938
04660F E9 1D 00    1090*  	dl 0x001DE9 ; 0000E7, 42.061
046612 FF 1D 00    1091*  	dl 0x001DFF ; 0000E8, 42.184
046615 15 1E 00    1092*  	dl 0x001E15 ; 0000E9, 42.307
046618 2C 1E 00    1093*  	dl 0x001E2C ; 0000EA, 42.429
04661B 42 1E 00    1094*  	dl 0x001E42 ; 0000EB, 42.551
04661E 58 1E 00    1095*  	dl 0x001E58 ; 0000EC, 42.672
046621 6E 1E 00    1096*  	dl 0x001E6E ; 0000ED, 42.793
046624 84 1E 00    1097*  	dl 0x001E84 ; 0000EE, 42.913
046627 99 1E 00    1098*  	dl 0x001E99 ; 0000EF, 43.033
04662A AF 1E 00    1099*  	dl 0x001EAF ; 0000F0, 43.152
04662D C5 1E 00    1100*  	dl 0x001EC5 ; 0000F1, 43.271
046630 DA 1E 00    1101*  	dl 0x001EDA ; 0000F2, 43.390
046633 F0 1E 00    1102*  	dl 0x001EF0 ; 0000F3, 43.508
046636 05 1F 00    1103*  	dl 0x001F05 ; 0000F4, 43.625
046639 1B 1F 00    1104*  	dl 0x001F1B ; 0000F5, 43.742
04663C 30 1F 00    1105*  	dl 0x001F30 ; 0000F6, 43.859
04663F 45 1F 00    1106*  	dl 0x001F45 ; 0000F7, 43.975
046642 5A 1F 00    1107*  	dl 0x001F5A ; 0000F8, 44.091
046645 6F 1F 00    1108*  	dl 0x001F6F ; 0000F9, 44.206
046648 84 1F 00    1109*  	dl 0x001F84 ; 0000FA, 44.321
04664B 99 1F 00    1110*  	dl 0x001F99 ; 0000FB, 44.435
04664E AD 1F 00    1111*  	dl 0x001FAD ; 0000FC, 44.549
046651 C2 1F 00    1112*  	dl 0x001FC2 ; 0000FD, 44.662
046654 D7 1F 00    1113*  	dl 0x001FD7 ; 0000FE, 44.775
046657 EB 1F 00    1114*  	dl 0x001FEB ; 0000FF, 44.888
04665A 00 20 00    1115*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
04665D             0062   ; App-specific includes
04665D             0063   	include "nurples/src/asm/player.asm"
04665D             0001*  ; ######## GAME STATE VARIABLES #######
04665D             0002*  ; THESE MUST BE IN THIS ORDER FOR new_game TO WORK PROPERLY
04665D 00 00 00    0003*  player_score: db 0x00,#00,#00 ; bcd
046660             0004*  ; player current shields,binary
046660             0005*  ; when < 0 player splodes
046660             0006*  ; restores to player_max_shields when new ship spawns
046660 10          0007*  player_shields: db 16 ; binary
046661             0008*  ; max player shields,binary
046661             0009*  ; can increase with power-ups (todo)
046661 10          0010*  player_max_shields: db 16 ; binary
046662             0011*  ; when reaches zero,game ends
046662             0012*  ; can increase based on TODO
046662 03          0013*  player_ships: db 0x03 ; binary
046663             0014*  
046663             0015*  ; ######### PLAYER SPRITE PARAMETERS ##########
046663             0016*  ; uses the same offsets from its table base as the main sprite table:
046663             0017*  player_start_variables: ; label marking beginning of table
046663 04          0018*  player_id:               db table_max_records
046664 00          0019*  player_type:             db     0x00 ; 1 bytes currently not used
046665 34 01 00    0020*  player_base_bufferId:    dl BUF_SHIP_0L ; 3 bytes bitmap bufferId
046668 00 00 00    0021*  player_move_program:     dl 0x000000 ; 3 bytes not currently used
04666B 00          0022*  player_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
04666C 00          0023*  player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
04666D 00          0024*  player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
04666E 00 00 00    0025*  player_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
046671 00 00 00    0026*  player_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
046674 00 00 00    0027*  player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
046677 00 00 00    0028*  player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
04667A 00 00 00    0029*  player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
04667D 00 00 00    0030*  player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
046680 00 00 00    0031*  player_orientation:      dl 0x000000 ; 3 bytes not currently used
046683 00          0032*  player_animation:        db     0x00 ; 1 bytes not currently used
046684 00          0033*  player_animation_timer:  db     0x00 ; 1 bytes not currently used
046685 00          0034*  player_move_timer:       db     0x00 ; 1 bytes not currently used
046686 00          0035*  player_move_step:        db     0x00 ; 1 bytes not currently used
046687 00          0036*  player_points:           db     0x00 ; 1 bytes not currently used
046688 00          0037*  player_shield_damage:    db     0x00 ; 1 bytes not currently used
046689             0038*  player_end_variables: ; for when we want to traverse this table in reverse
046689             0039*  
046689             0040*  ; set initial player position
046689             0041*  ; inputs: none,everything is hardcoded
046689             0042*  ; outputs: player_x/y set to bottom-left corner of screen
046689             0043*  ; destroys: a
046689             0044*  player_init:
046689 3E 04       0045*  	ld a,table_max_records ; this is always player spriteId
04668B CD 15 5A 04 0046*  	call vdu_sprite_select
04668F CD 28 5A 04 0047*      call vdu_sprite_clear_frames
046693 21 34 01 00 0048*      ld hl,BUF_SHIP_0L
046697 CD 62 5B 04 0049*      call vdu_sprite_add_buff
04669B 21 35 01 00 0050*      ld hl,BUF_SHIP_1C
04669F CD 62 5B 04 0051*      call vdu_sprite_add_buff
0466A3 21 36 01 00 0052*      ld hl,BUF_SHIP_2R
0466A7 CD 62 5B 04 0053*      call vdu_sprite_add_buff
0466AB 01 00 00 00 0054*      ld bc,0
0466AF ED 43 6E 66 0055*      ld (player_x),bc
       04          
0466B4 11 00 DF 00 0056*      ld de,0x00DF00
0466B8 ED 53 71 66 0057*      ld (player_y),de
       04          
0466BD CD E1 5A 04 0058*      call vdu_sprite_move_abs168
0466C1 CD 8B 5A 04 0059*      call vdu_sprite_show
0466C5 C9          0060*      ret
0466C6             0061*  
0466C6             0062*  ; process player keyboard input, set player bitmap
0466C6             0063*  ; velocities and draw player bitmap at updated coordinates
0466C6             0064*  ; Inputs: player_x/y set at desired position
0466C6             0065*  ; Returns: player bitmap drawn at updated position
0466C6             0066*  ; Destroys: probably everything except maybe iy
0466C6             0067*  ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
0466C6             0068*  ; TODO: requires sprite implementation
0466C6             0069*  player_input:
0466C6             0070*  ; reset player component velocities to zero as the default
0466C6 21 00 00 00 0071*  	ld hl,0
0466CA 22 74 66 04 0072*  	ld (player_xvel),hl
0466CE 22 77 66 04 0073*  	ld (player_yvel),hl
0466D2             0074*  ; make ship the active sprite
0466D2 3E 04       0075*      ld a,table_max_records ; this is always player spriteId
0466D4 CD 15 5A 04 0076*      call vdu_sprite_select
0466D8             0077*  ; check for keypresses and branch accordingly
0466D8             0078*  ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
0466D8             0079*      MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
0466D8 3E 1E       0001*M 			LD	A, function
0466DA 5B CF       0002*M 			RST.LIL	08h
0466DC             0080*  ; we test all four arrow keys and add/subract velocities accordingly
0466DC             0081*  ; this handles the case where two opposing movement keys
0466DC             0082*  ; are down simultaneously (velocities will net to zero)
0466DC             0083*  ; and allows diagonal movement when a vertical and horizontal key are down
0466DC             0084*  ; it also allows movement and action keys to be detected simultaneously
0466DC             0085*  ; so we can walk and chew gum at the same time
0466DC 3E 01       0086*      ld a,1 ; set ship's default animation to center
0466DE             0087*          ; if left and right are both down a will net to
0466DE             0088*  
0466DE             0089*  @left:
0466DE DD CB 03 4E 0090*      bit 1,(ix+3) ; keycode 26
0466E2 28 0E       0091*      jr z,@right
0466E4 2A 74 66 04 0092*      ld hl,(player_xvel)
0466E8 01 00 FD FF 0093*      ld bc,-speed_player
0466EC 09          0094*      add hl,bc
0466ED 22 74 66 04 0095*      ld (player_xvel),hl
0466F1 3D          0096*      dec a ; set ship's animation to left
0466F2             0097*  @right:
0466F2 DD CB 0F 4E 0098*      bit 1,(ix+15) ; keycode 122
0466F6 28 0E       0099*  	jr z,@up
0466F8 2A 74 66 04 0100*      ld hl,(player_xvel)
0466FC 01 00 03 00 0101*      ld bc,speed_player
046700 09          0102*      add hl,bc
046701 22 74 66 04 0103*      ld (player_xvel),hl
046705 3C          0104*      inc a ; set ship's animation to right
046706             0105*  @up:
046706 DD CB 07 4E 0106*      bit 1,(ix+7) ; keycode 58
04670A 28 0D       0107*  	jr z,@down
04670C 2A 77 66 04 0108*      ld hl,(player_yvel)
046710 01 00 FD FF 0109*      ld bc,-speed_player
046714 09          0110*      add hl,bc
046715 22 77 66 04 0111*      ld (player_yvel),hl
046719             0112*  @down:
046719 DD CB 05 4E 0113*      bit 1,(ix+5) ; keycode 42
04671D 28 0D       0114*  	jr z,@done_keyboard
04671F 2A 77 66 04 0115*      ld hl,(player_yvel)
046723 01 00 03 00 0116*      ld bc,speed_player
046727 09          0117*      add hl,bc
046728 22 77 66 04 0118*      ld (player_yvel),hl
04672C             0119*  @done_keyboard:
04672C             0120*  ; move player sprite according to velocities set by keypresses
04672C 2A 74 66 04 0121*      ld hl,(player_xvel)
046730             0122*  ; compute new x position
046730 ED 5B 6E 66 0123*      ld de,(player_x)
       04          
046735 19          0124*      add hl,de ; hl = player_x + player_xvel
046736             0125*      ; check for horizontal screen edge collisions
046736             0126*      ; and adjust coordinate as necessary
046736             0127*  ; TODO: make this work using 24-bit registers
046736             0128*      ; cp 8 ; 0 + 1/2 bitmap dim_x
046736             0129*      ; jr nc,@check_right ; x >= 8, no adjustment necessary
046736             0130*      ; ld a,8 ; set x to leftmost allowable position
046736             0131*  ; @check_right:
046736             0132*  ;     cp 248 ; 256 - 1/2 bitmap dim_x
046736             0133*  ;     jr c,@x_ok ; x < 248, no adjustment necessary
046736             0134*  ;     ld a,248 ; set x to rightmost allowable position
046736             0135*  @x_ok:
046736             0136*  ; save the updated drawing coordinate
046736 22 6E 66 04 0137*      ld (player_x),hl
04673A             0138*  ;compute new y position
04673A 2A 71 66 04 0139*      ld hl,(player_y)
04673E ED 5B 77 66 0140*      ld de,(player_yvel)
       04          
046743 19          0141*      add hl,de ; hl = player_y + player_yvel
046744             0142*  ; TODO: make this work using 24-bit registers
046744             0143*  ;     ; check for vertical screen edge collisions
046744             0144*  ;     ; and adjust coordinate as necessary
046744             0145*  ;     cp 8 ; 0 + 1/2 bitmap dim_y
046744             0146*  ;     jr nc,@check_top ; y >= 8, no adjustment necessary
046744             0147*  ;     ld a,8 ; set y to topmost allowable position
046744             0148*  ; @check_top:
046744             0149*  ;     cp 232 ; 240 - 1/2 bitmap dim_y
046744             0150*  ;     jr c,@y_ok ; y < 248, no adjustment necessary
046744             0151*  ;     ld a,232 ; set y to bottommost allowable position
046744             0152*  @y_ok:
046744 22 71 66 04 0153*      ld (player_y),hl ; do this here b/c next call destroys hl
046748             0154*  ; a should land here loaded with the correct frame
046748 CD 78 5A 04 0155*      call vdu_sprite_select_frame
04674C             0156*  ; draw player at updated position
04674C ED 4B 6E 66 0157*      ld bc,(player_x)
       04          
046751 ED 5B 71 66 0158*  	ld de,(player_y)
       04          
046756             0159*  
046756             0160*      ; call dumpRegistersHex
046756             0161*  
046756 CD E1 5A 04 0162*  	call vdu_sprite_move_abs168
04675A             0163*  
04675A             0164*  ; end player_input
04675A C9          0165*  	ret
04675B             0166*  
04675B             0167*  ; ; THE BELOW WORKS WITH THE AGON BUT USES INTEGER COORDINATES
04675B             0168*  ; ; INSTEAD OF FRACTIONAL
04675B             0169*  ; ; ----------------------------------------------------------------
04675B             0170*  ; ; process player keyboard input, set player bitmap
04675B             0171*  ; ; velocities and draw player bitmap at updated coordinates
04675B             0172*  ; ; Inputs: player_x/y set at desired position
04675B             0173*  ; ; Returns: player bitmap drawn at updated position
04675B             0174*  ; ; Destroys: probably everything except maybe iy
04675B             0175*  ; ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
04675B             0176*  ; ; TODO: requires sprite implementation
04675B             0177*  ; player_input:
04675B             0178*  ; ; reset player component velocities to zero as the default
04675B             0179*  ; 	ld hl,0
04675B             0180*  ; 	ld (player_xvel),hl
04675B             0181*  ; 	ld (player_yvel),hl
04675B             0182*  ; ; check for keypresses and branch accordingly
04675B             0183*  ; ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
04675B             0184*  ;     MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
04675B             0185*  ; ; we test all four arrow keys and add/subract velocities accordingly
04675B             0186*  ; ; this handles the case where two opposing movement keys
04675B             0187*  ; ; are down simultaneously (velocities will net to zero)
04675B             0188*  ; ; and allows diagonal movement when a vertical and horizontal key are down
04675B             0189*  ; ; it also allows movement and action keys to be detected simultaneously
04675B             0190*  ; ; so we can walk and chew gum at the same time
04675B             0191*  ; @left:
04675B             0192*  ;     bit 1,(ix+3) ; keycode 26
04675B             0193*  ;     jr z,@right
04675B             0194*  ;     ld hl,(player_xvel)
04675B             0195*  ;     ld bc,-3
04675B             0196*  ;     add hl,bc
04675B             0197*  ;     ld (player_xvel),hl
04675B             0198*  ; @right:
04675B             0199*  ;     bit 1,(ix+15) ; keycode 122
04675B             0200*  ; 	jr z,@up
04675B             0201*  ;     ld hl,(player_xvel)
04675B             0202*  ;     ld bc,3
04675B             0203*  ;     add hl,bc
04675B             0204*  ;     ld (player_xvel),hl
04675B             0205*  ; @up:
04675B             0206*  ;     bit 1,(ix+7) ; keycode 58
04675B             0207*  ; 	jr z,@down
04675B             0208*  ;     ld hl,(player_yvel)
04675B             0209*  ;     ld bc,-3
04675B             0210*  ;     add hl,bc
04675B             0211*  ;     ld (player_yvel),hl
04675B             0212*  ; @down:
04675B             0213*  ;     bit 1,(ix+5) ; keycode 42
04675B             0214*  ; 	jr z,@done_keyboard
04675B             0215*  ;     ld hl,(player_yvel)
04675B             0216*  ;     ld bc,3
04675B             0217*  ;     add hl,bc
04675B             0218*  ;     ld (player_yvel),hl
04675B             0219*  ; @done_keyboard:
04675B             0220*  ; ; move player sprite according to velocities set by keypresses
04675B             0221*  ;     ld hl,(player_xvel)
04675B             0222*  ; ; compute new x position
04675B             0223*  ;     ld de,(player_x)
04675B             0224*  ;     add hl,de ; hl = player_x + player_xvel
04675B             0225*  ;     ; check for horizontal screen edge collisions
04675B             0226*  ;     ; and adjust coordinate as necessary
04675B             0227*  ; ; TODO: make this work using 24-bit registers
04675B             0228*  ;     ; cp 8 ; 0 + 1/2 bitmap dim_x
04675B             0229*  ;     ; jr nc,@check_right ; x >= 8, no adjustment necessary
04675B             0230*  ;     ; ld a,8 ; set x to leftmost allowable position
04675B             0231*  ; ; @check_right:
04675B             0232*  ; ;     cp 248 ; 256 - 1/2 bitmap dim_x
04675B             0233*  ; ;     jr c,@x_ok ; x < 248, no adjustment necessary
04675B             0234*  ; ;     ld a,248 ; set x to rightmost allowable position
04675B             0235*  ; @x_ok:
04675B             0236*  ;     ; save the updated drawing coordinate
04675B             0237*  ;     ld (player_x),hl
04675B             0238*  ; ;compute new y position
04675B             0239*  ;     ld hl,(player_y)
04675B             0240*  ;     ld de,(player_yvel)
04675B             0241*  ;     add hl,de ; hl = player_y + player_yvel
04675B             0242*  ; ; TODO: make this work using 24-bit registers
04675B             0243*  ; ;     ; check for vertical screen edge collisions
04675B             0244*  ; ;     ; and adjust coordinate as necessary
04675B             0245*  ; ;     cp 8 ; 0 + 1/2 bitmap dim_y
04675B             0246*  ; ;     jr nc,@check_top ; y >= 8, no adjustment necessary
04675B             0247*  ; ;     ld a,8 ; set y to topmost allowable position
04675B             0248*  ; ; @check_top:
04675B             0249*  ; ;     cp 232 ; 240 - 1/2 bitmap dim_y
04675B             0250*  ; ;     jr c,@y_ok ; y < 248, no adjustment necessary
04675B             0251*  ; ;     ld a,232 ; set y to bottommost allowable position
04675B             0252*  ; @y_ok:
04675B             0253*  ;     ld (player_y),hl
04675B             0254*  ; ; draw player at updated position
04675B             0255*  ;     ld a,table_max_records ; this is always player spriteId
04675B             0256*  ;     call vdu_sprite_select
04675B             0257*  ;     ld hl,(player_xvel) ; we do a cheeky little hack
04675B             0258*  ;     call get_sign_hlu ; to set the proper animation
04675B             0259*  ;     add a,1 ; ...
04675B             0260*  ;     call vdu_sprite_select_frame
04675B             0261*  ;     ld bc,(player_x)
04675B             0262*  ; 	ld de,(player_y)
04675B             0263*  ; 	call vdu_sprite_move_abs
04675B             0264*  ; ; end player_input
04675B             0265*  ; 	ret
04675B             0266*  
04675B             0267*  
04675B             0268*  ; ###################################################################
04675B             0269*  ; TODO: the below is all stuff from the original code we need to port
04675B             0270*  ; ###################################################################
04675B             0271*  
04675B             0272*  ; kill_player:
04675B             0273*  ; ; set player status to dead
04675B             0274*  ;     xor a; sets all player flags to zero
04675B             0275*  ;     ld (player_collisions),a
04675B             0276*  ; ; deduct a ship from the inventory
04675B             0277*  ;     ld a,(player_ships)
04675B             0278*  ;     dec a
04675B             0279*  ;     ld (player_ships),a
04675B             0280*  ; ; are we out of ships?
04675B             0281*  ;     jp z,game_over
04675B             0282*  ; ; wait a few ticks
04675B             0283*  ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
04675B             0284*  ;     ld (player_move_timer),a
04675B             0285*  ; kill_player_loop:
04675B             0286*  ;     call vsync
04675B             0287*  ;     ld a,(player_move_timer)
04675B             0288*  ;     dec a
04675B             0289*  ;     ld (player_move_timer),a
04675B             0290*  ;     jr nz,kill_player_loop
04675B             0291*  ;     call player_init ; player respawn if timer zero
04675B             0292*  ;     ret ; and out
04675B             0293*  
04675B             0294*  
04675B             0295*  ; player_move:
04675B             0296*  ; ; begin setting player to active sprite
04675B             0297*  ;     ld hl,player
04675B             0298*  ;     ld (sprite_base_bufferId),hl
04675B             0299*  ;     ld hl,0 ; north
04675B             0300*  ;     ld (sprite_heading),hl
04675B             0301*  ;     ld a,#01 ; animation 1 is center,which we set here as a default
04675B             0302*  ;     ld (sprite_animation),a
04675B             0303*  ;     ; we set position here for the time being as a default
04675B             0304*  ;     ; in case the player doesn't move,or is flagged for deletion
04675B             0305*  ;     ld hl,(player_x)
04675B             0306*  ;     ld (sprite_x),hl
04675B             0307*  ;     ld hl,(player_y)
04675B             0308*  ;     ld (sprite_y),hl
04675B             0309*  ; ; did we just die?
04675B             0310*  ;     ld a,(player_collisions)
04675B             0311*  ;     and %00000010 ; zero flag will be set if not dead
04675B             0312*  ;     jr z,player_not_dead
04675B             0313*  ; ; yes we died
04675B             0314*  ;     call kill_player
04675B             0315*  ;     ret ; done
04675B             0316*  ; ; yay we didn't die
04675B             0317*  ; player_not_dead:
04675B             0318*  ; ; set player movements to zero by default
04675B             0319*  ;     ld hl,0
04675B             0320*  ;     ld (player_xvel),hl
04675B             0321*  ;     ld (player_yvel),hl
04675B             0322*  ; ; do we move it?
04675B             0323*  ;     in a,(#82) ; keyboard
04675B             0324*  ;     or a ; if zero,don't move
04675B             0325*  ;     jr z,player_draw
04675B             0326*  ; ; move it
04675B             0327*  ;     call player_move_calc
04675B             0328*  ; player_draw:
04675B             0329*  ;     call vdu_bmp_select
04675B             0330*  ;     call vdu_bmp_draw
04675B             0331*  ; player_move_done:
04675B             0332*  ;     ; write updated x,y coordinates back to player table
04675B             0333*  ;     ld hl,(sprite_x)
04675B             0334*  ;     ld (player_x),hl
04675B             0335*  ;     ld hl,(sprite_y)
04675B             0336*  ;     ld (player_y),hl
04675B             0337*  ;     ret
04675B             0064   	include "nurples/src/asm/tiles.asm"
04675B             0001*  ; ######### TILES #########
04675B             0002*  ; TODO: implement buffering of tiles here when there isn't other stuff to do
04675B             0003*  ; tiles_defs: ds 256*16 ; 256 rows of 16 tiles, each tile is a byte
04675B 00 00 00    0004*  tiles_row_defs: dl 0x000000 ; pointer to current row tiles definitions
04675E 00          0005*  tiles_row: db 0 ; decrements each time a row is drawn. level is over when hits zero
04675F             0006*                          ; initialize to zero for a maximum of 256 rows in a level
04675F 00          0007*  cur_level: db 0
046760             0008*  num_levels: equ 2 ; number of levels,duh
046760             0009*  
046760             0010*  ; lookup table for level definitions
046760 61 41 04 62 0011*  tiles_levels: dl tiles_level_00,tiles_level_01
       51 04       
046766             0012*  
046766             0013*  ; tiles_bufferId: dl 0
046766 00 00 00    0014*  tiles_x_plot: dl 0
046769 F1 FF FF    0015*  tiles_y_plot: dl -15
04676C             0016*  
04676C             0017*  
04676C             0018*  tiles_plot:
04676C             0019*  ; ; NOTE: this is bugged. y1 should be zero to get a 1px-tall viewport
04676C             0020*  ; ;       as written it gves a 2px-tall window which is what we'd expect,
04676C             0021*  ; ;       but don't want
04676C             0022*  ; ; https://discord.com/channels/1158535358624039014/1158536809916149831/1209571014514712637
04676C             0023*  ; ; set gfx viewport to one scanline to optimise plotting tiles
04676C             0024*  ; 	ld bc,0 ; leftmost x-coord
04676C             0025*  ; 	ld de,0 ; topmost y-coord
04676C             0026*  ; 	ld ix,255 ; rightmost x-coord
04676C             0027*  ; 	ld iy,1 ; bottommost y-coord
04676C             0028*  ; 	call vdu_set_gfx_viewport
04676C             0029*  
04676C 21 00 00 00 0030*      ld hl,0 ; init plotting x-coordinate
046770 22 66 67 04 0031*      ld (tiles_x_plot),hl
046774 2A 5B 67 04 0032*      ld hl,(tiles_row_defs)
046778 06 10       0033*  	ld b,16 ; loop counter
04677A             0034*  @loop:
04677A C5          0035*  	push bc ; save the loop counter
04677B             0036*  ; read the tile defintion for the current column
04677B 7E          0037*      ld a,(hl) ; a has tile definition
04677C E5          0038*      push hl  ; save pointer to tile definition
04677D 21 00 00 00 0039*      ld hl,0 ; hlu is non-zero
046781 6F          0040*      ld l,a ; l is tile defintion
046782 26 01       0041*      ld h,0x01 ; hl = 256 + tile index = the tile's bitmapId
046784 CD C8 57 04 0042*      call vdu_buff_select ; tile bitmap buffer is now active
046788             0043*  
046788             0044*  ; plot the active bitmap
046788 ED 4B 66 67 0045*      ld bc,(tiles_x_plot)
       04          
04678D ED 5B 69 67 0046*      ld de,(tiles_y_plot)
       04          
046792 CD 74 59 04 0047*      call vdu_plot_bmp
046796             0048*  
046796             0049*  ; bump x-coords the width of one tile and save it
046796 2A 66 67 04 0050*      ld hl,(tiles_x_plot)
04679A 01 10 00 00 0051*      ld bc,16
04679E 09          0052*      add hl,bc
04679F 22 66 67 04 0053*      ld (tiles_x_plot),hl
0467A3             0054*  
0467A3             0055*  ; prepare to loop to next column
0467A3 E1          0056*      pop hl ; get back pointer to tile def
0467A4 23          0057*      inc hl ; bump it to the next column
0467A5 C1          0058*  	pop bc ; snag our loop counter
0467A6 10 D2       0059*      djnz @loop
0467A8             0060*  
0467A8             0061*  ; increment tiles plotting y-coordinate
0467A8             0062*  ; when it hits zero, we go to next row of tiles in the map
0467A8             0063*  ; (we use ix b/c we want to preserve hl for the next step)
0467A8 DD 21 69 67 0064*  	ld ix,tiles_y_plot
       04          
0467AD DD 34 00    0065*  	inc (ix)
0467B0 C0          0066*  	ret nz
0467B1             0067*  
0467B1             0068*  ; time to bump tiles_row_defs to next row
0467B1             0069*  ; (hl was already there at the end of the loop)
0467B1 22 5B 67 04 0070*      ld (tiles_row_defs),hl
0467B5             0071*  
0467B5             0072*  ; reset coords to plot next row of tiles
0467B5 21 00 00 00 0073*      ld hl,0
0467B9 22 66 67 04 0074*      ld (tiles_x_plot),hl
0467BD 21 F1 FF FF 0075*      ld hl,-15
0467C1 22 69 67 04 0076*      ld (tiles_y_plot),hl
0467C5             0077*  
0467C5             0078*  ; decrement tiles row counter
0467C5 21 5E 67 04 0079*      ld hl,tiles_row
0467C9 35          0080*      dec (hl)
0467CA C0          0081*      ret nz
0467CB             0082*  
0467CB             0083*  ; queue up next level
0467CB 3A 5F 67 04 0084*      ld a,(cur_level)
0467CF FE 01       0085*      cp num_levels-1
0467D1 20 02       0086*      jr nz,@inc_level
0467D3 3E FF       0087*      ld a,-1 ; will wrap around to zero when we fall through
0467D5             0088*  
0467D5             0089*  @inc_level:
0467D5 3C          0090*      inc a
0467D6 32 5F 67 04 0091*      ld (cur_level),a
0467DA             0092*  
0467DA             0093*  ; increase the number of enemy sprites
0467DA 3A 29 68 04 0094*      ld a,(max_enemy_sprites)
0467DE 3C          0095*      inc a
0467DF FE 04       0096*      cp table_max_records ; if we're at the global limit,skip ahead at max level
0467E1 28 04       0097*      jr z,init_level
0467E3 32 29 68 04 0098*      ld (max_enemy_sprites),a ; otherwise save the updated number
0467E7             0099*  ; fall through to init_level
0467E7             0100*  
0467E7             0101*  init_level:
0467E7             0102*  ; look up address of level's tile defintion
0467E7 21 60 67 04 0103*      ld hl,tiles_levels
0467EB 3A 5F 67 04 0104*      ld a,(cur_level)
0467EF 11 00 00 00 0105*      ld de,0 ; just in case deu is non-zero
0467F3 57          0106*      ld d,a
0467F4 1E 03       0107*      ld e,3
0467F6 ED 5C       0108*      mlt de
0467F8 19          0109*      add hl,de
0467F9 ED 37       0110*      ld ix,(hl)
0467FB DD 22 5B 67 0111*      ld (tiles_row_defs),ix
       04          
046800             0112*  
046800             0113*  ; set tiles_row counter
046800 DD 7E 00    0114*      ld a,(ix)
046803 32 5E 67 04 0115*      ld (tiles_row),a
046807 DD 23       0116*      inc ix ; now ix points first element of first row tile def
046809 DD 22 5B 67 0117*      ld (tiles_row_defs),ix ; ... so we save it
       04          
04680E C9          0118*      ret
04680F             0119*  
04680F             0120*  
04680F             0121*  ; ###### TODO: NEW CODE TO IMPLEMENT ######
04680F             0122*  ; dt_is_active:
04680F             0123*  ; ; a lands here containing a tile index in the low nibble
04680F             0124*  ; ; we test the values for the tiles which are active
04680F             0125*  ;     cp #07
04680F             0126*  ;     call z,ld_act_landing_pad
04680F             0127*  ;     cp #08
04680F             0128*  ;     call z,ld_act_laser_turret
04680F             0129*  ;     ; fall through
04680F             0130*  ;     ret
04680F             0131*  
04680F             0132*  ; ; some tiles become active sprites,so we load those here
04680F             0133*  ; ; sprite_x/y have already been loaded
04680F             0134*  ; ; sprite_dim_x/y are loaded by table_add_record
04680F             0135*  ; ; we don't want sprite drawn to background like other tiles
04680F             0136*  ; ; so this routine only adds them to the sprite table
04680F             0137*  ; dt_ld_act:
04680F             0138*  ;     ld a,#48 ; top of screen + 1/2 tile height
04680F             0139*  ;     ld (sprite_y+1),a ; just the integer part
04680F             0140*  ;     ld (sprite_base_bufferId),hl
04680F             0141*  ;     call vdu_bmp_select
04680F             0142*  ;     call table_add_record
04680F             0143*  ;     call sprite_variables_from_stack
04680F             0144*  ;     ld a,#FF ; lets calling proc know we loaded an active tile
04680F             0145*  ;     ret ; and back
04680F             0146*  
04680F             0147*  ; ld_act_landing_pad:
04680F             0148*  ;     call sprite_variables_to_stack
04680F             0149*  
04680F             0150*  ;     ld hl,move_landing_pad
04680F             0151*  ;     ld (sprite_move_program),hl
04680F             0152*  
04680F             0153*  ;     xor a
04680F             0154*  ;     ld (sprite_animation),a ; animation 0
04680F             0155*  
04680F             0156*  ;     call rand_8     ; snag a random number
04680F             0157*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
04680F             0158*  ;     add a,64 ; range is now 64-127
04680F             0159*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
04680F             0160*  
04680F             0161*  ;     ld a,%10 ; collides with laser but not player
04680F             0162*  ;     ld (iy+sprite_collisions),a
04680F             0163*  
04680F             0164*  ;     ld a,#05 ; BCD
04680F             0165*  ;     ld (sprite_points),a
04680F             0166*  ;     ld a,0 ; binary
04680F             0167*  ;     ld (sprite_shield_damage),a
04680F             0168*  
04680F             0169*  ;     ld hl,landing_pad ; dt_ld_act loads this to sprite_base_bufferId
04680F             0170*  ;     jr dt_ld_act
04680F             0171*  
04680F             0172*  ; ld_act_laser_turret:
04680F             0173*  ;     call sprite_variables_to_stack
04680F             0174*  
04680F             0175*  ;     ld hl,move_laser_turret
04680F             0176*  ;     ld (sprite_move_program),hl
04680F             0177*  
04680F             0178*  ;     xor a
04680F             0179*  ;     ld (sprite_animation),a
04680F             0180*  ;     ld (sprite_move_step),a
04680F             0181*  
04680F             0182*  ;     call rand_8     ; snag a random number
04680F             0183*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
04680F             0184*  ;     add a,64 ; range is now 64-127
04680F             0185*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
04680F             0186*  
04680F             0187*  ;     ld a,%10 ; collides with laser but not player
04680F             0188*  ;     ld (iy+sprite_collisions),a
04680F             0189*  
04680F             0190*  ;     ld a,#10 ; BCD
04680F             0191*  ;     ld (sprite_points),a
04680F             0192*  ;     ld a,0 ; binary
04680F             0193*  ;     ld (sprite_shield_damage),a
04680F             0194*  
04680F             0195*  ;     ld hl,laser_turret ; dt_ld_act loads this to sprite_base_bufferId
04680F             0196*  ;     jp dt_ld_act
04680F             0197*  
04680F             0198*  
04680F             0199*  ; moves active tile sprites down one pixel in sync with tiles movement
04680F             0200*  ; deletes sprites from table when they wrap around to top of screen
04680F             0201*  move_active_tiles:
04680F             0202*  ; get current position
04680F 3A 0F 00 00 0203*      ld a,(sprite_y+1) ; we only need the integer part
046813 3C          0204*      inc a
046814             0205*  ; are we at the bottom of the screen?
046814 20 06       0206*      jr nz,move_active_tiles_draw_sprite ; nope
046816             0207*  ; otherwise kill sprite
046816 3E 80       0208*      ld a,%10000000 ; any bit set in high nibble means sprite will die
046818 FD 77 08    0209*      ld (iy+sprite_collisions),a
04681B C9          0210*      ret ; debug
04681C             0211*  move_active_tiles_draw_sprite:
04681C 32 0F 00 00 0212*      ld (sprite_y+1),a ; update tile y position integer part
046820 CD B5 57 04 0213*      call vdu_bmp_select
046824 CD FE 57 04 0214*      call vdu_bmp_draw ; draw it
046828 C9          0215*      ret ; and done
046829             0065   	include "nurples/src/asm/enemies.asm"
046829 10          0001*  max_enemy_sprites: db 16
04682A             0002*  
04682A             0003*  ; sprite_type
04682A             0004*  enemy_dead: equ 0
04682A             0005*  enemy_small: equ 1
04682A             0006*  enemy_medium: equ 2
04682A             0007*  enemy_large: equ 3
04682A             0008*  landing_pad: equ 4
04682A             0009*  laser_turret: equ 5
04682A             0010*  fireballs: equ 6
04682A             0011*  explosion: equ 7
04682A             0012*  
04682A             0013*  
04682A             0014*  respawn_countdown:
04682A 2A 4B 68 04 0015*      ld hl,(respawn_timer)
04682E 2B          0016*      dec hl
04682F 22 4B 68 04 0017*      ld (respawn_timer),hl
046833             0018*  ; check hl for zero
046833 19          0019*      add hl,de
046834 B7          0020*      or a
046835 ED 52       0021*      sbc hl,de
046837 C0          0022*      ret nz
046838 06 04       0023*      ld b,table_max_records
04683A             0024*  @respawn_loop:
04683A C5          0025*      push bc
04683B CD 40 69 04 0026*      call enemy_init_from_landing_pad
04683F C1          0027*      pop bc
046840 10 F8       0028*      djnz @respawn_loop
046842 21 3C 00 00 0029*      ld hl,1*60 ; 1 second
046846 22 4B 68 04 0030*      ld (respawn_timer),hl
04684A C9          0031*      ret
04684B 3C 00 00    0032*  respawn_timer: dl 1*60
04684E             0033*  
04684E             0034*  move_enemies:
04684E             0035*  ; are there any active enemies or explosions?
04684E 21 00 00 00 0036*      ld hl,0
046852 3A FE 52 04 0037*      ld a,(table_active_sprites)
046856 6F          0038*      ld l,a
046857 CD 5C 54 04 0039*      call dumpRegistersHex
04685B A7          0040*      and a ; will be zero if no alive enemies or explosions
04685C             0041*      ; ret z ; so nothing to do but go back
04685C             0042*      ; ld hl,(respawn_timer)
04685C             0043*      ; call dumpRegistersHex
04685C 20 05       0044*      jr nz,move_enemies_do
04685E CD 2A 68 04 0045*      call respawn_countdown
046862 C9          0046*      ret
046863             0047*  move_enemies_do:
046863             0048*  ; initialize pointers and loop counter
046863 FD 21 63 52 0049*      ld iy,table_base ; set iy to first record in table
       04          
046868 06 04       0050*      ld b,table_max_records ; loop counter
04686A             0051*  move_enemies_loop:
04686A FD 22 FB 52 0052*      ld (table_pointer),iy ; update table pointer
       04          
04686F C5          0053*      push bc ; backup loop counter
046870             0054*  ; check sprite_type to see if sprite is active
046870 FD 7E 01    0055*      ld a,(iy+sprite_type)
046873 A7          0056*      and a ; if zero, sprite is dead
046874 28 2E       0057*      jr z,move_enemies_next_record ; ... and we skip to next record
046876             0058*  ; otherwise we prepare to move the sprite
046876 FD 7E 00    0059*      ld a,(iy+sprite_id) ; get spriteId
046879 CD 15 5A 04 0060*      call vdu_sprite_select ; select sprite
04687D FD 27 05    0061*      ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
046880 E9          0062*      jp (hl)  ; ... and jump to it
046881             0063*  ; we always jp back here from behavior subroutines
046881             0064*  move_enemies_loop_return:
046881 FD 2A FB 52 0065*      ld iy,(table_pointer) ; get back table pointer
       04          
046886             0066*  ; now we check results of all the moves
046886 FD 7E 08    0067*      ld a,(iy+sprite_collisions)
046889 E6 F0       0068*      and %11110000 ; any bits set in high nibble means we died
04688B FD 7E 00    0069*      ld a,(iy+sprite_id) ; get spriteId for the deactivate_sprite call if needed
04688E 28 0A       0070*      jr z,move_enemies_draw_sprite ; if not dead,draw sprite
046890 CD 47 53 04 0071*      call table_deactivate_sprite ; otherwise we ded
046894 AF          0072*      xor a ; zero a so that we can ...
046895 FD 77 08    0073*      ld (iy+sprite_collisions),a ; ... clear collision flags
046898 18 0A       0074*      jr move_enemies_next_record ; and to the next record
04689A             0075*  move_enemies_draw_sprite:
04689A             0076*  ; if we got here sprite will have already been activated
04689A             0077*  ; so all we need to do is set its coordinates and draw it
04689A FD 07 0B    0078*      ld bc,(iy+sprite_x)
04689D FD 17 0E    0079*      ld de,(iy+sprite_y)
0468A0 CD E1 5A 04 0080*      call vdu_sprite_move_abs168
0468A4             0081*  ; fall through to next record
0468A4             0082*  move_enemies_next_record:
0468A4 11 26 00 00 0083*      ld de,table_bytes_per_record
0468A8 FD 19       0084*      add iy,de ; point to next record
0468AA AF          0085*      xor a ; clears carry flag
0468AB 32 FF 52 04 0086*      ld (sprite_screen_edge),a ; clear screen edge collision flag
0468AF C1          0087*      pop bc ; get back our loop counter
0468B0 10 B8       0088*      djnz move_enemies_loop ; loop until we've checked all the records
0468B2 C9          0089*      ret ; and we're out
0468B3             0090*  
0468B3             0091*  en_nav_zigzag_start:
0468B3 FD 2A FB 52 0092*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0468B8 CD E5 5D 04 0093*      call rand_8
0468BC E6 3F       0094*      and %00111111 ; limit it to 64
0468BE CB DF       0095*      set 3,a ; make sure it's at least 8
0468C0 FD 77 22    0096*      ld (iy+sprite_move_timer),a ; store it
0468C3             0097*      ; fall through to en_nav_zigzag
0468C3             0098*  en_nav_zigzag:
0468C3 FD 7E 22    0099*      ld a,(iy+sprite_move_timer)
0468C6 3D          0100*      dec a
0468C7 FD 77 22    0101*      ld (iy+sprite_move_timer),a
0468CA 20 1C       0102*      jr nz,en_nav_zigzag_no_switch
0468CC             0103*      ; otherwise flip direction and restart timer
0468CC FD 7E 23    0104*      ld a,(iy+sprite_move_step)
0468CF EE 01       0105*      xor %1 ; flips bit one
0468D1 FD 77 23    0106*      ld (iy+sprite_move_step),a ; store it
0468D4 20 09       0107*      jr nz,en_nav_zigzag_right
0468D6             0108*  ;otherwise zag left
0468D6 21 00 A0 00 0109*      ld hl,0x00A000; southwest heading
0468DA FD 2F 1A    0110*      ld (iy+sprite_heading),hl ; save sprite heading
0468DD 18 D4       0111*      jr en_nav_zigzag_start
0468DF             0112*  en_nav_zigzag_right:
0468DF 21 00 60 00 0113*      ld hl,0x006000; southeast heading
0468E3 FD 2F 1A    0114*      ld (iy+sprite_heading),hl ; save sprite heading
0468E6 18 CB       0115*      jr en_nav_zigzag_start
0468E8             0116*  en_nav_zigzag_no_switch:
0468E8             0117*      ; ld a,(sprite_orientation)
0468E8 FD 27 1A    0118*      ld hl,(iy+sprite_heading)
0468EB 18 13       0119*      jr en_nav_computevelocities
0468ED             0120*  
0468ED             0121*  ; contains the logic for how to move the enemy
0468ED             0122*  ; and then does the moving
0468ED             0123*  ; inputs: a fully-populated active sprite table
0468ED             0124*  ;         player position variables
0468ED             0125*  ; destroys: everything except index registers
0468ED             0126*  ; outputs: moving enemies
0468ED             0127*  en_nav:
0468ED             0128*  ; set velocity and orientation by player's relative location
0468ED             0129*  ; move enemies y-axis
0468ED             0130*  ; where is player relative to us?
0468ED CD C3 69 04 0131*      call orientation_to_player
0468F1             0132*  ;    h.l 16.8 fixed angle256 to player
0468F1             0133*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
0468F1             0134*  ; is player above or below us?
0468F1 ED 53 83 5B 0135*      ld (ude),de ; dy
       04          
0468F6 3A 85 5B 04 0136*      ld a,(ude+2) ; deu
0468FA 17          0137*      rla ; shift sign bit into carry
0468FB 30 C6       0138*      jr nc,en_nav_zigzag ; player is below,evade
0468FD             0139*  ; player is even or above,so home in on current heading
0468FD FD 2F 1A    0140*      ld (iy+sprite_heading),hl ; save sprite heading
046900             0141*  
046900             0142*  ; we land here from zig-zag program so as not to
046900             0143*  ; redundantly save orientation and heading
046900             0144*  en_nav_computevelocities:
046900             0145*  ; set x/y component velocities based on bearing to player
046900 FD 2A FB 52 0146*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
046905 E5          0147*      push hl ; we need it back to set rotation frame
046906 FD 17 17    0148*      ld de,(iy+sprite_vel)
046909 CD 11 5E 04 0149*      call polar_to_cartesian
04690D FD 0F 11    0150*      ld (iy+sprite_xvel),bc ; save x-velocity component
046910 FD 1F 14    0151*      ld (iy+sprite_yvel),de ; save y-velocity component
046913             0152*  ; change the animation frame to match heading
046913             0153*  ; by dividng the heading by 8
046913 E1          0154*      pop hl ; get back Heading
046914 7C          0155*      ld a,h
046915 CB 3F       0156*      srl a
046917 CB 3F       0157*      srl a
046919 CB 3F       0158*      srl a
04691B CD 78 5A 04 0159*      call vdu_sprite_select_frame
04691F             0160*  ; update sprite position
04691F             0161*  move_enemy_sprite:
04691F FD 27 0B    0162*      ld hl,(iy+sprite_x)
046922 FD 17 11    0163*      ld de,(iy+sprite_xvel)
046925 19          0164*      add hl,de
046926 FD 2F 0B    0165*      ld (iy+sprite_x),hl
046929             0166*  
046929 FD 27 0E    0167*      ld hl,(iy+sprite_y)
04692C FD 17 14    0168*      ld de,(iy+sprite_yvel)
04692F 19          0169*      add hl,de
046930 FD 2F 0E    0170*      ld (iy+sprite_y),hl
046933 C9          0171*      ret
046934             0172*  
046934             0173*  ; ; TODO: IMPLEMENT THIS PROPERLY
046934             0174*  ; move_enemy_sprite:
046934             0175*  ; ; x-axis movement first
046934             0176*  ;     ld hl,(iy+sprite_x)
046934             0177*  ;     push hl ; save pre-move position
046934             0178*  ;     pop bc ; to detect screen edge collision
046934             0179*  ;     ld de,(iy+sprite_xvel)
046934             0180*  ;     add hl,de ;compute new x position
046934             0181*  ;     ld (iy+sprite_x),hl ; store it
046934             0182*  ;     and a ; clear the carry flag
046934             0183*  ;     sbc hl,bc ; test which direction was our movement
046934             0184*  ;     jr z,@move_y ; zero flag means no horizontal movement
046934             0185*  ;     jp p,@move_right ; sign positive means moved right
046934             0186*  ; @move_left: ; otherwise we moved left
046934             0187*  ;     jr c,@move_y ; move left,no wraparound |C1 N1 PV1 H1 Z0 S1|A=00 HL=FF00 BC=0100 DE=FF00
046934             0188*  ;     ld hl,0x000000   ; move left,with wraparound |C0 N1 PV0 H0 Z0 S1|A=00 HL=FF00 BC=0000 DE=FF00
046934             0189*  ;     ld (iy+sprite_x),hl ; set x position to left edge of screen
046934             0190*  ;     ld a,#20 ; west
046934             0191*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
046934             0192*  ;     jr @move_y
046934             0193*  ; @move_right:
046934             0194*  ;     jr nc,@move_y ; move right,no wraparound |C0 N1 PV1 H0 Z0 S0|A=00 HL=0100 BC=FE00 DE=0100
046934             0195*  ;     ; move right,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
046934             0196*  ;     ld l,0x00
046934             0197*  ;     ld a,(iy+sprite_dim_x)
046934             0198*  ;     ld h,a
046934             0199*  ;     ld a,0x00
046934             0200*  ;     sub h
046934             0201*  ;     ld h,a
046934             0202*  ;     ld (iy+sprite_x),hl ; set x position to right edge of screen
046934             0203*  ;     ld a,0x02 ; east
046934             0204*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
046934             0205*  ; @move_y:
046934             0206*  ;     ld hl,(iy+sprite_y)
046934             0207*  ;     ld b,h ; save pre-move position
046934             0208*  ;     ld c,l ; to detect screen edge collision
046934             0209*  ;     ld de,(iy+sprite_yvel)
046934             0210*  ;     add hl,de ;compute new y position
046934             0211*  ;     ld (iy+sprite_y),hl ; store it
046934             0212*  ;     and a ; clear the carry flag
046934             0213*  ;     sbc hl,bc ; test which direction was our movement
046934             0214*  ;     jr z,@move_ret ; zero flag means no vertical movement
046934             0215*  ;     jp p,@move_dn ; sign positive means moved down
046934             0216*  ; @move_up:
046934             0217*  ;     add hl,bc ; get back new y position
046934             0218*  ;     ld de,0x5000 ; top edge of visible screen
046934             0219*  ;     and a ; clear the carry flag
046934             0220*  ;     sbc hl,de
046934             0221*  ;     jr nc,@move_ret ; move up,no wraparound |C0 N1 PV0 H0 Z1 S0|A=00 HL=0000 BC=5100 DE=5000
046934             0222*  ;     ; move up,with wraparound |C1 N1 PV1 H0 Z0 S1|A=00 HL=FF00 BC=5000 DE=5000
046934             0223*  ;     ld (iy+sprite_y),de ; set y position flush with top of screen
046934             0224*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
046934             0225*  ;     or 0x80 ; north
046934             0226*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
046934             0227*  ;     jr @move_ret
046934             0228*  ; @move_dn:
046934             0229*  ;     jr nc,@move_ret ; move down,no wraparound |C0 N1 PV0 H0 Z0 S0|A=00 HL=0100 BC=5100 DE=0100
046934             0230*  ;     ; move down,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
046934             0231*  ;     ld l,0x00
046934             0232*  ;     ld a,(iy+sprite_dim_y)
046934             0233*  ;     ld h,a
046934             0234*  ;     ld a,0x00
046934             0235*  ;     sub h
046934             0236*  ;     ld h,a
046934             0237*  ;     ld (iy+sprite_y),hl ; set y position flush with bottom of screen
046934             0238*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
046934             0239*  ;     or 0x08 ; south
046934             0240*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
046934             0241*  ; @move_ret:
046934             0242*  ;     ret
046934             0243*  
046934             0244*  ; ; ######### SPRITE BEHAVIOR ROUTINES #########
046934             0245*  ; ; each sprite in the table must have one of these defined
046934             0246*  ; ; but they need not be unique to a particular sprite
046934             0247*  ; ; these are jumped to from move_enemies_do_program,but could come from other places
046934             0248*  ; ; and have the option but not obligation to go back to move_enemies_loop_return
046934             0249*  ; ; but they can call anything they want between those two endpoints
046934             0250*  ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
046934             0251*  
046934             0252*  ; move_nop: ; does nothing but burn a few cycles changing the PC
046934             0253*  ;     jp move_enemies_loop_return
046934             0254*  
046934             0255*  ; move_explosion:
046934             0256*  ;     call animate_explosion
046934             0257*  ;     jp move_enemies_loop_return
046934             0258*  
046934             0259*  move_enemy_small:
046934 CD ED 68 04 0260*      call en_nav
046938 CD 5F 6A 04 0261*      call check_collisions
04693C C3 81 68 04 0262*      jp move_enemies_loop_return
046940             0263*  
046940             0264*  ; move_enemy_medium:
046940             0265*  ;     call en_nav
046940             0266*  ;     call check_collisions
046940             0267*  ;     jp move_enemies_loop_return
046940             0268*  
046940             0269*  ; move_enemy_large:
046940             0270*  ;     call en_nav
046940             0271*  ;     call check_collisions
046940             0272*  ;     jp move_enemies_loop_return
046940             0273*  
046940             0274*  ; move_landing_pad:
046940             0275*  ;     call move_active_tiles
046940             0276*  ;     call check_collisions
046940             0277*  ; ; is it time to launch an enemy?
046940             0278*  ;     ld hl,sprite_move_timer
046940             0279*  ;     dec (hl)
046940             0280*  ;     jp nz,move_enemies_loop_return
046940             0281*  ;     call enemy_init_from_landing_pad
046940             0282*  ;     ; reset move timer so can spawn again if player doesn't take us out
046940             0283*  ;     call rand_8     ; snag a random number
046940             0284*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
046940             0285*  ;     add a,64 ; range is now 64-127
046940             0286*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
046940             0287*  ;     jp move_enemies_loop_return
046940             0288*  
046940             0289*  enemy_init_from_landing_pad:
046940             0290*  ; get next available spriteId
046940 CD 22 53 04 0291*      call table_get_next_id
046944 D0          0292*      ret nc ; no carry means no free sprite slots, so we go home
046945             0293*  ; ix comes back with the pointer to the new sprite variables
046945 DD E5       0294*      push ix ; de picks it up when we're ready for the copy to the table
046947             0295*  ; a comes back with the spriteId of the new sprite
046947 32 9D 69 04 0296*      ld (@id),a
04694B             0297*  ; initialize the new sprite
04694B CD 15 5A 04 0298*      call vdu_sprite_select
04694F CD 28 5A 04 0299*      call vdu_sprite_clear_frames
046953 21 14 01 00 0300*      ld hl,BUF_SEEKER_000
046957 06 20       0301*      ld b,32
046959             0302*  @load_frames:
046959 C5          0303*      push bc
04695A E5          0304*      push hl
04695B CD 62 5B 04 0305*      call vdu_sprite_add_buff
04695F E1          0306*      pop hl
046960 23          0307*      inc hl
046961 C1          0308*      pop bc
046962 10 F5       0309*      djnz @load_frames
046964             0310*  ; copy coordinates of active sprite to new sprite
046964 FD 2A FB 52 0311*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
046969             0312*      ; ld hl,(iy+sprite_x)
046969             0313*  	; ld hl,0x008000 ; debug
046969             0314*  
046969 CD E5 5D 04 0315*      call rand_8
04696D 21 00 00 00 0316*      ld hl,0
046971 67          0317*      ld h,a
046972             0318*  
046972 22 A8 69 04 0319*      ld (@x),hl
046976             0320*      ; ld hl,(iy+sprite_y)
046976             0321*      ; ld hl,0x002000 ; debug
046976             0322*  
046976 CD E5 5D 04 0323*      call rand_8
04697A 21 00 00 00 0324*      ld hl,0
04697E 67          0325*      ld h,a
04697F             0326*  
04697F 22 AB 69 04 0327*      ld (@y),hl
046983 CD E5 5D 04 0328*      call rand_8
046987 E6 01       0329*      and %00000001 ; 50/50 chance of moving left or right on spanw
046989 32 C0 69 04 0330*      ld (@move_step),a
04698D             0331*  ; now copy to the table
04698D 21 9D 69 04 0332*      ld hl,@id ; address to copy from
046991 D1          0333*      pop de ; address to copy to (was ix)
046992 01 26 00 00 0334*      ld bc,table_bytes_per_record ; number of bytes to copy
046996 ED B0       0335*      ldir ; copy the records from local scratch to sprite table
046998             0336*  ; finally, make the new sprite visible
046998 CD 8B 5A 04 0337*      call vdu_sprite_show
04699C C9          0338*      ret
04699D 00          0339*  @id:               db     0x00 ; 1 bytes unique spriteId, zero-based
04699E 01          0340*  @type:             db enemy_small ; 1 bytes type of sprite as defined in enemies.inc
04699F 14 01 00    0341*  @base_bufferId:    dl BUF_SEEKER_000 ; 3 bytes bitmap bufferId
0469A2 34 69 04    0342*  @move_program:     dl move_enemy_small ; 3 bytes address of sprite's behavior subroutine
0469A5 03          0343*  @collisions:       db %00000011 ; 3 bytes collides with enemy and laser
0469A6 10          0344*  @dim_x:            db     0x10 ; 1 bytes sprite width in pixels
0469A7 10          0345*  @dim_y:            db     0x10 ; 1 bytes sprite height in pixels
0469A8 00 00 00    0346*  @x:                dl 0x000000 ; 1 bytes 16.8 fractional x position in pixels
0469AB 00 00 00    0347*  @y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
0469AE 00 00 00    0348*  @xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0469B1 00 00 00    0349*  @yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0469B4 80 02 00    0350*  @vel:              dl speed_seeker ; 3 bytes velocity, 16.8 fixed, pixels
0469B7 00 80 00    0351*  @heading:          dl 0x008000 ; 3 bytes sprite movement direction deg256 16.8 fixed
0469BA 00 80 00    0352*  @orientation:      dl 0x008000 ; 3 bytes orientation bits
0469BD 00          0353*  @animation:        db     0x00 ; 1 bytes current animation index, zero-based
0469BE 00          0354*  @animation_timer:  db     0x00 ; 1 bytes when hits zero, draw next animation
0469BF 01          0355*  @move_timer:       db     0x01 ; 1 bytes when zero, go to next move program, or step
0469C0 00          0356*  @move_step:        db     0x00 ; 1 bytes stage in a move program sequence, varies
0469C1 20          0357*  @points:           db     0x20 ; 1 bytes points awarded for killing this sprite type, BCD
0469C2 02          0358*  @shield_damage:    db     0x02 ; 1 bytes shield points deducted for collision, binary
0469C3             0359*  
0469C3             0360*  ; move_laser_turret:
0469C3             0361*  ; ; compute orientation to player
0469C3             0362*  ;     call orientation_to_player
0469C3             0363*  ; ; h.l 8.8 fixed angle256 to player
0469C3             0364*  ; ; bc and de as signed 16-bit integers
0469C3             0365*  ; ; representing delta-x/y *to* target respectively
0469C3             0366*  ;     ld (Bearing_t),hl
0469C3             0367*  ;     ld hl,0x0400
0469C3             0368*  ;     ld (Vp),hl
0469C3             0369*  ;     call targeting_computer
0469C3             0370*  ;     ld (sprite_heading),hl ; store bearing to player
0469C3             0371*  ; ; is it time to launch a fireball?
0469C3             0372*  ;     ld hl,sprite_move_timer
0469C3             0373*  ;     dec (hl)
0469C3             0374*  ;     jp nz,move_laser_turret_boilerplate
0469C3             0375*  ;     call fireballs_init
0469C3             0376*  ;     ; reset move timer so can fire again if player doesn't take us out
0469C3             0377*  ;     call rand_8     ; snag a random number
0469C3             0378*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
0469C3             0379*  ;     add a,64 ; range is now 64-127
0469C3             0380*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
0469C3             0381*  ; move_laser_turret_boilerplate:
0469C3             0382*  ;     call move_active_tiles
0469C3             0383*  ;     call check_collisions
0469C3             0384*  ;     jp move_enemies_loop_return
0469C3             0385*  
0469C3             0386*  ; fireballs_init:
0469C3             0387*  ;     call sprite_variables_to_stack
0469C3             0388*  
0469C3             0389*  ;     ld hl,fireballs
0469C3             0390*  ;     ld (sprite_base_bufferId),hl
0469C3             0391*  
0469C3             0392*  ;     ld hl,move_fireballs
0469C3             0393*  ;     ld (sprite_move_program),hl
0469C3             0394*  
0469C3             0395*  ;     ld a,%11 ; collides with laser and player
0469C3             0396*  ;     ; ld a,%10 ; collides with laser DEBUG
0469C3             0397*  ;     ld (iy+sprite_collisions),a
0469C3             0398*  
0469C3             0399*  ;     ld hl,(Vp)
0469C3             0400*  ;     ld (sprite_vel),hl
0469C3             0401*  ;     ld hl,(Vp_x)
0469C3             0402*  ;     ld (sprite_xvel),hl
0469C3             0403*  ;     ld hl,(Vp_y)
0469C3             0404*  ;     inc h ; account for ground movement
0469C3             0405*  ;     ld (sprite_yvel),hl
0469C3             0406*  
0469C3             0407*  ;     xor a ; zero a
0469C3             0408*  ;     ld (sprite_animation),a
0469C3             0409*  ;     ld (sprite_move_step),a
0469C3             0410*  ;     ld (sprite_move_timer),a
0469C3             0411*  
0469C3             0412*  ;     ld a,6 ; 1/10th of a second timer
0469C3             0413*  ;     ld (sprite_animation_timer),a
0469C3             0414*  
0469C3             0415*  ;     ld a,0x00 ; BCD
0469C3             0416*  ;     ld (sprite_points),a
0469C3             0417*  ;     ld a,1 ; binary
0469C3             0418*  ;     ld (sprite_shield_damage),a
0469C3             0419*  
0469C3             0420*  ;     call table_add_record ; plops that on the sprite stack for later
0469C3             0421*  ;     call sprite_variables_from_stack ; come back to where we started
0469C3             0422*  ;     ret
0469C3             0423*  
0469C3             0424*  ; move_fireballs:
0469C3             0425*  ;     call move_enemy_sprite ; move sprite
0469C3             0426*  ;     ld a,(sprite_screen_edge) ; check for collision with screen edge
0469C3             0427*  ;     and a ; if zero we're still within screen bounds
0469C3             0428*  ;     jr z,move_fireballs_alive
0469C3             0429*  ; ; otherwise kill sprite
0469C3             0430*  ;     ld a,%10000000 ; any bit set in high nibble means sprite will die
0469C3             0431*  ;     ld (iy+sprite_collisions),a
0469C3             0432*  ;     jp move_enemies_loop_return
0469C3             0433*  ; move_fireballs_alive:
0469C3             0434*  ;     ld a,(sprite_animation_timer)
0469C3             0435*  ;     dec a
0469C3             0436*  ;     ld (sprite_animation_timer),a
0469C3             0437*  ;     jr nz,move_fireballs_draw
0469C3             0438*  ;     ld a,(sprite_animation)
0469C3             0439*  ;     xor %1
0469C3             0440*  ;     ld (sprite_animation),a
0469C3             0441*  ;     ld a,6 ; 1/10th of a second timer
0469C3             0442*  ;     ld (sprite_animation_timer),a
0469C3             0443*  ;     ; fall through
0469C3             0444*  
0469C3             0445*  ; move_fireballs_draw:
0469C3             0446*  ;     call vdu_bmp_select
0469C3             0447*  ;     call vdu_bmp_draw
0469C3             0448*  ;     call check_collisions
0469C3             0449*  ;     jp move_enemies_loop_return
0469C3             0450*  
0469C3             0451*  ; compute orientation to player
0469C3             0452*  ; based on relative positions
0469C3             0453*  ; returns: h.l 16.8 fixed angle256 to player
0469C3             0454*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
0469C3             0455*  ;    representing delta-x/y *to* target respectively
0469C3             0456*  orientation_to_player:
0469C3 FD 2A FB 52 0457*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0469C8 FD E5       0458*      push iy ; so we can send it back intact
0469CA FD 07 0B    0459*      ld bc,(iy+sprite_x)
0469CD FD 17 0E    0460*      ld de,(iy+sprite_y)
0469D0 DD 2A 6E 66 0461*      ld ix,(player_x)
       04          
0469D5 FD 2A 71 66 0462*      ld iy,(player_y)
       04          
0469DA CD 5B 5E 04 0463*      call dxy168
0469DE CD C2 5E 04 0464*      call atan2_168game
0469E2 ED 4B B6 5E 0465*      ld bc,(dx168)
       04          
0469E7 ED 5B BC 5E 0466*      ld de,(dy168)
       04          
0469EC FD E1       0467*      pop iy ; restore table pointer
0469EE C9          0468*      ret
0469EF             0469*  
0469EF             0470*  
0469EF             0471*  ; targeting_computer scratch variables
0469EF 00 00       0472*  Bearing_t: dw #0000 ; 8.8 fixed
0469F1 00 00       0473*  Heading_t: dw #0000 ; 8.8 fixed
0469F3 00 00       0474*  Vp: dw #0000 ; 8.8 fixed
0469F5 00 00       0475*  Vp_x: dw #0000 ; 8.8 fixed
0469F7 00 00       0476*  Vp_y: dw #0000 ; 8.8 fixed
0469F9 00 00       0477*  Vt: dw #0000 ; 8.8 fixed
0469FB 00 00       0478*  Vt_x: dw #0000 ; 8.8 fixed
0469FD 00 00       0479*  Vt_y: dw #0000 ; 8.8 fixed
0469FF             0480*  
0469FF             0481*  
0469FF             0482*  ; ; Inputs:   see scratch variables
0469FF             0483*  ; ; Note:     a call to orientation_to_player provides these inputs
0469FF             0484*  ; ; Outputs:  h.l is the 16.8 fixed firing angle256
0469FF             0485*  ; ;           b.c and d.e are the 16.8 fixed x,y component projectile velocities
0469FF             0486*  ; ; https://old.robowiki.net/cgi-bin/robowiki?LinearTargeting
0469FF             0487*  ; targeting_computer:
0469FF             0488*  ; ; compute target velocity from x,y component velocities
0469FF             0489*  ;     ld bc,(player_xvel)
0469FF             0490*  ;     ld de,(player_yvel)
0469FF             0491*  ;     dec d ; account for vertical ground movement: b.c=player_xvel,d.e=player_yvel-1
0469FF             0492*  
0469FF             0493*  ;     call cartesian_to_polar ; b.c=Heading_t, d.e=Vt
0469FF             0494*  ;     ld (Heading_t),bc
0469FF             0495*  ;     ld (Vt),de
0469FF             0496*  
0469FF             0497*  ; ; compute Heading_t-Bearing_t
0469FF             0498*  ;     ld h,b
0469FF             0499*  ;     ld l,c
0469FF             0500*  ;     ld bc,(Bearing_t)
0469FF             0501*  ;     and a ; clear carry
0469FF             0502*  ;     sbc hl,bc ; h.l=Heading_t-Bearing_t
0469FF             0503*  
0469FF             0504*  ; ; compute sin(Heading_t-Bearing_t)
0469FF             0505*  ;     ld b,h
0469FF             0506*  ;     ld c,l
0469FF             0507*  ;     call sin_bc ; h.l=sin(Heading_t-Bearing_t)
0469FF             0508*  
0469FF             0509*  ; ; compute (Vt*sin(Heading_t-Bearing_t))
0469FF             0510*  ;     ex de,hl
0469FF             0511*  ;     ld bc,(Vt)
0469FF             0512*  ;     call BC_Mul_DE_88 ; h.l=(Vt*sin(Heading_t-Bearing_t))
0469FF             0513*  
0469FF             0514*  ; ; compute (Vt * sin(Heading_t-Bearing_t)) / Vp
0469FF             0515*  ;     ld b,h
0469FF             0516*  ;     ld c,l
0469FF             0517*  ;     ld de,(Vp)
0469FF             0518*  ;     call div_88 ; h.l=(Vt*sin(Heading_t-Bearing_t)) / Vp
0469FF             0519*  ; ; answer is in radians, convert to degrees256
0469FF             0520*  ;     ex de,hl
0469FF             0521*  ;     ld bc,#28BE ; 40.74=57.29578*256/360
0469FF             0522*  ;     call BC_Mul_DE_88
0469FF             0523*  
0469FF             0524*  ; ; add lead angle to target bearing
0469FF             0525*  ;     ld de,(Bearing_t)
0469FF             0526*  ;     add hl,de ; h.l=lead angle+target bearing
0469FF             0527*  ;     push hl
0469FF             0528*  
0469FF             0529*  ; ; compute component projectile velocities
0469FF             0530*  ;     ld b,h
0469FF             0531*  ;     ld c,l
0469FF             0532*  ;     ld de,(Vp)
0469FF             0533*  ;     call polar_to_cartesian ; b.c=Vp_x, d.e=Vp_y
0469FF             0534*  
0469FF             0535*  ;     ld (Vp_x),bc
0469FF             0536*  ;     ld (Vp_y),de
0469FF             0537*  ;     pop hl ; h.l=lead angle+target bearing
0469FF             0538*  ;     ret
0469FF             0539*  
0469FF             0540*  ; this routine vanquishes the enemy sprite
0469FF             0541*  ; and replaces it with an animated explosion
0469FF             0542*  ; we jump here instead of call because
0469FF             0543*  ; we want to return to differing locations in the loop
0469FF             0544*  ; depending on whether we're still sploding
0469FF             0545*  ; destroys: everything except index registers
0469FF             0546*  ; returns: an incandescent ball of debris and gas
0469FF             0547*  kill_nurple:
0469FF             0548*  ; ; tally up points
0469FF             0549*  ;     ld bc,0
0469FF             0550*  ;     ld a,(sprite_points)
0469FF             0551*  ;     ld e,a
0469FF             0552*  ;     ld d,0
0469FF             0553*  ;     ld hl,add_bcd_arg2
0469FF             0554*  ;     call set_bcd
0469FF             0555*  ;     ld hl,player_score
0469FF             0556*  ;     ld de,add_bcd_arg2
0469FF             0557*  ;     ld a,3 ; number of bytes to add
0469FF             0558*  ;     call add_bcd
0469FF             0559*  ; ; initialize explosion
0469FF             0560*  ; init_explosion:
0469FF             0561*  ;     ld hl,explosion
0469FF             0562*  ;     ld (sprite_base_bufferId),hl
0469FF             0563*  ;     ld hl,move_explosion
0469FF             0564*  ;     ld (sprite_move_program),hl
0469FF             0565*  ;     ld a,%00000000 ; collides with nothing
0469FF             0566*  ;     ld (iy+sprite_collisions),a
0469FF             0567*  ;     ld hl,0 ; north
0469FF             0568*  ;     ld (sprite_heading),hl
0469FF             0569*  ;     ld a,0x04 ; will decrement to 03
0469FF             0570*  ;     ld (sprite_animation),a
0469FF             0571*  ;     ld a,0x07 ; 7/60th of a second timer
0469FF             0572*  ;     ld (sprite_animation_timer),a
0469FF             0573*  ;     xor a
0469FF             0574*  ;     ld (sprite_move_timer),a
0469FF             0575*  ;     call vdu_bmp_select
0469FF             0576*  ; ; fall through to next_explosion
0469FF             0577*  ; next_explosion:
0469FF             0578*  ;     ld a,(sprite_animation)
0469FF             0579*  ;     dec a ; if rolled negative from zero,we're done sploding
0469FF             0580*  ;     jp m,done_explosion
0469FF             0581*  ;     ld (sprite_animation),a
0469FF             0582*  ;     ld a,0x7 ; 7/60th of a second timer
0469FF             0583*  ;     ld (sprite_animation_timer),a
0469FF             0584*  ; ; fall through to animate_explosion
0469FF             0585*  ; animate_explosion:
0469FF             0586*  ;     ld hl,sprite_y+1
0469FF             0587*  ;     inc (hl) ; move explosion down 1 pixel
0469FF             0588*  ;     jr z, done_explosion ; if wraparound to top of screen, kill explosion
0469FF             0589*  ;     ld hl,sprite_animation_timer
0469FF             0590*  ;     dec (hl) ; if timer is zero,we do next animation
0469FF             0591*  ;     jr z,next_explosion
0469FF             0592*  ;     ;otherwise we fall through to draw the current one
0469FF             0593*  ;     call vdu_bmp_select
0469FF             0594*  ;     call vdu_bmp_draw
0469FF             0595*  ;     ret ; now we go back to caller
0469FF             0596*  ; done_explosion:
0469FF 3E 80       0597*      ld a,%10000000 ; high bit set is non-specific kill-me flag
046A01 FD 2A FB 52 0598*      ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
046A06 FD 77 08    0599*      ld (iy+sprite_collisions),a
046A09 C9          0600*      ret ; now we go back to caller
046A0A             0601*  
046A0A             0602*  ; game_over:
046A0A             0603*  ;     jp new_game
046A0A             0604*  
046A0A             0605*  ; it's presumed we've already checked that laser is alive
046A0A             0606*  collision_enemy_with_laser:
046A0A DD 2A 97 6A 0607*      ld ix,(laser_x)
       04          
046A0F FD 2A 9A 6A 0608*      ld iy,(laser_y)
       04          
046A14 3A 95 6A 04 0609*      ld a,(laser_dim_x)
046A18 CB 2F       0610*      sra a ; divide by 2
046A1A F5          0611*      push af ; we need this later
046A1B             0612*      ; ld de,0
046A1B             0613*      ; ld d,a
046A1B             0614*      ; add ix,de
046A1B             0615*      ; add iy,de
046A1B 18 11       0616*      jr collision_enemy
046A1D             0617*  
046A1D             0618*  ; it's presumed we've already checked that player is alive
046A1D             0619*  collision_enemy_with_player:
046A1D DD 2A 6E 66 0620*      ld ix,(player_x)
       04          
046A22 FD 2A 71 66 0621*      ld iy,(player_y)
       04          
046A27 3A 6C 66 04 0622*      ld a,(player_dim_x)
046A2B             0623*  
046A2B             0624*      ; call dumpRegistersHex
046A2B             0625*  
046A2B CB 2F       0626*      sra a ; divide by 2
046A2D F5          0627*      push af ; we need this later
046A2E             0628*      ; ld de,0
046A2E             0629*      ; ld d,a
046A2E             0630*      ; add ix,de
046A2E             0631*      ; add iy,de
046A2E             0632*      ; fall through to collision_enemy
046A2E             0633*  
046A2E             0634*  ; compute the distance between the two sprites' centers
046A2E             0635*  ; inputs: bc and de as y0,x0 and y1,x1 respectively
046A2E             0636*  collision_enemy:
046A2E             0637*  ; back up iy because we need it as the sprite table pointer
046A2E FD E5       0638*      push iy
046A30 FD 2A FB 52 0639*      ld iy,(table_pointer)
       04          
046A35 FD 27 0B    0640*      ld hl,(iy+sprite_x)
046A38 FD 7E 09    0641*      ld a,(iy+sprite_dim_x)
046A3B CB 2F       0642*      sra a
046A3D F5          0643*      push af ; we need this later
046A3E             0644*      ; ld de,0
046A3E             0645*      ; ld d,a
046A3E             0646*      ; add hl,de
046A3E E5          0647*      push hl
046A3F C1          0648*      pop bc ; bc = x0
046A40 FD 27 0E    0649*      ld hl,(iy+sprite_y)
046A43 FD 7E 0A    0650*      ld a,(iy+sprite_dim_y)
046A46             0651*      ; sra a
046A46             0652*      ; ld de,0
046A46             0653*      ; ld d,a
046A46             0654*      ; add hl,de
046A46 EB          0655*      ex de,hl ; de = y0
046A47 F1          0656*      pop af ; TODO: srsly, this is the best way to do this?
046A48 FD E1       0657*      pop iy
046A4A F5          0658*      push af
046A4B             0659*  
046A4B             0660*      ; call dumpRegistersHex
046A4B             0661*  
046A4B CD 76 5E 04 0662*      call distance168
046A4F             0663*      ; CALL dumpRegistersHex
046A4F             0664*  ; ; subtract sum of radii from distance between centers
046A4F             0665*  ;     ld de,0
046A4F             0666*  ;     pop af ; radius of enemy sprite
046A4F             0667*  ;     ld e,a
046A4F             0668*  ;     pop af ; radius of player or laser sprite
046A4F             0669*  ;     add a,e
046A4F             0670*  ;     ld e,a
046A4F             0671*  ;     and a ; clear carry
046A4F             0672*  ;     sbc hl,de
046A4F             0673*  ;     jr c,collision_enemy_is
046A4F             0674*  ;     xor a
046A4F             0675*  ;     ret
046A4F             0676*  ; temp fix TODO: remove this
046A4F F1          0677*      pop af
046A50 F1          0678*      pop af
046A51 11 00 10 00 0679*      ld de,16*256
046A55 A7          0680*      and a
046A56 ED 52       0681*      sbc hl,de
046A58 38 02       0682*      jr c,collision_enemy_is
046A5A AF          0683*      xor a
046A5B             0684*      ; call dumpRegistersHex
046A5B C9          0685*      ret
046A5C             0686*  collision_enemy_is:
046A5C AF          0687*      xor a
046A5D 3C          0688*      inc a
046A5E             0689*      ; call dumpRegistersHex
046A5E C9          0690*      ret
046A5F             0691*  
046A5F             0692*  ; ; looks up what enemy sprite collides with
046A5F             0693*  ; ; detects collisions
046A5F             0694*  ; ; and sets things to sploding accordingly
046A5F             0695*  ; check_collisions:
046A5F             0696*  ;     ld a,(iy+sprite_collisions) ; snag what we collide with
046A5F             0697*  ;     and a ; if this is zero,
046A5F             0698*  ;     ret z ; there's nothing to do
046A5F             0699*  ;     and %01 ; do we collide with player?
046A5F             0700*  ;     jr z,move_enemies_laser ; if not,check laser collision
046A5F             0701*  ;     call collision_enemy_with_player ; otherwise see if we hit player
046A5F             0702*  ;     and a ; was there a collision?
046A5F             0703*  ;     jr z,move_enemies_laser ; if not,see if laser smacked us
046A5F             0704*  ; ; yes collision with player
046A5F             0705*  ;     ; deduct shield damage
046A5F             0706*  ;     ld hl,sprite_shield_damage
046A5F             0707*  ;     ld a,(player_shields)
046A5F             0708*  ;     sub (hl)
046A5F             0709*  ;     ld (player_shields),a
046A5F             0710*  ; ; if shields >= 0,player survives
046A5F             0711*  ;     jp p,check_collisions_kill_nurple
046A5F             0712*  ; ; otherwise update player status so it will die
046A5F             0713*  ;     ld a,(player_collisions)
046A5F             0714*  ;     or %10 ; sets bit 1,meaning player just died
046A5F             0715*  ;     ld (player_collisions),a
046A5F             0716*  ;     ; fall through
046A5F             0717*  ; check_collisions_kill_nurple:
046A5F             0718*  ; ; kill enemy and replace with explosion
046A5F             0719*  ;     call kill_nurple
046A5F             0720*  ;     ret ; and out
046A5F             0721*  
046A5F             0722*  check_collisions:
046A5F CD 1D 6A 04 0723*      call collision_enemy_with_player ; did we hit the player?
046A63 A7          0724*      and a ; was there a collision?
046A64 C8          0725*      ret z ; if not,we're done
046A65 CD FF 69 04 0726*      call kill_nurple ; otherwise kill enemy
046A69 C9          0727*      ret
046A6A             0728*  
046A6A             0729*  ; did we hit the laser?
046A6A             0730*  move_enemies_laser:
046A6A FD 7E 08    0731*      ld a,(iy+sprite_collisions) ; snag what we collide with again
046A6D E6 02       0732*      and %10 ; do we even collide with laser?
046A6F C8          0733*      ret z ; if not,we're out
046A70 3A 94 6A 04 0734*      ld a,(laser_collisions) ; is laser alive?
046A74 E6 01       0735*      and %1 ; if bit 0 is not set laser is dead
046A76 C8          0736*      ret z ; so we're out
046A77 CD 0A 6A 04 0737*      call collision_enemy_with_laser ; otherwise check for collision
046A7B A7          0738*      and a ; was there a collision?
046A7C C8          0739*      ret z ; if not,we're done
046A7D             0740*  ; otherwise we mark laser for termination and kill enemy
046A7D             0741*  ; update laser status so it will die
046A7D 3A 94 6A 04 0742*      ld a,(laser_collisions)
046A81 F6 02       0743*      or %10 ; bit 1 set means laser just died
046A83 32 94 6A 04 0744*      ld (laser_collisions),a
046A87 CD FF 69 04 0745*      call kill_nurple ; yes there was a collision,so kill enemy
046A8B C9          0746*      ret ; we're outta' here
046A8C             0066   	include "nurples/src/asm/laser.asm"
046A8C             0001*  ; ##### LASER SPRITE PARAMETERS #####
046A8C             0002*  ; uses the same offsets from its table base as the main sprite table:
046A8C             0003*  laser_start_variables: ; label marking beginning of table
046A8C 05          0004*  laser_id:               db table_max_records+1
046A8D 00          0005*  laser_type:             db     0x00 ; 1 bytes currently not used
046A8E 11 01 00    0006*  laser_base_bufferId:    dl BUF_LASER_A ; 3 bytes bitmap bufferId
046A91 00 00 00    0007*  laser_move_program:     dl 0x000000 ; 3 bytes not currently used
046A94 00          0008*  laser_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
046A95 00          0009*  laser_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
046A96 00          0010*  laser_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
046A97 00 00 00    0011*  laser_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
046A9A 00 00 00    0012*  laser_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
046A9D 00 00 00    0013*  laser_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
046AA0 00 F8 FF    0014*  laser_yvel:             dl 0xFFF800 ; 3 bytes y-component velocity, 16.8 fixed, pixels
046AA3 00 00 00    0015*  laser_vel:              dl 0x000000 ; 3 bytes not currently used
046AA6 00 00 00    0016*  laser_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
046AA9 00 00 00    0017*  laser_orientation:      dl 0x000000 ; 3 bytes not currently used
046AAC 00          0018*  laser_animation:        db     0x00 ; 1 bytes current sprite animation frame
046AAD 00          0019*  laser_animation_timer:  db     0x00 ; 1 bytes decremented every frame, when zero, advance animation
046AAE 00          0020*  laser_move_timer:       db     0x00 ; 1 bytes not currently used
046AAF 00          0021*  laser_move_step:        db     0x00 ; 1 bytes not currently used
046AB0 00          0022*  laser_points:           db     0x00 ; 1 bytes not currently used
046AB1 00          0023*  laser_shield_damage:    db     0x00 ; 1 bytes not currently used
046AB2             0024*  laser_end_variables: ; for when we want to traverse this table in reverse
046AB2             0025*  
046AB2             0026*  ; laser_control:
046AB2             0027*  ; ; is laser already active?
046AB2             0028*  ;     ld a,(laser_collisions)
046AB2             0029*  ;     and %00000001 ; bit zero is lit if laser is active
046AB2             0030*  ;     jr nz,laser_move ; move laser if not zero
046AB2             0031*  ; ; otherwise check if laser fired
046AB2             0032*  ;     in a,(#82) ; keyboard
046AB2             0033*  ;     and %00010000 ; bit 4 is lit if space bar pressed
046AB2             0034*  ;     ret z ; go back if laser not fired
046AB2             0035*  ; ; otherwise,FIRE ZEE LASER!!1111
046AB2             0036*  ; ; set laser status to active (set bit 0)
046AB2             0037*  ;     ld a,%1
046AB2             0038*  ;     ld (laser_collisions),a
046AB2             0039*  ; ; initialize laser position
046AB2             0040*  ;     ld a,(player_x+1) ; we only need the integer part
046AB2             0041*  ;     ; add a,6 ; horizontal center with player sprite
046AB2             0042*  ;     ld (laser_x+1),a ; store laser x coordinate
046AB2             0043*  ;     ld a,(player_y+1) ; we only need the integer part
046AB2             0044*  ;     add a,-6 ; set laser y a few pixels above player
046AB2             0045*  ;     ld (laser_y+1),a ; store laser y coordinate
046AB2             0046*  ;     ; fall through to laser_move
046AB2             0047*  
046AB2             0048*  ; laser_move:
046AB2             0049*  ; ; begin setting laser to active sprite
046AB2             0050*  ;     ld hl,lasers
046AB2             0051*  ;     ld (sprite_base_bufferId),hl
046AB2             0052*  ;     ld hl,0 ; north
046AB2             0053*  ;     ld (sprite_heading),hl
046AB2             0054*  ;     xor a ; laser has no animations yet :-(
046AB2             0055*  ;     ld (sprite_animation),a
046AB2             0056*  ;     ; we set position here for the time being as a default
046AB2             0057*  ;     ; in case the laser is flagged for deletion
046AB2             0058*  ;     ; load sprite_x with laser x position (we do y further down)
046AB2             0059*  ;     ld hl,(laser_x)
046AB2             0060*  ;     ld (sprite_x),hl
046AB2             0061*  ; ; did laser just die?
046AB2             0062*  ;     ld a,(laser_collisions)
046AB2             0063*  ;     bit 1,a ; z if laser didn't just die
046AB2             0064*  ;     jr z,laser_not_dead_yet
046AB2             0065*  ; ; yes laser died
046AB2             0066*  ;     call kill_laser
046AB2             0067*  ;     ret ; done
046AB2             0068*  ; laser_not_dead_yet:
046AB2             0069*  ; ; draw it
046AB2             0070*  ; ; update laser y position
046AB2             0071*  ;     ld hl,(laser_y) ; grab laser y position
046AB2             0072*  ;     ld de,(laser_yvel) ; snag laser y velocity
046AB2             0073*  ;     add hl,de ; add y velocity to y pos
046AB2             0074*  ;     ld (sprite_y),hl ; update laser y position
046AB2             0075*  ;     ld (laser_y),hl ; update laser y position
046AB2             0076*  ; ; are we at top of screen?
046AB2             0077*  ;     ld a,#51 ; top of visible screen plus a pixel
046AB2             0078*  ;     sub h ; no carry if above threshold
046AB2             0079*  ;     jr c,finally_draw_the_frikken_laser
046AB2             0080*  ;     ; if at top of screen,laser dies
046AB2             0081*  ;     call kill_laser
046AB2             0082*  ;     ret
046AB2             0083*  ; ; otherwise,finally draw the frikken laser
046AB2             0084*  ; finally_draw_the_frikken_laser:
046AB2             0085*  ;     call vdu_bmp_select
046AB2             0086*  ;     call vdu_bmp_draw
046AB2             0087*  ; ; all done
046AB2             0088*  ;     ret
046AB2             0089*  
046AB2             0090*  ; kill_laser:
046AB2             0091*  ; ; update status to inactive
046AB2             0092*  ;     xor a ; zero out a
046AB2             0093*  ;     ld (laser_collisions),a
046AB2             0094*  ;     ret
046AB2             0067   	; include "nurples/src/asm/temp.asm"
046AB2             0068   	include "nurples/src/asm/vdp.inc"
046AB2 00 00 00    0001*  keycode_ptr:	dl	0
046AB5 00 00 00    0002*  frame_ptr:		dl	0
046AB8 00 00 00    0003*  vk_code:		dl	0
046ABB 00 00 00    0004*  key_up:			dl	0
046ABE             0005*  
046ABE 00          0006*  keycode:		db	0
046ABF 00          0007*  vk:				db	0
046AC0             0008*  
046AC0 00          0009*  c_up:			db	0
046AC1 00          0010*  c_dn:			db	0
046AC2 00          0011*  c_lf:			db	0
046AC3 00          0012*  c_rt:			db	0
046AC4             0013*  
046AC4             0014*  VK_U: 			equ 150
046AC4             0015*  VK_D: 			equ 152
046AC4             0016*  VK_L: 			equ 154
046AC4             0017*  VK_R: 			equ 156
046AC4             0018*  
046AC4             0019*  ; ############# MY MODIFICATIONS / ADDITIONS #############
046AC4             0020*  
046AC4             0021*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
046AC4             0022*  ; ; VDU 23, 7: Scrolling
046AC4             0023*  ; ;     VDU 23, 7, extent, direction, speed: Scroll the screen
046AC4             0024*  ; ; inputs: a, extent; l, direction; h; speed
046AC4             0025*  ; vdu_scroll_down:
046AC4             0026*  ; 	ld (@extent),a
046AC4             0027*  ; 	ld (@dir),hl ; implicitly populates @speed
046AC4             0028*  ; 	ld hl,@cmd
046AC4             0029*  ; 	ld bc,@end-@cmd
046AC4             0030*  ; 	rst.lil $18     ;; Sending command to VDP
046AC4             0031*  ; 	ret
046AC4             0032*  ; @cmd:       db 23,7
046AC4             0033*  ; @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
046AC4             0034*  ; @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
046AC4             0035*  ; @speed:     db 0x00 ; pixels
046AC4             0036*  ; @end:		db 0x00 ; padding
046AC4             0037*  
046AC4             0038*  
046AC4             0039*  ; ####### ROKKY ORIGINAL STUFF BELOW, WITH SOME COMMENTARY BY ME
046AC4             0040*  
046AC4             0041*  vdu_init:
046AC4             0042*  ; TODO: this is technically MOS stuff,and should live in mos_api.inc
046AC4             0043*  ; Get pointers to the MOS sysvars we'll be using,and stash
046AC4             0044*  ; their addresses as scratch variables in program space
046AC4             0045*  	MOSCALL mos_sysvars
046AC4 3E 08       0001*M 			LD	A, function
046AC6 5B CF       0002*M 			RST.LIL	08h
046AC8 ED 22 05    0046*  	lea hl,ix+5
046ACB 22 B2 6A 04 0047*  	ld (keycode_ptr),hl
046ACF ED 22 17    0048*  	lea hl,ix+$17
046AD2 22 B8 6A 04 0049*  	ld  (vk_code),hl
046AD6 ED 22 18    0050*  	lea hl,ix+$18
046AD9 22 BB 6A 04 0051*  	ld (key_up),hl
046ADD DD 22 B5 6A 0052*  	ld (frame_ptr),ix
       04          
046AE2             0053*  ; ; set up a string of VDP commands and send them
046AE2             0054*  ; 	ld hl,vdu_init_cmd
046AE2             0055*  ; 	ld bc,vdu_init_end-vdu_init_cmd
046AE2             0056*  ; 	rst.lil $18
046AE2 C9          0057*  	ret
046AE3             0058*  ; vdu_init_cmd: db 22 ; set screen mode
046AE3             0059*  ; vdu_init_mode: db 0 ; presently self-modified in _main at startup
046AE3             0060*  ; 	db 23,1,0 ; Hide cursor
046AE3             0061*  ; 	db 23,0,$88 ; set keyboard mode?
046AE3             0062*  ; 	dw 250,33 ; no idea
046AE3             0063*  ; 	db 255 ; stumped here as well
046AE3             0064*  ; 	; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
046AE3             0065*  ; 	db 23,0,0xC0,0 ; 0 IS OFF
046AE3             0066*  ; vdu_init_end:
046AE3             0067*  
046AE3             0068*  vk_down:
046AE3 2A B8 6A 04 0069*  	ld hl,(vk_code)
046AE7 7E          0070*  	ld a,(hl)
046AE8             0071*  
046AE8 21 C0 6A 04 0072*  	ld hl,c_up
046AEC FE 96       0073*  	cp VK_U
046AEE 28 10       0074*  	jr z,@write
046AF0             0075*  
046AF0 23          0076*  	inc hl
046AF1 FE 98       0077*  	cp VK_D
046AF3 28 0B       0078*  	jr z,@write
046AF5             0079*  
046AF5 23          0080*  	inc hl
046AF6 FE 9A       0081*  	cp VK_L
046AF8 28 06       0082*  	jr z,@write
046AFA             0083*  
046AFA 23          0084*  	inc hl
046AFB FE 9C       0085*  	cp VK_R
046AFD 28 01       0086*  	jr z,@write
046AFF C9          0087*  	ret
046B00             0088*  @write:
046B00 3E 01       0089*  	ld a,1
046B02 77          0090*  	ld (hl),a
046B03 C9          0091*  	ret
046B04             0092*  
046B04             0093*  vk_up:
046B04 2A B8 6A 04 0094*  	ld hl,(vk_code)
046B08 7E          0095*  	ld a,(hl)
046B09             0096*  
046B09 21 C0 6A 04 0097*  	ld hl,c_up
046B0D FE 96       0098*  	cp VK_U
046B0F 28 10       0099*  	jr z,@write
046B11             0100*  
046B11 23          0101*  	inc hl
046B12 FE 98       0102*  	cp VK_D
046B14 28 0B       0103*  	jr z,@write
046B16             0104*  
046B16 23          0105*  	inc hl
046B17 FE 9A       0106*  	cp VK_L
046B19 28 06       0107*  	jr z,@write
046B1B             0108*  
046B1B 23          0109*  	inc hl
046B1C FE 9C       0110*  	cp VK_R
046B1E 28 01       0111*  	jr z,@write
046B20 C9          0112*  	ret
046B21             0113*  @write:
046B21 AF          0114*  	xor a
046B22 77          0115*  	ld (hl),a
046B23 C9          0116*  	ret
046B24             0117*  
046B24             0118*  
046B24             0119*  get_key:
046B24 AF          0120*  	xor a
046B25 32 BE 6A 04 0121*  	ld (keycode),a
046B29             0122*  
046B29 2A BB 6A 04 0123*  	ld hl,(key_up)
046B2D 7E          0124*  	ld a,(hl)
046B2E A7          0125*  	and a
046B2F 28 D3       0126*  	jr z,vk_up
046B31             0127*  
046B31 CD E3 6A 04 0128*  	call vk_down
046B35             0129*  
046B35 2A B2 6A 04 0130*  	ld hl,(keycode_ptr)
046B39 7E          0131*  	ld a,(hl)
046B3A 32 BE 6A 04 0132*  	ld (keycode),a
046B3E C9          0133*  	ret
046B3F             0134*  
046B3F             0135*  vsync:
046B3F 2A B5 6A 04 0136*  	ld hl,(frame_ptr)
046B43 7E          0137*  	ld a,(hl)
046B44 F5          0138*  @wait:	push af
046B45 E5          0139*  	push hl
046B46 CD 24 6B 04 0140*  	call get_key
046B4A E1          0141*  	pop hl
046B4B F1          0142*  	pop af
046B4C BE          0143*  	cp (hl)
046B4D 28 F5       0144*  	jr z,@wait
046B4F C9          0145*  	ret
046B50             0146*  
046B50             0147*  ; cursor_on:
046B50             0148*  ; 	ld hl,@cmd
046B50             0149*  ; 	ld bc,@end-@cmd
046B50             0150*  ; 	rst.lil $18
046B50             0151*  ; 	ret
046B50             0152*  ; @cmd:
046B50             0153*  ; 	db 23,1,1
046B50             0154*  ; @end:
046B50             0155*  
046B50             0156*  ; cursor_off:
046B50             0157*  ; 	ld hl,@cmd
046B50             0158*  ; 	ld bc,@end-@cmd
046B50             0159*  ; 	rst.lil $18
046B50             0160*  ; 	ret
046B50             0161*  ; @cmd:
046B50             0162*  ; 	db 23,1,0
046B50             0163*  ; @end:
046B50             0164*  
046B50             0165*  vdu_close:
046B50 21 5B 6B 04 0166*  	ld hl,@cmd
046B54 01 0A 00 00 0167*  	ld bc,@end-@cmd
046B58 5B DF       0168*  	rst.lil $18
046B5A C9          0169*  	ret
046B5B             0170*  @cmd:
046B5B 16 00       0171*  	db 22,0
046B5D 11 07 11 80 0172*  	db 17,7,17,$80
046B61 17 01 01    0173*  	db 23,1,1
046B64 0C          0174*  	db 12
046B65             0175*  @end:
046B65             0176*  
046B65             0177*  
046B65             0178*  ; vdu_vblank:		PUSH 	IX			; Wait for VBLANK interrupt
046B65             0179*  ; 			MOSCALL	mos_sysvars		; Fetch pointer to system variables
046B65             0180*  ; 			LD	A, (IX + sysvar_time + 0)
046B65             0181*  ; @wait:			CP 	A, (IX + sysvar_time + 0)
046B65             0182*  ; 			JR	Z, @wait
046B65             0183*  ; 			POP	IX
046B65             0184*  ; 			RET
046B65             0069   
046B65 48 65 6C 6C 0070   hello_world: defb "Hello, World!\n\r",0
       6F 2C 20 57 
       6F 72 6C 64 
       21 0A 0D 00 
046B75             0071   
046B75             0072   init:
046B75             0073   ; ; set fonts
046B75             0074   ; 	ld hl,font_nurples
046B75             0075   ; 	ld b,144 ; loop counter for 96 chars
046B75             0076   ; 	ld a,32 ; first char to define (space)
046B75             0077   ; @loop:
046B75             0078   ; 	push bc
046B75             0079   ; 	push hl
046B75             0080   ; 	push af
046B75             0081   ; 	call vdu_define_character
046B75             0082   ; 	pop af
046B75             0083   ; 	inc a
046B75             0084   ; 	pop hl
046B75             0085   ; 	ld de,8
046B75             0086   ; 	add hl,de
046B75             0087   ; 	pop bc
046B75             0088   ; 	djnz @loop
046B75             0089   
046B75             0090   ; set up the display
046B75 3E 08       0091       ld a,8
046B77 CD EC 56 04 0092       call vdu_set_screen_mode
046B7B AF          0093       xor a
046B7C CD 1B 58 04 0094       call vdu_set_scaling
046B80 01 20 00 00 0095   	ld bc,32
046B84 11 10 00 00 0096   	ld de,16
046B88 CD 7C 57 04 0097   	call vdu_set_gfx_origin
046B8C             0098   
046B8C CD C4 6A 04 0099   	call vdu_init ; grab a bunch of sysvars and stuff
046B90 CD 86 58 04 0100   	call cursor_off
046B94             0101   
046B94             0102   ; ; TESTING SOME MATHS
046B94             0103   ; 	ld bc,0x00A000 ; 160
046B94             0104   ; 	ld de,0x007800 ; 120
046B94             0105   ; 	ld ix,0x011F80 ; 287.5
046B94             0106   ; 	ld iy,0xFF9B2A ; -100.836
046B94             0107   ; 	;  hl=0x00FF00 255
046B94             0108   ; 	call distance168
046B94             0109   ; 	call dumpRegistersHex
046B94             0110   ; 	halt
046B94             0111   ; ; END TESTING SOME MATHS
046B94             0112   
046B94             0113   ; ; print a hello message
046B94             0114   ; 	ld hl,hello_world
046B94             0115   ; 	call printString
046B94             0116   
046B94             0117   ; load the bitmaps
046B94 CD 60 00 04 0118   	call bmp2_init
046B98             0119   
046B98             0120   ; initialize the first level
046B98 AF          0121   	xor a
046B99 32 5F 67 04 0122   	ld (cur_level),a
046B9D CD E7 67 04 0123   	call init_level
046BA1             0124   
046BA1             0125   ; set gfx viewport to scrolling window
046BA1 01 00 00 00 0126   	ld bc,0
046BA5 11 00 00 00 0127   	ld de,0
046BA9 DD 21 FF 00 0128   	ld ix,255
       00          
046BAE FD 21 DF 00 0129   	ld iy,239-16
       00          
046BB3 CD 22 57 04 0130   	call vdu_set_gfx_viewport
046BB7             0131   
046BB7             0132   ; initialize sprites
046BB7 CD 41 5B 04 0133   	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
046BBB AF          0134   	xor a
046BBC             0135   @sprite_loop:
046BBC F5          0136   	push af
046BBD CD 15 5A 04 0137   	call vdu_sprite_select
046BC1 21 00 01 00 0138   	ld hl,BUF_0TILE_EMPTY ; can be anything, but why not blank?
046BC5 CD 62 5B 04 0139   	call vdu_sprite_add_buff
046BC9 F1          0140   	pop af
046BCA 3C          0141   	inc a
046BCB FE 05       0142   	cp table_max_records+1 ; tack on sprites for player and laser
046BCD 20 ED       0143   	jr nz,@sprite_loop
046BCF 3C          0144   	inc a
046BD0 CD 49 5A 04 0145   	call vdu_sprite_activate
046BD4             0146   
046BD4             0147   ; define player sprite
046BD4 3E 10       0148   	ld a,16
046BD6 CD 15 5A 04 0149   	call vdu_sprite_select
046BDA CD 28 5A 04 0150   	call vdu_sprite_clear_frames
046BDE 21 34 01 00 0151   	ld hl,BUF_SHIP_0L
046BE2 01 03 00 00 0152   	ld bc,3 ; three bitmaps for player ship
046BE6             0153   @sprite_player_loop:
046BE6 C5          0154   	push bc
046BE7 E5          0155   	push hl
046BE8 CD 62 5B 04 0156   	call vdu_sprite_add_buff
046BEC E1          0157   	pop hl
046BED 23          0158   	inc hl
046BEE C1          0159   	pop bc
046BEF 10 F5       0160   	djnz @sprite_player_loop
046BF1 CD 8B 5A 04 0161   	call vdu_sprite_show
046BF5             0162   
046BF5             0163   ; initialize player
046BF5 CD 89 66 04 0164   	call player_init
046BF9             0165   
046BF9             0166   ; spawn an enemy sprite
046BF9 06 04       0167   	ld b,table_max_records
046BFB             0168   @spawn_enemy_loop:
046BFB C5          0169   	push bc
046BFC CD 40 69 04 0170   	call enemy_init_from_landing_pad
046C00 C1          0171   	pop bc
046C01 10 F8       0172   	djnz @spawn_enemy_loop
046C03             0173   
046C03 C9          0174   	ret
046C04             0175   
046C04             0176   ; new_game:
046C04             0177   ; ; ###### INITIALIZE GAME #######
046C04             0178   ; ; clear the screen
046C04             0179   ;     ld a,3
046C04             0180   ;     out (81h),a
046C04             0181   
046C04             0182   ; ; reset the sprite table
046C04             0183   ;     xor a
046C04             0184   ;     ld (table_active_sprites),a
046C04             0185   ;     ld hl,table_limit
046C04             0186   ;     ld (table_base),hl
046C04             0187   ;     ld (table_pointer),hl
046C04             0188   
046C04             0189   ; ; draw a starfield over the entire screen
046C04             0190   ;     ld b,#50 ; first row of visible screen
046C04             0191   ; new_game_draw_stars_loop:
046C04             0192   ;     push bc
046C04             0193   ;     call draw_stars
046C04             0194   ;     pop bc
046C04             0195   ;     ld a,#10
046C04             0196   ;     add a,b
046C04             0197   ;     ld b,a
046C04             0198   ;     jr nz,new_game_draw_stars_loop
046C04             0199   
046C04             0200   ; ; ; print a welcome message
046C04             0201   ; ;     ld de,msg_welcome
046C04             0202   ; ;     ld hl,#581C
046C04             0203   ; ;     ld c,218 ; a bright pastel purple d677e3
046C04             0204   ; ;     call print_string
046C04             0205   
046C04             0206   ; ; push all that to frame buffer
046C04             0207   ;     ld a,#01 ; send video to frame buffer
046C04             0208   ;     out (81h),a
046C04             0209   
046C04             0210   ; ; reset score, lives, shields
046C04             0211   ;     xor a
046C04             0212   ;     ld hl,player_score
046C04             0213   ;     ld (hl),a ; player_score 0
046C04             0214   ;     inc hl
046C04             0215   ;     ld (hl),a ; player_score 1
046C04             0216   ;     inc hl
046C04             0217   ;     ld (hl),a ; player_score 3
046C04             0218   ;     inc hl
046C04             0219   ;     ld a,16
046C04             0220   ;     ld (hl),a ; player_shields
046C04             0221   ;     inc hl
046C04             0222   ;     ld (hl),a ; player_max_shields
046C04             0223   ;     inc hl
046C04             0224   ;     ld a,3
046C04             0225   ;     ld (hl),a ; player_ships
046C04             0226   ;     inc hl
046C04             0227   
046C04             0228   ; ; initialize first level
046C04             0229   ;     ld a,1 ; levels are zero-based, so this will wrap around
046C04             0230   ;     ld (cur_level),a
046C04             0231   ;     ld a,3 ; set max enemy sprites to easy street
046C04             0232   ;     ; ld a,64 ; DEBUG: BRING IT
046C04             0233   ;     ld (max_enemy_sprites),a
046C04             0234   ;     call dt_next_level
046C04             0235   ;     call dt
046C04             0236   
046C04             0237   ; ; spawn our intrepid hero
046C04             0238   ;     call player_init
046C04             0239   
046C04             0240   ; ; #### BEGIN GAME VARIABLES ####
046C04             0241   speed_seeker: equ 0x000280 ; 2.5 pixels per frame
046C04             0242   speed_player: equ 0x000300 ; 3 pixels per frame
046C04             0243   
046C04             0244   main:
046C04             0245   ; move the background down one pixel
046C04 3E 02       0246   	ld a,2 ; current gfx viewport
046C06 2E 02       0247   	ld l,2 ; direction=down
046C08 26 01       0248   	ld h,1 ; speed=1 px
046C0A CD 5F 58 04 0249   	call vdu_scroll_down
046C0E             0250   
046C0E             0251   ; scroll tiles
046C0E CD 6C 67 04 0252   	call tiles_plot
046C12             0253   
046C12             0254   ; get player input and update sprite position
046C12 CD C6 66 04 0255   	call player_input
046C16             0256   
046C16             0257   ; move enemies
046C16 CD 4E 68 04 0258   	call move_enemies
046C1A             0259   
046C1A             0260   ; wait for the next vsync
046C1A CD 3F 6B 04 0261   	call vsync
046C1E             0262   
046C1E             0263   ; poll keyboard
046C1E 3E 08       0264       ld a, $08                           ; code to send to MOS
046C20 5B CF       0265       rst.lil $08                         ; get IX pointer to System Variables
046C22             0266   
046C22 DD 7E 05    0267       ld a, (ix + $05)                    ; get ASCII code of key pressed
046C25 FE 1B       0268       cp 27                               ; check if 27 (ascii code for ESC)
046C27 CA 2F 6C 04 0269       jp z, main_end                     ; if pressed, jump to exit
046C2B             0270   
046C2B C3 04 6C 04 0271       jp main
046C2F             0272   
046C2F             0273   main_end:
046C2F CD 78 58 04 0274       call cursor_on
046C33 C9          0275   	ret
046C34             0276   
046C34             0277   
046C34             0278   ; ; #### BEGIN GAME MAIN LOOP ####
046C34             0279   ; main_loop:
046C34             0280   ; ; ; debug: start execution counter
046C34             0281   ; ;     ld a,1
046C34             0282   ; ;     out (#e0),a ; start counting instructions
046C34             0283   
046C34             0284   ; ; refresh background from frame buffer
046C34             0285   ;     ld a,#02
046C34             0286   ;     out (81h),a
046C34             0287   ;     call move_background ; now move it
046C34             0288   ;     ld a,#01
046C34             0289   ;     out (81h),a ; save it back to buffer
046C34             0290   ; ; do all the things
046C34             0291   ;     call move_enemies
046C34             0292   ;     call player_move
046C34             0293   ;     call laser_control
046C34             0294   ;     call print_score
046C34             0295   ;     call draw_shields
046C34             0296   ;     call draw_lives
046C34             0297   ; ; ; debug: stop execution counter and print results
046C34             0298   ; ;     ld a,0
046C34             0299   ; ;     out (#e0),a ; stop counting instructions
046C34             0300   
046C34             0301   ; ; ; debug: start execution counter
046C34             0302   ; ;     ld a,1
046C34             0303   ; ;     out (#e0),a ; start counting instructions
046C34             0304   
046C34             0305   ;     call vsync
046C34             0306   ; ; ; debug: stop execution counter and print results
046C34             0307   ; ;     ld a,0
046C34             0308   ; ;     out (#e0),a ; stop counting instructions
046C34             0309   
046C34             0310   ;     jr main_loop
046C34             0311   ; #### END GAME MAIN LOOP ####
046C34             0312   
046C34             0313   ; draws the player's shields level
046C34             0314   ; draw_shields:
046C34             0315   ; TODO: Agonize this routine
046C34             0316   ; ; prep the loop to draw the bars
046C34             0317   ;     ld a,(player_shields) ; snag shields
046C34             0318   ;     and a
046C34             0319   ;     ret z ; don't draw if zero shields
046C34             0320   ; ; set loop counter and drawing position
046C34             0321   ;     ld b,a ; loop counter
046C34             0322   ;     ld hl,#5300+48+12
046C34             0323   ; ; set color based on bars remaining
046C34             0324   ;     ld c,103 ; bright green 28fe0a
046C34             0325   ;     cp 9
046C34             0326   ;     jp p,draw_shields_loop
046C34             0327   ;     ld c,74 ; bright yellow eafe5b
046C34             0328   ;     cp 3
046C34             0329   ;     jp p,draw_shields_loop
046C34             0330   ;     ld c,28 ; bright red fe0a0a
046C34             0331   ; draw_shields_loop:
046C34             0332   ;     push bc ; yup,outta
046C34             0333   ;     push hl ; registers again
046C34             0334   ;     ; ld a,#A8 ; ,168
046C34             0335   ;     ld a,10 ; ,168 ; we renumber because we don't use the full charset
046C34             0336   ;     ; call draw_char
046C34             0337   ;     call draw_num ; we nuked draw_char for the time being
046C34             0338   ;     pop hl
046C34             0339   ;     ld a,8
046C34             0340   ;     add a,l
046C34             0341   ;     ld l,a
046C34             0342   ;     pop bc
046C34             0343   ;     djnz draw_shields_loop
046C34             0344       ; ret
046C34             0345   
046C34             0346   ; prints the player's score
046C34             0347   ; print_score:
046C34             0348   ; TODO: Agonize this
046C34             0349   ; ; draw score (we do it twice for a totally unecessary drop-shadow effect)
046C34             0350   ;     ld c,42 ; dark orange b74400
046C34             0351   ;     ld hl,#5200+1+8+6*6
046C34             0352   ;     ld a,3 ; print 6 bdc digits
046C34             0353   ;     ld de,player_score
046C34             0354   ;     call print_num
046C34             0355   
046C34             0356   ;     ld c,58 ; golden yellow fec10a
046C34             0357   ;     ld hl,#5100+8+6*6
046C34             0358   ;     ld a,3 ; print 6 bdc digits
046C34             0359   ;     ld de,player_score
046C34             0360   ;     call print_num
046C34             0361       ; ret
046C34             0362   
046C34             0363   ; draw_lives:
046C34             0364   ;     ld hl,player_small ; make small yellow ship the active sprite
046C34             0365   ;     ld (sprite_base_bufferId),hl
046C34             0366   ;     ; ld a,#80 ; northern orientation
046C34             0367   ;     ; ld (sprite_orientation),a
046C34             0368   ;     ld hl,0 ; north
046C34             0369   ;     ld (sprite_heading),hl
046C34             0370   ;     xor a
046C34             0371   ;     ld (sprite_animation),a
046C34             0372   ;     ld a,#56 ; top of visible screen
046C34             0373   ;     ld (sprite_y+1),a
046C34             0374   ;     call vdu_bmp_select
046C34             0375   ;     ld a,(player_ships)
046C34             0376   ;     dec a ; we draw one fewer ships than lives
046C34             0377   ;     ret z ; nothing to draw here, move along
046C34             0378   ;     ld b,a ; loop counter
046C34             0379   ;     ld a,256-16 ; initial x position
046C34             0380   ; draw_lives_loop:
046C34             0381   ;     ld (sprite_x+1),a
046C34             0382   ;     push af
046C34             0383   ;     push bc
046C34             0384   ;     call vdu_bmp_draw
046C34             0385   ;     pop bc
046C34             0386   ;     pop af
046C34             0387   ;     sub 10
046C34             0388   ;     djnz draw_lives_loop
046C34             0389   ;     ret
