PC     Output      Line
040000             0001       include "pingo/src/asm/mos_api.asm"
040000             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.asm
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
040000             0005*  ;			Added MOS error codes for return in HL
040000             0006*  ; Created:	03/08/2022
040000             0007*  ; Last Updated:	10/08/2023
040000             0008*  ;
040000             0009*  ; Modinfo:
040000             0010*  ; 05/08/2022:	Added mos_feof
040000             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0015*  ; 13/10/2022:	Added mos_oscli
040000             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0025*  ; 19/05/2023:	Added sysvar_scrMode
040000             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0027*  ; 03/08/2023:	Added mos_setkbvector
040000             0028*  ; 10/08/2023:	Added mos_getkbmap
040000             0029*  
040000             0030*  ; VDP control (VDU 23, 0, n)
040000             0031*  ;
040000             0032*  vdp_gp:				EQU 80h
040000             0033*  vdp_keycode:		EQU 81h
040000             0034*  vdp_cursor:			EQU	82h
040000             0035*  vdp_scrchar:		EQU	83h
040000             0036*  vdp_scrpixel:		EQU	84h
040000             0037*  vdp_audio:			EQU	85h
040000             0038*  vdp_mode:			EQU	86h
040000             0039*  vdp_rtc:			EQU	87h
040000             0040*  vdp_keystate:		EQU	88h
040000             0041*  vdp_logicalcoords:	EQU	C0h
040000             0042*  vdp_terminalmode:	EQU	FFh
040000             0043*  
040000             0044*  ; MOS high level functions
040000             0045*  ;
040000             0046*  mos_getkey:			EQU	00h
040000             0047*  mos_load:			EQU	01h
040000             0048*  mos_save:			EQU	02h
040000             0049*  mos_cd:				EQU	03h
040000             0050*  mos_dir:			EQU	04h
040000             0051*  mos_del:			EQU	05h
040000             0052*  mos_ren:			EQU	06h
040000             0053*  mos_mkdir:			EQU	07h
040000             0054*  mos_sysvars:		EQU	08h
040000             0055*  mos_editline:		EQU	09h
040000             0056*  mos_fopen:			EQU	0Ah
040000             0057*  mos_fclose:			EQU	0Bh
040000             0058*  mos_fgetc:			EQU	0Ch
040000             0059*  mos_fputc:			EQU	0Dh
040000             0060*  mos_feof:			EQU	0Eh
040000             0061*  mos_getError:		EQU	0Fh
040000             0062*  mos_oscli:			EQU	10h
040000             0063*  mos_copy:			EQU	11h
040000             0064*  mos_getrtc:			EQU	12h
040000             0065*  mos_setrtc:			EQU	13h
040000             0066*  mos_setintvector:	EQU	14h
040000             0067*  mos_uopen:			EQU	15h
040000             0068*  mos_uclose:			EQU	16h
040000             0069*  mos_ugetc:			EQU	17h
040000             0070*  mos_uputc:			EQU	18h
040000             0071*  mos_getfil:			EQU	19h
040000             0072*  mos_fread:			EQU	1Ah
040000             0073*  mos_fwrite:			EQU	1Bh
040000             0074*  mos_flseek:			EQU	1Ch
040000             0075*  mos_setkbvector:	EQU	1Dh
040000             0076*  mos_getkbmap:		EQU	1Eh
040000             0077*  
040000             0078*  ; MOS program exit codes
040000             0079*  ;
040000             0080*  EXIT_OK:				EQU  0;	"OK",
040000             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040000             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040000             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040000             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040000             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040000             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040000             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040000             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040000             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040000             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040000             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040000             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040000             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040000             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040000             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040000             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040000             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040000             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040000             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040000             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040000             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040000             0102*  ; FatFS file access functions
040000             0103*  ;
040000             0104*  ffs_fopen:			EQU	80h
040000             0105*  ffs_fclose:			EQU	81h
040000             0106*  ffs_fread:			EQU	82h
040000             0107*  ffs_fwrite:			EQU	83h
040000             0108*  ffs_flseek:			EQU	84h
040000             0109*  ffs_ftruncate:		EQU	85h
040000             0110*  ffs_fsync:			EQU	86h
040000             0111*  ffs_fforward:		EQU	87h
040000             0112*  ffs_fexpand:		EQU	88h
040000             0113*  ffs_fgets:			EQU	89h
040000             0114*  ffs_fputc:			EQU	8Ah
040000             0115*  ffs_fputs:			EQU	8Bh
040000             0116*  ffs_fprintf:		EQU	8Ch
040000             0117*  ffs_ftell:			EQU	8Dh
040000             0118*  ffs_feof:			EQU	8Eh
040000             0119*  ffs_fsize:			EQU	8Fh
040000             0120*  ffs_ferror:			EQU	90h
040000             0121*  
040000             0122*  ; FatFS directory access functions
040000             0123*  ;
040000             0124*  ffs_dopen:			EQU	91h
040000             0125*  ffs_dclose:			EQU	92h
040000             0126*  ffs_dread:			EQU	93h
040000             0127*  ffs_dfindfirst:		EQU	94h
040000             0128*  ffs_dfindnext:		EQU	95h
040000             0129*  
040000             0130*  ; FatFS file and directory management functions
040000             0131*  ;
040000             0132*  ffs_stat:			EQU	96h
040000             0133*  ffs_unlink:			EQU	97h
040000             0134*  ffs_rename:			EQU	98h
040000             0135*  ffs_chmod:			EQU	99h
040000             0136*  ffs_utime:			EQU	9Ah
040000             0137*  ffs_mkdir:			EQU	9Bh
040000             0138*  ffs_chdir:			EQU	9Ch
040000             0139*  ffs_chdrive:		EQU	9Dh
040000             0140*  ffs_getcwd:			EQU	9Eh
040000             0141*  
040000             0142*  ; FatFS volume management and system configuration functions
040000             0143*  ;
040000             0144*  ffs_mount:			EQU	9Fh
040000             0145*  ffs_mkfs:			EQU	A0h
040000             0146*  ffs_fdisk:			EQU	A1h
040000             0147*  ffs_getfree:		EQU	A2h
040000             0148*  ffs_getlabel:		EQU	A3h
040000             0149*  ffs_setlabel:		EQU	A4h
040000             0150*  ffs_setcp:			EQU	A5h
040000             0151*  
040000             0152*  ; File access modes
040000             0153*  ;
040000             0154*  fa_read:			EQU	01h
040000             0155*  fa_write:			EQU	02h
040000             0156*  fa_open_existing:	EQU	00h
040000             0157*  fa_create_new:		EQU	04h
040000             0158*  fa_create_always:	EQU	08h
040000             0159*  fa_open_always:		EQU	10h
040000             0160*  fa_open_append:		EQU	30h
040000             0161*  
040000             0162*  ; System variable indexes for api_sysvars
040000             0163*  ; Index into _sysvars in globals.asm
040000             0164*  ;
040000             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040000             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040000             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040000             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040000             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040000             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040000             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040000             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040000             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040000             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040000             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040000             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040000             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040000             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040000             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040000             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040000             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
040000             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0191*  
040000             0192*  ; Flags for the VPD protocol
040000             0193*  ;
040000             0194*  vdp_pflag_cursor:		EQU	00000001b
040000             0195*  vdp_pflag_scrchar:		EQU	00000010b
040000             0196*  vdp_pflag_point:		EQU	00000100b
040000             0197*  vdp_pflag_audio:		EQU	00001000b
040000             0198*  vdp_pflag_mode:			EQU	00010000b
040000             0199*  vdp_pflag_rtc:			EQU	00100000b
040000             0200*  
040000             0201*  ;
040000             0202*  ; FatFS structures
040000             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0204*  ;
040000             0205*  ; Object ID and allocation information (FFOBJID)
040000             0206*  ;
040000             0207*  ; Indexes into FFOBJID structure
040000             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040000             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040000             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
040000             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040000             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040000             0214*  ;
040000             0215*  ; File object structure (FIL)
040000             0216*  ;
040000             0217*  ; Indexes into FIL structure
040000             0218*  fil_obj:		EQU 0	; 15: Object identifier
040000             0219*  fil_flag:		EQU	15 	;  1: File status flags
040000             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
040000             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040000             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040000             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040000             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040000             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040000             0226*  ;
040000             0227*  ; Directory object structure (DIR)
040000             0228*  ; Indexes into DIR structure
040000             0229*  dir_obj:		EQU  0	; 15: Object identifier
040000             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
040000             0231*  dir_clust:		EQU	19	;  4: Current cluster
040000             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040000             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040000             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040000             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0236*  ;
040000             0237*  ; File information structure (FILINFO)
040000             0238*  ;
040000             0239*  ; Indexes into FILINFO structure
040000             0240*  filinfo_fsize:		EQU 0	;   4: File size
040000             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
040000             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
040000             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
040000             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
040000             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
040000             0246*  ;
040000             0247*  ; Macro for calling the API
040000             0248*  ; Parameters:
040000             0249*  ; - function: One of the function numbers listed above
040000             0250*  ;
040000             0251*  	MACRO	MOSCALL	function
040000             0252*  			LD	A, function
040000             0253*  			RST.LIL	08h
040000             0254*  	ENDMACRO
040000             0002   
040000             0003       .assume adl=1
040000             0004       .org 0x040000
040000             0005   
040000 C3 45 00 04 0006       jp start
040004             0007   
040004 FF FF FF FF 0008       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0009       .db "MOS"
040043 00          0010       .db 00h
040044 01          0011       .db 01h
040045             0012   
040045             0013   start:
040045 F5          0014       push af
040046 C5          0015       push bc
040047 D5          0016       push de
040048 DD E5       0017       push ix
04004A FD E5       0018       push iy
04004C             0019   
04004C CD 60 00 04 0020       call init
040050 CD D4 02 04 0021       call main
040054             0022   
040054             0023   exit:
040054             0024   
040054 FD E1       0025       pop iy
040056 DD E1       0026       pop ix
040058 D1          0027       pop de
040059 C1          0028       pop bc
04005A F1          0029       pop af
04005B 21 00 00 00 0030       ld hl,0
04005F             0031   
04005F C9          0032       ret
040060             0033   
040060             0034   init:
040060 AF          0035       xor a
040061 CD 38 05 04 0036       call vdu_set_scaling
040065 21 45 13 04 0037       ld hl,str_hello_world
040069 CD C0 0D 04 0038       call printString
04006D CD 72 00 04 0039       call cube_init
040071 C9          0040       ret
040072             0041   
040072             0042   ;   210 sid%=100: mid%=1: oid%=1: bmid1%=101: bmid2%=102
040072             0043   sid: equ 100
040072             0044   mid: equ 1
040072             0045   oid: equ 1
040072             0046   bmid1: equ 101
040072             0047   bmid2: equ 102
040072             0048   model_vertices: equ 8
040072             0049   model_indexes: equ 36
040072             0050   
040072             0051   obj_scale: equ 1*256
040072             0052   
040072             0053   ;   230 scene_width%=320: scene_height%=240
040072             0054   scene_width: equ 96
040072             0055   scene_height: equ 96
040072             0056   
040072             0057   ;   250 f=32767.0/256.0
040072             0058   ;   260 distx=0*f: disty=0*f: distz=-25*f
040072             0059   cam_f: equ 128 ; 32767/256
040072             0060   cam_distx: equ 0*cam_f
040072             0061   cam_disty: equ 2*cam_f
040072             0062   cam_distz: equ -25*cam_f
040072             0063   
040072             0064   ;   280 pi2=PI*2.0: f=32767.0/pi2
040072             0065   ;   290 anglex=0.0*f
040072             0066   cam_anglex: equ 0
040072             0067   
040072             0068   cube_init:
040072             0069   
040072             0070   ;   220 PRINT "Creating control structure"
040072 21 A3 14 04 0071       ld hl,str_create_control
040076 CD C0 0D 04 0072       call printString
04007A             0073   ccs:
04007A 21 88 00 04 0074       ld hl,@beg
04007E 01 0B 00 00 0075       ld bc,@end-@beg
040082 5B DF       0076       rst.lil $18
040084 C3 93 00 04 0077       jp @end
040088             0078   @beg:
040088             0079   ;   240 VDU 23,0, &A0, sid%; &49, 0, scene_width%; scene_height%; : REM Create Control Structure
040088 17 00 A0    0080       db 23,0,$A0
04008B 64 00       0081       dw sid
04008D 49 00       0082       db $49,0
04008F 60 00       0083       dw scene_width
040091 60 00       0084       dw scene_height
040093             0085   @end:
040093             0086   
040093             0087   ; set camera distance
040093 21 88 14 04 0088       ld hl,str_set_camera_distance
040097 CD C0 0D 04 0089       call printString
04009B             0090   scd:
04009B 21 A9 00 04 0091       ld hl,@beg
04009F 01 0D 00 00 0092       ld bc,@end-@beg
0400A3 5B DF       0093       rst.lil $18
0400A5 C3 B6 00 04 0094       jp @end
0400A9             0095   @beg:
0400A9             0096   ;   270 VDU 23,0, &A0, sid%; &49, 25, distx; disty; distz; : REM Set Camera XYZ Translation Distances
0400A9 17 00 A0    0097       db 23,0,$A0
0400AC 64 00       0098       dw sid
0400AE 49 19       0099       db $49,25
0400B0 00 00       0100       dw cam_distx
0400B2 00 01       0101       dw cam_disty
0400B4 80 F3       0102       dw cam_distz
0400B6             0103   @end:
0400B6             0104   
0400B6             0105   ; set camera x rotation
0400B6 21 6B 14 04 0106       ld hl,str_set_camera_x_rotation
0400BA CD C0 0D 04 0107       call printString
0400BE             0108   scxr:
0400BE 21 CC 00 04 0109       ld hl,@beg
0400C2 01 09 00 00 0110       ld bc,@end-@beg
0400C6 5B DF       0111       rst.lil $18
0400C8 C3 D5 00 04 0112       jp @end
0400CC             0113   @beg:
0400CC             0114   ;   300 VDU 23,0, &A0, sid%; &49, 18, anglex; : REM Set Camera X Rotation Angle
0400CC 17 00 A0    0115       db 23,0,$A0
0400CF 64 00       0116       dw sid
0400D1 49 12       0117       db $49,18
0400D3 00 00       0118       dw cam_anglex
0400D5             0119   @end:
0400D5             0120   
0400D5             0121   ;   310 PRINT "Sending vertices using factor ";factor
0400D5 21 57 14 04 0122       ld hl,str_send_vertices
0400D9 CD C0 0D 04 0123       call printString
0400DD             0124   sv:
0400DD 21 EB 00 04 0125       ld hl,@beg
0400E1 01 3B 00 00 0126       ld bc,@end-@beg
0400E5 5B DF       0127       rst.lil $18
0400E7 C3 26 01 04 0128       jp @end
0400EB             0129   @beg:
0400EB             0130   ;   320 VDU 23,0, &A0, sid%; &49, 1, mid%; model_vertices%; : REM Define Mesh Vertices
0400EB 17 00 A0    0131       db 23,0,$A0
0400EE 64 00       0132       dw sid
0400F0 49 01       0133       db $49,1
0400F2 01 00 08 00 0134       dw mid, model_vertices
0400F6 FF 7F 01 80 0135       dw 32767, -32767, 32767
       FF 7F       
0400FC FF 7F FF 7F 0136       dw 32767, 32767, 32767
       FF 7F       
040102 FF 7F 01 80 0137       dw 32767, -32767, -32767
       01 80       
040108 FF 7F FF 7F 0138       dw 32767, 32767, -32767
       01 80       
04010E 01 80 01 80 0139       dw -32767, -32767, 32767
       FF 7F       
040114 01 80 FF 7F 0140       dw -32767, 32767, 32767
       FF 7F       
04011A 01 80 01 80 0141       dw -32767, -32767, -32767
       01 80       
040120 01 80 FF 7F 0142       dw -32767, 32767, -32767
       01 80       
040126             0143   @end:
040126             0144   
040126             0145   ;   390 PRINT "Reading and sending vertex indexes"
040126 21 3D 14 04 0146       ld hl,str_set_mesh_vertex_indexes
04012A CD C0 0D 04 0147       call printString
04012E             0148   smvi:
04012E 21 3C 01 04 0149       ld hl,@beg
040132 01 53 00 00 0150       ld bc,@end-@beg
040136 5B DF       0151       rst.lil $18
040138 C3 8F 01 04 0152       jp @end
04013C             0153   @beg:
04013C             0154   ;   400 VDU 23,0, &A0, sid%; &49, 2, mid%; model_indexes%; : REM Set Mesh Vertex Indexes
04013C 17 00 A0    0155       db 23,0,$A0
04013F 64 00       0156       dw sid
040141 49 02       0157       db $49,2
040143 01 00 24 00 0158       dw mid, model_indexes
040147 04 00 02 00 0159       dw 4, 2, 0
       00 00       
04014D 02 00 07 00 0160       dw 2, 7, 3
       03 00       
040153 06 00 05 00 0161       dw 6, 5, 7
       07 00       
040159 01 00 07 00 0162       dw 1, 7, 5
       05 00       
04015F 00 00 03 00 0163       dw 0, 3, 1
       01 00       
040165 04 00 01 00 0164       dw 4, 1, 5
       05 00       
04016B 04 00 06 00 0165       dw 4, 6, 2
       02 00       
040171 02 00 06 00 0166       dw 2, 6, 7
       07 00       
040177 06 00 04 00 0167       dw 6, 4, 5
       05 00       
04017D 01 00 03 00 0168       dw 1, 3, 7
       07 00       
040183 00 00 02 00 0169       dw 0, 2, 3
       03 00       
040189 04 00 00 00 0170       dw 4, 0, 1
       01 00       
04018F             0171   @end:
04018F             0172   
04018F             0173   ;   470 PRINT "Sending texture coordinate indexes"
04018F 21 1E 14 04 0174       ld hl,str_set_texture_coordinates
040193 CD C0 0D 04 0175       call printString
040197             0176   stc:
040197 21 A5 01 04 0177       ld hl,@beg
04019B 01 0F 00 00 0178       ld bc,@end-@beg
04019F 5B DF       0179       rst.lil $18
0401A1 C3 B4 01 04 0180       jp @end
0401A5             0181   @beg:
0401A5             0182   ;   480 VDU 23,0, &A0, sid%; &49, 3, mid%; 1; 32767; 32767; : REM Define Texture Coordinates
0401A5 17 00 A0    0183       db 23,0,$A0
0401A8 64 00       0184       dw sid
0401AA 49 03       0185       db $49,3
0401AC 01 00       0186       dw mid
0401AE 01 00       0187       dw 1
0401B0 FF 7F       0188       dw 32767
0401B2 FF 7F       0189       dw 32767
0401B4             0190   @end:
0401B4             0191   
0401B4 21 F8 13 04 0192       ld hl,str_set_tex_coord_idxs
0401B8 CD C0 0D 04 0193       call printString
0401BC             0194   stci:
0401BC 21 C8 01 04 0195       ld hl,@beg
0401C0 01 53 00 00 0196       ld bc,@end-@beg
0401C4 C3 1B 02 04 0197       jp @end
0401C8             0198   @beg:
0401C8             0199   ;   490 VDU 23,0, &A0, sid%; &49, 4, mid%; model_indexes%; : REM Set Texture Coordinate Indexes
0401C8 17 00 A0    0200       db 23,0,$A0
0401CB 64 00       0201       dw sid
0401CD 49 04       0202       db $49,4
0401CF 01 00 24 00 0203       dw mid, model_indexes
0401D3             0204   ;   500 FOR i%=0 TO model_indexes%-1
0401D3             0205   ;   510   VDU 0;
0401D3             0206   ;   520 NEXT i%
0401D3 00 00 00 00 0207       blkw model_indexes, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04021B             0208   @end:
04021B             0209   
04021B             0210   ;   530 PRINT "Creating texture bitmap"
04021B 21 C0 13 04 0211       ld hl,str_create_texture_bitmap
04021F CD C0 0D 04 0212       call printString
040223             0213   ctb:
040223 21 31 02 04 0214       ld hl,@beg
040227 01 05 00 00 0215       ld bc,@end-@beg
04022B 5B DF       0216       rst.lil $18
04022D C3 36 02 04 0217       jp @end
040231             0218   @beg:
040231             0219   ;   540 VDU 23, 27, 0, bmid1%: REM Create a bitmap for a texture
040231 17 1B 00    0220       db 23,27,0
040234 65 00       0221       dw bmid1
040236             0222   @end:
040236             0223   
040236             0224   ;   550 PRINT "Setting texture pixel"
040236 21 A7 13 04 0225       ld hl,str_set_texture_pixel
04023A CD C0 0D 04 0226       call printString
04023E             0227   stp:
04023E 21 4C 02 04 0228       ld hl,@beg
040242 01 0B 00 00 0229       ld bc,@end-@beg
040246 5B DF       0230       rst.lil $18
040248 C3 57 02 04 0231       jp @end
04024C             0232   @beg:
04024C             0233   ;   560 VDU 23, 27, 1, 1; 1; &55, &AA, &FF, &C0 : REM Set a pixel in the bitmap
04024C 17 1B 01    0234       db 23,27,1
04024F 01 00 01 00 0235       dw 1,1
040253 55 AA FF C0 0236       db $55,$AA,$FF,$C0
040257             0237   @end:
040257             0238   
040257             0239   ;   570 PRINT "Create 3D object"
040257 21 65 13 04 0240       ld hl,str_create_object
04025B CD C0 0D 04 0241       call printString
04025F             0242   co:
04025F 21 6D 02 04 0243       ld hl,@beg
040263 01 0D 00 00 0244       ld bc,@end-@beg
040267 5B DF       0245       rst.lil $18
040269 C3 7A 02 04 0246       jp @end
04026D             0247   @beg:
04026D             0248   ;   580 VDU 23,0, &A0, sid%; &49, 5, oid%; mid%; bmid1%+64000; : REM Create Object
04026D 17 00 A0    0249       db 23,0,$A0
040270 64 00       0250       dw sid
040272 49 05       0251       db $49,5
040274 01 00       0252       dw oid
040276 01 00       0253       dw mid
040278 65 FA       0254       dw bmid1+64000
04027A             0255   @end:
04027A             0256   
04027A             0257   ;   590 PRINT "Scale object"
04027A 21 7B 13 04 0258       ld hl,str_scale_object
04027E CD C0 0D 04 0259       call printString
040282             0260   so:
040282             0261   ;   600 scale=1.0*256.0
040282 21 90 02 04 0262       ld hl,@beg
040286 01 0F 00 00 0263       ld bc,@end-@beg
04028A 5B DF       0264       rst.lil $18
04028C C3 9F 02 04 0265       jp @end
040290             0266   @beg:
040290             0267   ;   610 VDU 23, 0, &A0, sid%; &49, 9, oid%; scale; scale; scale; : REM Set Object XYZ Scale Factors
040290 17 00 A0    0268       db 23,0,$A0
040293 64 00       0269       dw sid
040295 49 09       0270       db $49,9
040297 01 00       0271       dw oid
040299 00 01       0272       dw obj_scale
04029B 00 01       0273       dw obj_scale
04029D 00 01       0274       dw obj_scale
04029F             0275   @end:
04029F             0276   
04029F             0277   ;   620 PRINT "Create target bitmap"
04029F 21 8D 13 04 0278       ld hl,str_create_target_bitmap
0402A3 CD C0 0D 04 0279       call printString
0402A7             0280   ctb2:
0402A7 21 B5 02 04 0281       ld hl,@beg
0402AB 01 10 00 00 0282       ld bc,@end-@beg
0402AF 5B DF       0283       rst.lil $18
0402B1 C3 C5 02 04 0284       jp @end
0402B5             0285   @beg:
0402B5             0286   ;   630 VDU 23, 27, 0, bmid2% : REM Select output bitmap
0402B5 17 1B 00    0287       db 23,27,0
0402B8 66 00       0288       dw bmid2
0402BA             0289   ;   640 VDU 23, 27, 2, scene_width%; scene_height%; &0000; &00C0; : REM Create solid color bitmap
0402BA 17 1B 02    0290       db 23,27,2
0402BD 60 00       0291       dw scene_width
0402BF 60 00       0292       dw scene_height
0402C1 00 00       0293       dw $0000
0402C3 C0 00       0294       dw $00C0
0402C5             0295   @end:
0402C5             0296   
0402C5 21 C1 14 04 0297       ld hl,str_init_cmplt
0402C9 CD C0 0D 04 0298       call printString
0402CD 3E 40       0299       ld a,%01000000
0402CF CD 25 13 04 0300       call multiPurposeDelay
0402D3             0301   
0402D3 C9          0302       ret
0402D4             0303   
0402D4             0304   main:
0402D4 21 DC 14 04 0305       ld hl,str_render_to_bitmap
0402D8 CD C0 0D 04 0306       call printString
0402DC 3E 40       0307       ld a,%01000000
0402DE CD 25 13 04 0308       call multiPurposeDelay
0402E2             0309   ; draw the cube
0402E2             0310   rendbmp:
0402E2 21 F0 02 04 0311       ld hl,@beg
0402E6 01 09 00 00 0312       ld bc,@end-@beg
0402EA 5B DF       0313       rst.lil $18
0402EC C3 F9 02 04 0314       jp @end
0402F0             0315   @beg:
0402F0             0316   ; 6800 VDU 23, 0, &A0, sid%; &49, 38, bmid2%+64000; : REM Render To Bitmap
0402F0 17 00 A0    0317       db 23, 0, $A0 ; Render To Bitmap
0402F3 64 00       0318       dw sid
0402F5 49 26       0319       db $49, 38
0402F7 66 FA       0320       dw bmid2+64000
0402F9             0321   @end:
0402F9             0322   
0402F9 21 F3 14 04 0323       ld hl,str_display_output_bitmap
0402FD CD C0 0D 04 0324       call printString
040301 3E 40       0325       ld a,%01000000
040303 CD 25 13 04 0326       call multiPurposeDelay
040307             0327   
040307             0328   dispbmp:
040307             0329   ; 6810 VDU 23, 27, 3, 0; 0; : REM Display output bitmap
040307 21 15 03 04 0330       ld hl,@beg
04030B 01 07 00 00 0331       ld bc,@end-@beg
04030F 5B DF       0332       rst.lil $18
040311 C3 1C 03 04 0333       jp @end
040315             0334   @beg:
040315 17 1B 03    0335       db 23, 27, 3 ; Display output bitmap
040318 10 00 10 00 0336       dw 16, 16
04031C             0337   @end:
04031C             0338   
04031C C9          0339       ret
04031D             0340   
04031D             0341       include "pingo/src/asm/vdu.asm"
04031D             0001*  ; The following is a high-level list of the VDU sequences that are supported:
04031D             0002*  ; VDU 0: Null (no operation)
04031D             0003*  ; VDU 1: Send next character to “printer” (if “printer” is enabled) §§
04031D             0004*  ; VDU 2: Enable “printer” §§
04031D             0005*  ; VDU 3: Disable “printer” §§
04031D             0006*  ; VDU 4: Write text at text cursor
04031D             0007*  ; VDU 5: Write text at graphics cursor
04031D             0008*  ; VDU 6: Enable screen (opposite of VDU 21) §§
04031D             0009*  ; VDU 7: Make a short beep (BEL)
04031D             0010*  ; VDU 8: Move cursor back one character
04031D             0011*  ; VDU 9: Move cursor forward one character
04031D             0012*  ; VDU 10: Move cursor down one line
04031D             0013*  ; VDU 11: Move cursor up one line
04031D             0014*  ; VDU 12: Clear text area (CLS)
04031D             0015*  ; VDU 13: Carriage return
04031D             0016*  ; VDU 14: Page mode On *
04031D             0017*  ; VDU 15: Page mode Off *
04031D             0018*  ; VDU 16: Clear graphics area (CLG)
04031D             0019*  ; VDU 17, colour: Define text colour (COLOUR)
04031D             0020*  ; VDU 18, mode, colour: Define graphics colour (GCOL mode, colour)
04031D             0021*  ; VDU 19, l, p, r, g, b: Define logical colour (COLOUR l, p / COLOUR l, r, g, b)
04031D             0022*  ; VDU 20: Reset palette and text/graphics colours and drawing modes §§
04031D             0023*  ; VDU 21: Disable screen (turns of VDU command processing, except for VDU 1 and VDU 6) §§
04031D             0024*  ; VDU 22, n: Select screen mode (MODE n)
04031D             0025*  ; VDU 23, n: Re-program display character / System Commands
04031D             0026*  ; VDU 24, left; bottom; right; top;: Set graphics viewport **
04031D             0027*  ; VDU 25, mode, x; y;: PLOT command
04031D             0028*  ; VDU 26: Reset graphics and text viewports **
04031D             0029*  ; VDU 27, char: Output character to screen §
04031D             0030*  ; VDU 28, left, bottom, right, top: Set text viewport **
04031D             0031*  ; VDU 29, x; y;: Set graphics origin
04031D             0032*  ; VDU 30: Home cursor
04031D             0033*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
04031D             0034*  ; VDU 127: Backspace
04031D             0035*  
04031D             0036*  ; VDU 0: Null (no operation)
04031D             0037*  ;     On encountering a VDU 0 command, the VDP will do nothing.
04031D             0038*  ;     This may be useful for padding out a VDU command sequence,
04031D             0039*  ;     or for inserting a placeholder for a command that will be added later.
04031D             0040*  ; inputs: none
04031D             0041*  ; outputs: an empty byte somewhere in VDU
04031D             0042*  ; destroys: a
04031D             0043*  vdu_null:
04031D AF          0044*      xor a
04031E 5B D7       0045*  	rst.lil $10
040320 C9          0046*  	ret
040321             0047*  
040321             0048*  ; VDU 1: Send next character to “printer” (if “printer” is enabled) §§
040321             0049*  ;     Ensures that the next character received by the VDP is sent through to
040321             0050*  ;     the “printer”, and not to the screen. This is useful for sending control
040321             0051*  ;     codes to the “printer”, or for sending data to the “printer” that is not
040321             0052*  ;     intended to be displayed on the screen. It allows characters that would
040321             0053*  ;     not otherwise normally be sent through to the “printer” to be sent.
040321             0054*  ;     If the “printer” has not been enabled then this command will just discard
040321             0055*  ;     the next byte sent to the VDP.
040321             0056*  ; inputs: a is the ascii code of the character to send
040321             0057*  ; prerequisites: "printer" must first be activated with VDU 2 (see below)
040321             0058*  ; outputs: a character on the serial terminal connected to the USB port
040321             0059*  ;           and the same character on the screen at the current text cursor location
040321             0060*  ; QUESTION: does it also advance the text cursor?
040321             0061*  ; destroys: hl, bc
040321             0062*  vdu_char_to_printer:
040321 32 31 03 04 0063*  	ld (@arg),a
040325 21 30 03 04 0064*  	ld hl,@cmd
040329 01 02 00 00 0065*  	ld bc,@end-@cmd
04032D 5B DF       0066*  	rst.lil $18
04032F C9          0067*  	ret
040330 01          0068*  @cmd: db 1
040331 00          0069*  @arg: db 0
040332             0070*  @end:
040332             0071*  
040332             0072*  ; VDU 2: Enable “printer” §§
040332             0073*  ;     Enables the “printer”.
040332             0074*  ;     In the context of the Agon platform, the “printer” is a serial
040332             0075*  ;     terminal that is connected to the VDP’s USB port. Typically
040332             0076*  ;     this port is used for power, but it can also be used to send and
040332             0077*  ;     receive data to and from the VDP.
040332             0078*  ;     When the “printer” is enabled, the VDP will send characters it receives
040332             0079*  ;     to the “printer” as well as to the screen. It will additionally send
040332             0080*  ;     through control codes 8-13. To send other control codes to the “printer”,
040332             0081*  ;     use the VDU 1 command.
040332             0082*  ;     The VDP will not send through other control codes to the printer,
040332             0083*  ;     and will will not send through data it receives as part of other commands.
040332             0084*  vdu_enable_printer:
040332 3E 02       0085*      ld a,2
040334 5B D7       0086*  	rst.lil $10
040336 C9          0087*  	ret
040337             0088*  
040337             0089*  ; VDU 3: Disable “printer” §§
040337             0090*  ; inputs: none
040337             0091*  ; outputs: a USB port bereft of communication with the VDP
040337             0092*  ; destroys: a
040337             0093*  vdu_disable_printer:
040337 3E 03       0094*      ld a,3
040339 5B D7       0095*  	rst.lil $10
04033B C9          0096*  	ret
04033C             0097*  
04033C             0098*  ; VDU 4: Write text at text cursor
04033C             0099*  ;     This causes text to be written at the current text cursor position.
04033C             0100*  ;     This is the default mode for text display.
04033C             0101*  ;     Text is written using the current text foreground and background colours.
04033C             0102*  ; inputs: a is the character to write to the screen
04033C             0103*  ; prerequisites: the text cursor at the intended position on screen
04033C             0104*  ; outputs: prints the character and moves text cursor right one position
04033C             0105*  ; destroys: a, hl, bc
04033C             0106*  vdu_char_to_text_cursor:
04033C 32 4C 03 04 0107*  	ld (@arg),a
040340 21 4B 03 04 0108*  	ld hl,@cmd
040344 01 02 00 00 0109*  	ld bc,@end-@cmd
040348 5B DF       0110*  	rst.lil $18
04034A C9          0111*  	ret
04034B 04          0112*  @cmd: db 4
04034C 00          0113*  @arg: db 0
04034D             0114*  @end:
04034D             0115*  
04034D             0116*  ; VDU 5: Write text at graphics cursor
04034D             0117*  ;     This causes text to be written at the current graphics cursor position.
04034D             0118*  ;     Using this, characters may be positioned at any graphics coordinate within
04034D             0119*  ;     the graphics viewport. This is useful for positioning text over graphics,
04034D             0120*  ;     or for positioning text at a specific location on the screen.
04034D             0121*  ;     Characters are plotted using the current graphics foreground colour,
04034D             0122*  ;     using the current graphics foreground plotting mode (see VDU 18).
04034D             0123*  ;     The character background is transparent, and will not overwrite any
04034D             0124*  ;     graphics that are already present at the character’s location.
04034D             0125*  ;     The exception to this is VDU 27, the “delete” character, which backspaces
04034D             0126*  ;     and deletes as per its usual behaviour, but will erase using the current
04034D             0127*  ;     graphics background colour.
04034D             0128*  ; inputs: a is the character to write to the screen
04034D             0129*  ; prerequisites: the graphics cursor at the intended position on screen
04034D             0130*  ; outputs: see the name of the function
04034D             0131*  ; destroys: a, hl, bc
04034D             0132*  vdu_char_to_gfx_cursor:
04034D 32 5D 03 04 0133*  	ld (@arg),a
040351 21 5C 03 04 0134*  	ld hl,@cmd
040355 01 02 00 00 0135*  	ld bc,@end-@cmd
040359 5B DF       0136*  	rst.lil $18
04035B C9          0137*  	ret
04035C 05          0138*  @cmd: db 5
04035D 00          0139*  @arg: db 0
04035E             0140*  @end:
04035E             0141*  
04035E             0142*  ; VDU 6: Enable screen (opposite of VDU 21) §§
04035E             0143*  ;     This enables the screen, and re-enables VDU command processing,
04035E             0144*  ;     reversing the effect of VDU 21.
04035E             0145*  ; inputs: none
04035E             0146*  ; outputs: a functioning screen and VDU
04035E             0147*  ; destroys: a
04035E             0148*  vdu_enable_screen:
04035E 3E 06       0149*      ld a,6
040360 5B D7       0150*  	rst.lil $10
040362 C9          0151*  	ret
040363             0152*  
040363             0153*  ; PASSES
040363             0154*  ; VDU 7: Make a short beep (BEL)
040363             0155*  ;     Plays a short beep sound on audio channel 0. If the audio channel
040363             0156*  ;     is already in use, or has been disabled, then this command will have no effect.
040363             0157*  ; inputs: none
040363             0158*  ; outputs: an unpleasant but thankfully short-lived audio tone
040363             0159*  ; destroys: a
040363             0160*  vdu_beep:
040363 3E 07       0161*      ld a,7
040365 5B D7       0162*  	rst.lil $10
040367 C9          0163*  	ret
040368             0164*  
040368             0165*  ; VDU 8: Move cursor back one character
040368             0166*  ;     Moves the text cursor one character in the negative “X” direction.
040368             0167*  ;     By default, when at the start of a line it will move to the end of
040368             0168*  ;     the previous line (as defined by the current text viewport).
040368             0169*  ;     If the cursor is also at the top of the screen then the viewport will scroll down.
040368             0170*  ;     The cursor remains constrained to the current text viewport.
040368             0171*  ;     When in VDU 5 mode and the graphics cursor is active, the viewport will not scroll.
040368             0172*  ;     The cursor is just moved left by one character width.
040368             0173*  ;     Further behaviour of the cursor can be controlled using the VDU 23,16 command.
040368             0174*  ;     It should be noted that as of Console8 VDP 2.5.0, the cursor system does not
040368             0175*  ;     support adjusting the direction of the cursor’s X axis, so this command
040368             0176*  ;     will move the cursor to the left. This is likely to change in the future.
040368             0177*  vdu_cursor_back:
040368 3E 08       0178*      ld a,8
04036A 5B D7       0179*  	rst.lil $10
04036C C9          0180*  	ret
04036D             0181*  
04036D             0182*  ; VDU 9: Move cursor forward one character
04036D             0183*  vdu_cursor_forward:
04036D 3E 09       0184*      ld a,9
04036F 5B D7       0185*  	rst.lil $10
040371 C9          0186*  	ret
040372             0187*  
040372             0188*  ; VDU 10: Move cursor down one line
040372             0189*  vdu_cursor_down:
040372 3E 0A       0190*      ld a,10
040374 5B D7       0191*  	rst.lil $10
040376 C9          0192*  	ret
040377             0193*  
040377             0194*  ; VDU 11: Move cursor up one line
040377             0195*  vdu_cursor_up:
040377 3E 0B       0196*      ld a,11
040379 5B D7       0197*  	rst.lil $10
04037B C9          0198*  	ret
04037C             0199*  
04037C             0200*  ; VDU 12: Clear text area (CLS)
04037C             0201*  vdu_cls:
04037C 3E 0C       0202*      ld a,12
04037E 5B D7       0203*  	rst.lil $10
040380 C9          0204*  	ret
040381             0205*  
040381             0206*  ; VDU 13: Carriage return
040381             0207*  vdu_cr:
040381 3E 0D       0208*      ld a,13
040383 5B D7       0209*  	rst.lil $10
040385 C9          0210*  	ret
040386             0211*  
040386             0212*  ; VDU 14: Page mode On *
040386             0213*  vdu_page_on:
040386 3E 0E       0214*      ld a,14
040388 5B D7       0215*  	rst.lil $10
04038A C9          0216*  	ret
04038B             0217*  
04038B             0218*  ; VDU 15: Page mode Off *
04038B             0219*  vdu_page_off:
04038B 3E 0F       0220*      ld a,15
04038D 5B D7       0221*  	rst.lil $10
04038F C9          0222*  	ret
040390             0223*  
040390             0224*  ; VDU 16: Clear graphics area (CLG)
040390             0225*  vdu_clg:
040390 3E 10       0226*      ld a,16
040392 5B D7       0227*  	rst.lil $10
040394 C9          0228*  	ret
040395             0229*  
040395             0230*  ; VDU 17, colour: Define text colour (COLOUR)
040395             0231*  vdu_colour_text:
040395 32 A5 03 04 0232*  	ld (@arg),a
040399 21 A4 03 04 0233*  	ld hl,@cmd
04039D 01 02 00 00 0234*  	ld bc,@end-@cmd
0403A1 5B DF       0235*  	rst.lil $18
0403A3 C9          0236*  	ret
0403A4 11          0237*  @cmd: db 17
0403A5 00          0238*  @arg: db 0
0403A6             0239*  @end:
0403A6             0240*  
0403A6             0241*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0403A6             0242*  ; inputs: a is the plotting mode, c is the colour
0403A6             0243*  ; outputs: a VDU set to put pixels on the screen with the selected mode/colour
0403A6             0244*  vdu_gcol_fg:
0403A6             0245*  ; This command will set both the current graphics colour,
0403A6             0246*  ; and the current graphics plotting mode.
0403A6             0247*  ; As with VDU 17 the colour number will set the foreground colour
0403A6             0248*  ; if it is in the range 0-127, or the background colour if it is
0403A6             0249*  ; in the range 128-255, and will be interpreted in the same manner.
0403A6             0250*  ; Support for different plotting modes on Agon is currently very limited.
0403A6             0251*  ; The only fully supported mode is mode 0, which is the default mode.
0403A6             0252*  ; This mode will plot the given colour at the given graphics coordinate,
0403A6             0253*  ; and will overwrite any existing graphics at that coordinate. There is
0403A6             0254*  ; very limited support for mode 4, which will invert the colour of any
0403A6             0255*  ; existing graphics at the given coordinate, but this is not fully supported
0403A6             0256*  ; and may not work as expected.
0403A6             0257*  ; Support for other plotting modes, matching those provided by Acorn’s
0403A6             0258*  ; original VDU system, may be added in the future.
0403A6             0259*  ; This command is identical to the BASIC GCOL keyword.
0403A6 32 BB 03 04 0260*  	ld (@mode),a
0403AA 79          0261*      ld a,c
0403AB 32 BC 03 04 0262*      ld (@col),a
0403AF 21 BA 03 04 0263*  	ld hl,@cmd
0403B3 01 03 00 00 0264*  	ld bc,@end-@cmd
0403B7 5B DF       0265*  	rst.lil $18
0403B9 C9          0266*  	ret
0403BA 12          0267*  @cmd: db 18
0403BB 00          0268*  @mode: db 0
0403BC 00          0269*  @col: db 0
0403BD             0270*  @end:
0403BD             0271*  
0403BD             0272*  vdu_gcol_bg:
0403BD 32 D4 03 04 0273*  	ld (@mode),a
0403C1 79          0274*      ld a,c
0403C2 C6 80       0275*      add a,128
0403C4 32 D5 03 04 0276*      ld (@col),a
0403C8 21 D3 03 04 0277*  	ld hl,@cmd
0403CC 01 03 00 00 0278*  	ld bc,@end-@cmd
0403D0 5B DF       0279*  	rst.lil $18
0403D2 C9          0280*  	ret
0403D3 12          0281*  @cmd:  db 18
0403D4 00          0282*  @mode: db 0
0403D5 00          0283*  @col:  db 0
0403D6             0284*  @end:
0403D6             0285*  
0403D6             0286*  ; VDU 19, l, p, r, g, b: Define logical colour (COLOUR l, p / COLOUR l, r, g, b)
0403D6             0287*  ;     This command sets the colour palette, by mapping a logical colour
0403D6             0288*  ;     to a physical colour. This is useful for defining custom colours,
0403D6             0289*  ;     or for redefining the default colours.
0403D6             0290*  ;     If the physical colour number is given as 255 then the colour will
0403D6             0291*  ;     be defined using the red, green, and blue values given. If the physical
0403D6             0292*  ;     colour number is given as any other value then the colour will be defined
0403D6             0293*  ;     using the colour palette entry given by that number, up to colour number 63.
0403D6             0294*  ;     If the physical colour is not 255 then the red, green, and blue values
0403D6             0295*  ;     must still be provided, but will be ignored.
0403D6             0296*  ;     The values for red, green and blue must be given in the range 0-255.
0403D6             0297*  ;     You should note that the physical Agon hardware only supports 64 colours,
0403D6             0298*  ;     so the actual colour displayed may not be exactly the same as the colour
0403D6             0299*  ;     requested. The nearest colour will be chosen.
0403D6             0300*  ;     This command is equivalent to the BASIC COLOUR keyword.
0403D6             0301*  ; inputs: a=physcial colour, b=logical colour, chl=r,g,b
0403D6             0302*  vdu_def_log_colour:
0403D6 32 FB 03 04 0303*  	ld (@physical),a
0403DA 47          0304*      ld b,a
0403DB 32 FA 03 04 0305*      ld (@logical),a
0403DF 79          0306*      ld a,c
0403E0 32 FC 03 04 0307*      ld (@red),a
0403E4 7C          0308*      ld a,h
0403E5 32 FD 03 04 0309*      ld (@green),a
0403E9 7D          0310*      ld a,l
0403EA 32 FE 03 04 0311*      ld (@blue),a
0403EE 21 F9 03 04 0312*  	ld hl,@cmd
0403F2 01 06 00 00 0313*  	ld bc,@end-@cmd
0403F6 5B DF       0314*  	rst.lil $18
0403F8 C9          0315*  	ret
0403F9 13          0316*  @cmd: db 19
0403FA 00          0317*  @logical: db 0
0403FB 00          0318*  @physical: db 0
0403FC 00          0319*  @red: db 0
0403FD 00          0320*  @green: db 0
0403FE 00          0321*  @blue: db 0
0403FF             0322*  @end:
0403FF             0323*  
0403FF             0324*  ; VDU 20: Reset palette and text/graphics colours and drawing modes §§
0403FF             0325*  vdu_reset_gfx:
0403FF 3E 14       0326*      ld a,20
040401 5B D7       0327*  	rst.lil $10
040403 C9          0328*  	ret
040404             0329*  
040404             0330*  ; VDU 21: Disable screen (turns off VDU command processing,
040404             0331*  ; except for VDU 1 and VDU 6) §§
040404             0332*  vdu_disable_screen:
040404 3E 15       0333*      ld a,21
040406 5B D7       0334*  	rst.lil $10
040408 C9          0335*  	ret
040409             0336*  
040409             0337*  ; VDU 22, n: Select screen mode (MODE n)
040409             0338*  ; Inputs: a, screen mode (8-bit unsigned integer), in the following list:
040409             0339*  ; https://agonconsole8.github.io/agon-docs/VDP---Screen-Modes.html
040409             0340*  ; Screen modes
040409             0341*  ; Modes over 128 are double-buffered
040409             0342*  ; From Version 1.04 or greater
040409             0343*  ; Mode 	Horz 	Vert 	Cols 	Refresh
040409             0344*  ; 0 	640 	480 	16 	    60hz
040409             0345*  ; * 1 	640 	480 	4 	    60hz
040409             0346*  ; 2 	640 	480 	2 	    60hz
040409             0347*  ; 3 	640 	240 	64 	    60hz
040409             0348*  ; 4 	640 	240 	16 	    60hz
040409             0349*  ; 5 	640 	240 	4 	    60hz
040409             0350*  ; 6 	640 	240 	2 	    60hz
040409             0351*  ; ** 7 	n/a 	n/a 	16 	    60hz
040409             0352*  ; 8 	320 	240 	64 	    60hz
040409             0353*  ; 9 	320 	240 	16 	    60hz
040409             0354*  ; 10 	320 	240 	4 	    60hz
040409             0355*  ; 11 	320 	240 	2 	    60hz
040409             0356*  ; 12 	320 	200 	64 	    70hz
040409             0357*  ; 13 	320 	200 	16 	    70hz
040409             0358*  ; 14 	320 	200 	4 	    70hz
040409             0359*  ; 15 	320 	200 	2 	    70hz
040409             0360*  ; 16 	800 	600 	4 	    60hz
040409             0361*  ; 17 	800 	600 	2 	    60hz
040409             0362*  ; 18 	1024 	768 	2 	    60hz
040409             0363*  ; 129 	640 	480 	4 	    60hz
040409             0364*  ; 130 	640 	480 	2 	    60hz
040409             0365*  ; 132 	640 	240 	16 	    60hz
040409             0366*  ; 133 	640 	240 	4 	    60hz
040409             0367*  ; 134 	640 	240 	2 	    60hz
040409             0368*  ; 136 	320 	240 	64 	    60hz
040409             0369*  ; 137 	320 	240 	16 	    60hz
040409             0370*  ; 138 	320 	240 	4 	    60hz
040409             0371*  ; 139 	320 	240 	2 	    60hz
040409             0372*  ; 140 	320 	200 	64 	    70hz
040409             0373*  ; 141 	320 	200 	16 	    70hz
040409             0374*  ; 142 	320 	200 	4 	    70hz
040409             0375*  ; 143 	320 	200 	2 	    70hz
040409             0376*  ; * Mode 1 is the “default” mode, and is the mode that the system will use on startup.
040409             0377*  ; It is also the mode that the system will fall back to use if it was not possible to
040409             0378*  ; change to the requested mode.
040409             0379*  ; ** Mode 7 is the “Teletext” mode, and essentially works in a very similar manner to
040409             0380*  ; the BBC Micro’s Teletext mode, which was also mode 7.
040409             0381*  vdu_set_screen_mode:
040409 32 19 04 04 0382*  	ld (@arg),a
04040D 21 18 04 04 0383*  	ld hl,@cmd
040411 01 02 00 00 0384*  	ld bc,@end-@cmd
040415 5B DF       0385*  	rst.lil $18
040417 C9          0386*  	ret
040418 16          0387*  @cmd: db 22 ; set screen mode
040419 00          0388*  @arg: db 0  ; screen mode parameter
04041A             0389*  @end:
04041A             0390*  
04041A             0391*  ; VDU 23, n: Re-program display character / System Commands
04041A             0392*  ; inputs: a, ascii code; hl, pointer to bitmask data
04041A             0393*  vdu_define_character:
04041A 32 36 04 04 0394*  	ld (@ascii),a
04041E 11 37 04 04 0395*  	ld de,@data
040422 06 08       0396*  	ld b,8 ; loop counter for 8 bytes of data
040424             0397*  @loop:
040424 7E          0398*  	ld a,(hl)
040425 12          0399*  	ld (de),a
040426 23          0400*  	inc hl
040427 13          0401*  	inc de
040428 10 FA       0402*  	djnz @loop
04042A 21 35 04 04 0403*  	ld hl,@cmd
04042E 01 0A 00 00 0404*  	ld bc,@end-@cmd
040432 5B DF       0405*  	rst.lil $18
040434 C9          0406*  	ret
040435 17          0407*  @cmd:   db 23
040436 00          0408*  @ascii: db 0
040437             0409*  @data:  ds 8
04043F             0410*  @end:
04043F             0411*  
04043F             0412*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
04043F             0413*  ; NOTE: the order of the y-coordinate parameters are inverted
04043F             0414*  ; 	because we have turned off logical screen scaling
04043F             0415*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
04043F             0416*  ; outputs; nothing
04043F             0417*  ; destroys: a might make it out alive
04043F             0418*  vdu_set_gfx_viewport:
04043F ED 43 5F 04 0419*      ld (@x0),bc
       04          
040444 FD 22 61 04 0420*      ld (@y1),iy
       04          
040449 DD 22 63 04 0421*  	ld (@x1),ix
       04          
04044E ED 53 65 04 0422*  	ld (@y0),de
       04          
040453 21 5E 04 04 0423*  	ld hl,@cmd
040457 01 09 00 00 0424*  	ld bc,@end-@cmd
04045B 5B DF       0425*  	rst.lil $18
04045D C9          0426*  	ret
04045E 18          0427*  @cmd:   db 24 ; set graphics viewport command
04045F 00 00       0428*  @x0: 	dw 0x0000 ; set by bc
040461 00 00       0429*  @y1: 	dw 0x0000 ; set by iy
040463 00 00       0430*  @x1: 	dw 0x0000 ; set by ix
040465 00 00       0431*  @y0: 	dw 0x0000 ; set by de
040467 00          0432*  @end:   db 0x00	  ; padding
040468             0433*  
040468             0434*  ; VDU 25, mode, x; y;: PLOT command
040468             0435*  ; Implemented in vdu_plot.asm
040468             0436*  
040468             0437*  ; VDU 26: Reset graphics and text viewports **
040468             0438*  vdu_reset_txt_gfx_view:
040468 3E 1A       0439*      ld a,26
04046A 5B D7       0440*  	rst.lil $10
04046C C9          0441*  	ret
04046D             0442*  
04046D             0443*  ; PASSES
04046D             0444*  ; VDU 27, char: Output character to screen §
04046D             0445*  ; inputs: a is the ascii code of the character to draw
04046D             0446*  vdu_draw_char:
04046D 32 7D 04 04 0447*  	ld (@arg),a
040471 21 7C 04 04 0448*  	ld hl,@cmd
040475 01 02 00 00 0449*  	ld bc,@end-@cmd
040479 5B DF       0450*  	rst.lil $18
04047B C9          0451*  	ret
04047C 1B          0452*  @cmd: db 27
04047D 00          0453*  @arg: db 0  ; ascii code of character to draw
04047E             0454*  @end:
04047E             0455*  
04047E             0456*  ; VDU 28, left, bottom, right, top: Set text viewport **
04047E             0457*  ; MIND THE LITTLE-ENDIANESS
04047E             0458*  ; inputs: c=left,b=bottom,e=right,d=top
04047E             0459*  ; outputs; nothing
04047E             0460*  ; destroys: a might make it out alive
04047E             0461*  vdu_set_txt_viewport:
04047E ED 43 94 04 0462*      ld (@lb),bc
       04          
040483 ED 53 96 04 0463*  	ld (@rt),de
       04          
040488 21 93 04 04 0464*  	ld hl,@cmd
04048C 01 05 00 00 0465*  	ld bc,@end-@cmd
040490 5B DF       0466*  	rst.lil $18
040492 C9          0467*  	ret
040493 1C          0468*  @cmd:   db 28 ; set text viewport command
040494 00 00       0469*  @lb: 	dw 0x0000 ; set by bc
040496 00 00       0470*  @rt: 	dw 0x0000 ; set by de
040498 00          0471*  @end:   db 0x00	  ; padding
040499             0472*  
040499             0473*  ; PASSES
040499             0474*  ; VDU 29, x; y;: Set graphics origin
040499             0475*  ; inputs: bc,de x,y coordinates
040499             0476*  vdu_set_gfx_origin:
040499 ED 43 AF 04 0477*      ld (@x0),bc
       04          
04049E ED 53 B1 04 0478*      ld (@y0),de
       04          
0404A3 21 AE 04 04 0479*  	ld hl,@cmd
0404A7 01 05 00 00 0480*  	ld bc,@end-@cmd
0404AB 5B DF       0481*  	rst.lil $18
0404AD C9          0482*  	ret
0404AE 1D          0483*  @cmd:	db 29
0404AF 00 00       0484*  @x0: 	dw 0
0404B1 00 00       0485*  @y0: 	dw 0
0404B3 00          0486*  @end: 	db 0 ; padding
0404B4             0487*  
0404B4             0488*  ; PASSES
0404B4             0489*  ; VDU 30: Home cursor
0404B4             0490*  vdu_home_cursor:
0404B4 3E 1E       0491*      ld a,30
0404B6 5B D7       0492*  	rst.lil $10
0404B8 C9          0493*  	ret
0404B9             0494*  
0404B9             0495*  ; PASSES
0404B9             0496*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0404B9             0497*  ; inputs: c=x, b=y 8-bit unsigned integers
0404B9             0498*  vdu_move_cursor:
0404B9 ED 43 CA 04 0499*      ld (@x0),bc
       04          
0404BE 21 C9 04 04 0500*  	ld hl,@cmd
0404C2 01 03 00 00 0501*  	ld bc,@end-@cmd
0404C6 5B DF       0502*  	rst.lil $18
0404C8 C9          0503*  	ret
0404C9 1F          0504*  @cmd: 	db 31
0404CA 00          0505*  @x0:	db 0
0404CB 00          0506*  @y0: 	db 0
0404CC 00          0507*  @end: 	db 0 ; padding
0404CD             0508*  
0404CD             0509*  
0404CD             0510*  ; VDU 127: Backspace
0404CD             0511*  vdu_bksp:
0404CD 3E 7F       0512*      ld a,127
0404CF 5B D7       0513*  	rst.lil $10
0404D1 C9          0514*  	ret
0404D2             0515*  
0404D2             0516*  ; activate a bitmap in preparation to draw it
0404D2             0517*  ; inputs: a holding the bitmap index
0404D2             0518*  vdu_bmp_select:
0404D2 32 E4 04 04 0519*  	ld (@bmp),a
0404D6 21 E1 04 04 0520*  	ld hl,@cmd
0404DA 01 04 00 00 0521*  	ld bc,@end-@cmd
0404DE 5B DF       0522*  	rst.lil $18
0404E0 C9          0523*  	ret
0404E1 17 1B 00    0524*  @cmd: db 23,27,0
0404E4 00          0525*  @bmp: db 0
0404E5             0526*  @end:
0404E5             0527*  
0404E5             0528*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0404E5             0529*  ; inputs: hl=bufferId
0404E5             0530*  vdu_buff_select:
0404E5 22 F7 04 04 0531*  	ld (@bufferId),hl
0404E9 21 F4 04 04 0532*  	ld hl,@cmd
0404ED 01 05 00 00 0533*  	ld bc,@end-@cmd
0404F1 5B DF       0534*  	rst.lil $18
0404F3 C9          0535*  	ret
0404F4 17 1B 20    0536*  @cmd: db 23,27,0x20
0404F7 00 00       0537*  @bufferId: dw 0x0000
0404F9 00          0538*  @end: db 0x00 ; padding
0404FA             0539*  
0404FA             0540*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0404FA             0541*  ; inputs: a=format; bc=width; de=height
0404FA             0542*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0404FA             0543*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0404FA             0544*  ; 0 	RGBA8888 (4-bytes per pixel)
0404FA             0545*  ; 1 	RGBA2222 (1-bytes per pixel)
0404FA             0546*  ; 2 	Mono/Mask (1-bit per pixel)
0404FA             0547*  ; 3 	Reserved for internal use by VDP (“native” format)
0404FA             0548*  vdu_bmp_create:
0404FA ED 43 16 05 0549*      ld (@width),bc
       04          
0404FF ED 53 18 05 0550*      ld (@height),de
       04          
040504 32 1A 05 04 0551*      ld (@fmt),a
040508 21 13 05 04 0552*  	ld hl,@cmd
04050C 01 08 00 00 0553*  	ld bc,@end-@cmd
040510 5B DF       0554*  	rst.lil $18
040512 C9          0555*  	ret
040513 17 1B 21    0556*  @cmd:       db 23,27,0x21
040516 00 00       0557*  @width:     dw 0x0000
040518 00 00       0558*  @height:    dw 0x0000
04051A 00          0559*  @fmt:       db 0x00
04051B             0560*  @end:
04051B             0561*  
04051B             0562*  ; Draw a bitmap on the screen
04051B             0563*  ; inputs: bc, x-coordinate; de, y-coordinate
04051B             0564*  ; prerequisite: bitmap index set by e.g. vdu_bmp_select
04051B             0565*  vdu_bmp_draw:
04051B ED 43 33 05 0566*      ld (@x0),bc
       04          
040520 ED 53 35 05 0567*      ld (@y0),de
       04          
040525 21 30 05 04 0568*  	ld hl,@cmd
040529 01 07 00 00 0569*  	ld bc,@end-@cmd
04052D 5B DF       0570*  	rst.lil $18
04052F C9          0571*  	ret
040530 17 1B 03    0572*  @cmd: db 23,27,3
040533 00 00       0573*  @x0:  dw 0x0000
040535 00 00       0574*  @y0:  dw 0x0000
040537 00          0575*  @end: db 0x00 ; padding
040538             0576*  
040538             0577*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
040538             0578*  ; inputs: a is scaling mode, 1=on, 0=off
040538             0579*  ; note: default setting on boot is scaling ON
040538             0580*  vdu_set_scaling:
040538 32 4A 05 04 0581*  	ld (@arg),a
04053C 21 47 05 04 0582*  	ld hl,@cmd
040540 01 04 00 00 0583*  	ld bc,@end-@cmd
040544 5B DF       0584*  	rst.lil $18
040546 C9          0585*  	ret
040547 17 00 C0    0586*  @cmd: db 23,0,0xC0
04054A 00          0587*  @arg: db 0  ; scaling on/off
04054B             0588*  @end:
04054B             0589*  
04054B             0590*  ; VDU 23, 0, &C3: Swap the screen buffer and/or wait for VSYNC **
04054B             0591*  ; 	Swap the screen buffer (double-buffered modes only) or wait for VSYNC
04054B             0592*  ; 	(all modes).
04054B             0593*  
04054B             0594*  ; 	This command will swap the screen buffer, if the current screen mode
04054B             0595*  ; 	is double-buffered, doing so at the next VSYNC. If the current screen
04054B             0596*  ; 	mode is not double-buffered then this command will wait for the next
04054B             0597*  ; 	VSYNC signal before returning. This can be used to synchronise the
04054B             0598*  ; 	screen with the vertical refresh rate of the monitor.
04054B             0599*  
04054B             0600*  ; 	Waiting for VSYNC can be useful for ensuring smooth graphical animation,
04054B             0601*  ; 	as it will prevent tearing of the screen.
04054B             0602*  ; inputs: none
04054B             0603*  ; outputs: none
04054B             0604*  ; destroys: hl, bc
04054B             0605*  vdu_flip:
04054B 21 56 05 04 0606*  	ld hl,@cmd
04054F 01 03 00 00 0607*  	ld bc,@end-@cmd
040553 5B DF       0608*  	rst.lil $18
040555 C9          0609*  	ret
040556 17 00 C3    0610*  @cmd: db 23,0,0xC3
040559             0611*  @end:
040559             0612*  
040559             0613*  ; Command 64: Compress a buffer
040559             0614*  ; VDU 23, 0, &A0, targetBufferId; 64, sourceBufferId;
040559             0615*  ; This command will compress the contents of a buffer, replacing the target buffer with the compressed data. Unless the target buffer is the same as the source, the source buffer will be left unchanged.
040559             0616*  
040559             0617*  
040559             0618*  ; Command 65: Decompress a buffer
040559             0619*  ; VDU 23, 0, &A0, targetBufferId; 65, sourceBufferId;
040559             0620*  ; This command will decompress the contents of a buffer, replacing the target buffer with the decompressed data. Unless the target buffer is the same as the source, the source buffer will be left unchanged.
040559             0621*  ; inputs: hl=sourceBufferId/targetBufferId
040559             0622*  vdu_decompress_buffer:
040559 22 75 05 04 0623*  	ld (@targetBufferId),hl
04055D 22 78 05 04 0624*  	ld (@sourceBufferId),hl
040561 3E 41       0625*  	ld a,65
040563 32 77 05 04 0626*  	ld (@cmd1),a ; restore the part of command that got stomped on
040567 21 72 05 04 0627*  	ld hl,@cmd
04056B 01 08 00 00 0628*  	ld bc,@end-@cmd
04056F 5B DF       0629*  	rst.lil $18
040571 C9          0630*  	ret
040572 17 00 A0    0631*  @cmd: 	db 23,0,0xA0
040575 00 00       0632*  @targetBufferId: dw 0x0000
040577 41          0633*  @cmd1:	db 65
040578 00 00       0634*  @sourceBufferId: dw 0x0000
04057A 00          0635*  @end: 	db 0x00 ; padding
04057B             0636*  
04057B             0637*  ; Command 65: Decompress a buffer
04057B             0638*  ; VDU 23, 0, &A0, targetBufferId; 65, sourceBufferId;
04057B             0639*  ; This command will decompress the contents of a buffer, replacing the target buffer with the decompressed data. Unless the target buffer is the same as the source, the source buffer will be left unchanged.
04057B             0640*  ; inputs: hl=sourceBufferId/targetBufferId
04057B             0641*  ; 0x7FFF for the source buffer is just an easy-to remember aribtrary value
04057B             0642*  vdu_decompress_buffer_different:
04057B 22 9B 05 04 0643*  	ld (@targetBufferId),hl
04057F 21 FF 7F 00 0644*      ld hl,0x7FFF
040583 22 9E 05 04 0645*  	ld (@sourceBufferId),hl
040587 3E 41       0646*  	ld a,65
040589 32 9D 05 04 0647*  	ld (@cmd1),a ; restore the part of command that got stomped on
04058D 21 98 05 04 0648*  	ld hl,@cmd
040591 01 08 00 00 0649*  	ld bc,@end-@cmd
040595 5B DF       0650*  	rst.lil $18
040597 C9          0651*  	ret
040598 17 00 A0    0652*  @cmd: 	db 23,0,0xA0
04059B 00 00       0653*  @targetBufferId: dw 0x0000
04059D 41          0654*  @cmd1:	db 65
04059E 00 00       0655*  @sourceBufferId: dw 0x0000
0405A0 00          0656*  @end: 	db 0x00 ; padding
0405A1             0657*  
0405A1             0658*  ; #### from vdp.asm ####
0405A1             0659*  
0405A1             0660*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
0405A1             0661*  ; VDU 23, 7: Scrolling
0405A1             0662*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
0405A1             0663*  ; inputs: a, extent; l, direction; h; speed
0405A1             0664*  vdu_scroll_down:
0405A1 32 B6 05 04 0665*  	ld (@extent),a
0405A5 22 B7 05 04 0666*  	ld (@dir),hl ; implicitly populates @speed
0405A9 21 B4 05 04 0667*  	ld hl,@cmd
0405AD 01 05 00 00 0668*  	ld bc,@end-@cmd
0405B1 5B DF       0669*  	rst.lil $18     ;; Sending command to VDP
0405B3 C9          0670*  	ret
0405B4 17 07       0671*  @cmd:       db 23,7
0405B6 00          0672*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
0405B7 00          0673*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
0405B8 00          0674*  @speed:     db 0x00 ; pixels
0405B9 00          0675*  @end:		db 0x00 ; padding
0405BA             0676*  
0405BA             0677*  cursor_on:
0405BA 21 C5 05 04 0678*  	ld hl,@cmd
0405BE 01 03 00 00 0679*  	ld bc,@end-@cmd
0405C2 5B DF       0680*  	rst.lil $18
0405C4 C9          0681*  	ret
0405C5             0682*  @cmd:
0405C5 17 01 01    0683*  	db 23,1,1
0405C8             0684*  @end:
0405C8             0685*  
0405C8             0686*  cursor_off:
0405C8 21 D3 05 04 0687*  	ld hl,@cmd
0405CC 01 03 00 00 0688*  	ld bc,@end-@cmd
0405D0 5B DF       0689*  	rst.lil $18
0405D2 C9          0690*  	ret
0405D3             0691*  @cmd:
0405D3 17 01 00    0692*  	db 23,1,0
0405D6             0693*  @end:
0405D6             0694*  
0405D6 DD E5       0695*  vdu_vblank:		PUSH 	IX			; Wait for VBLANK interrupt
0405D8             0696*  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
0405D8 3E 08       0001*M 			LD	A, function
0405DA 5B CF       0002*M 			RST.LIL	08h
0405DC DD 7E 00    0697*  			LD	A, (IX + sysvar_time + 0)
0405DF DD BE 00    0698*  @wait:			CP 	A, (IX + sysvar_time + 0)
0405E2 28 FB       0699*  			JR	Z, @wait
0405E4 DD E1       0700*  			POP	IX
0405E6 C9          0701*  			RET
0405E7             0702*  
0405E7             0703*  ; #### from vdu_bmp.asm ####
0405E7             0704*  ; =========================================================================
0405E7             0705*  ; Bitmaps
0405E7             0706*  ; -------------------------------------------------------------------------
0405E7             0707*  ; VDU 23, 27, 0, n: Select bitmap n
0405E7             0708*  ; VDU 23, 27, &20, bufferId;: Select bitmap using a 16-bit buffer ID *
0405E7             0709*  ; VDU 23, 27, 1, w; h; b1, b2 ... bn: Load colour bitmap data into current bitmap
0405E7             0710*  
0405E7             0711*  ; VDU 23, 27, 1, n, 0, 0;: Capture screen data into bitmap n *
0405E7             0712*  ; VDU 23, 27, &21, bitmapId; 0; : same, but to 16-bit buffer ID *
0405E7             0713*  ; Any PLOT, or VDU 25, style command will push the graphics cursor position -
0405E7             0714*  ; typically "move" style plot commands are used to define the rectangle.
0405E7             0715*  ; To be clear, this command should be performed after two "move" style PLOT commands.
0405E7             0716*  ; inputs: hl; target bufferId
0405E7             0717*  ; all the following are in 16.8 fixed point format
0405E7             0718*  ;   ub.c; top-left x coordinate
0405E7             0719*  ;   ud.e; top-left y coordinate
0405E7             0720*  ;   ui.x; width
0405E7             0721*  ;   ui.y; height
0405E7             0722*  vdu_buff_screen_capture168:
0405E7 ED 53 1E 06 0723*          ld (@y0-1),de
       04          
0405EC ED 43 1C 06 0724*          ld (@x0-1),bc
       04          
0405F1 3E 44       0725*          ld a,0x44 ; plot_pt+mv_abs
0405F3 32 1C 06 04 0726*          ld (@x0-1),a
0405F7             0727*  
0405F7 DD 22 23 06 0728*          ld (@x1),ix
       04          
0405FC FD 22 25 06 0729*          ld (@y1),iy
       04          
040601 3E 17       0730*          ld a,23
040603 32 27 06 04 0731*          ld (@y1+2),a
040607             0732*  
040607 22 2A 06 04 0733*          ld (@bufId),hl
04060B AF          0734*          xor a
04060C 32 2C 06 04 0735*          ld (@bufId+2),a
040610             0736*  
040610 21 1B 06 04 0737*          ld hl,@begin
040614 01 13 00 00 0738*          ld bc,@end-@begin
040618 5B DF       0739*          rst.lil $18
04061A C9          0740*          ret
04061B             0741*  @begin:
04061B             0742*  ; absolute move gfx cursor to top-left screen coordinate
04061B             0743*  ; VDU 25, mode, x; y;: PLOT command
04061B 19 44       0744*          db 25,0x44 ; plot_pt+mv_abs
04061D 40 00       0745*  @x0: 	dw 64
04061F 40 00       0746*  @y0: 	dw 64
040621             0747*  ; relative move gfx cursor to bottom-right screen coordinate
040621             0748*  ; VDU 25, mode, x; y;: PLOT command
040621 19 40       0749*          db 25,0x40 ; plot_pt+mv_rel
040623 0F 00       0750*  @x1: 	dw 15
040625 0F 00       0751*  @y1: 	dw 15
040627             0752*  ; now the main event
040627             0753*  ; VDU 23, 27, &21, bitmapId; 0;
040627 17 1B 21    0754*          db 23,27,0x21
04062A 00 20 00 00 0755*  @bufId: dw 0x2000,0x0000
04062E             0756*  @end: ; no padding required
04062E             0757*  
04062E             0758*  vdu_buff_screen_capture_full:
04062E 21 39 06 04 0759*          ld hl,@begin
040632 01 13 00 00 0760*          ld bc,@end-@begin
040636 5B DF       0761*          rst.lil $18
040638 C9          0762*          ret
040639             0763*  @begin:
040639             0764*  ; absolute move gfx cursor to top-left screen coordinate
040639             0765*  ; VDU 25, mode, x; y;: PLOT command
040639 19 44       0766*          db 25,0x44 ; plot_pt+mv_abs
04063B 00 00       0767*  @x0: 	dw 0
04063D 00 00       0768*  @y0: 	dw 0
04063F             0769*  ; relative move gfx cursor to bottom-right screen coordinate
04063F             0770*  ; VDU 25, mode, x; y;: PLOT command
04063F 19 40       0771*          db 25,0x40 ; plot_pt+mv_rel
040641 3F 01       0772*  @x1: 	dw 319
040643 EF 00       0773*  @y1: 	dw 239
040645             0774*  ; now the main event
040645             0775*  ; VDU 23, 27, &21, bitmapId; 0;
040645 17 1B 21    0776*          db 23,27,0x21
040648 00 20 00 00 0777*  @bufId: dw 0x2000,0x0000
04064C             0778*  @end: ; no padding required
04064C             0779*  
04064C             0780*  vdu_buff_screen_paste_full:
04064C 21 57 06 04 0781*          ld hl,@begin
040650 01 0B 00 00 0782*          ld bc,@end-@begin
040654 5B DF       0783*          rst.lil $18
040656 C9          0784*          ret
040657             0785*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
040657 17 1B 20    0786*  @begin:    db 23,27,0x20
04065A 00 20       0787*  @bufferId: dw 0x2000
04065C             0788*  ; VDU 25, mode, x; y;: PLOT command
04065C 19 ED       0789*             db 25,0xED ; plot_bmp+dr_abs_fg
04065E 00 00 00 00 0790*             dw 0x0000,0x0000
040662             0791*  @end: ; no padding required
040662             0792*  
040662             0793*  vdu_buff_screen_capture_tiles:
040662 21 6D 06 04 0794*          ld hl,@begin
040666 01 13 00 00 0795*          ld bc,@end-@begin
04066A 5B DF       0796*          rst.lil $18
04066C C9          0797*          ret
04066D             0798*  @begin:
04066D             0799*  ; absolute move gfx cursor to top-left screen coordinate
04066D             0800*  ; VDU 25, mode, x; y;: PLOT command
04066D 19 44       0801*          db 25,0x44 ; plot_pt+mv_abs
04066F 00 00       0802*  @x0: 	dw 0
040671 00 00       0803*  @y0: 	dw 0
040673             0804*  ; relative move gfx cursor to bottom-right screen coordinate
040673             0805*  ; VDU 25, mode, x; y;: PLOT command
040673 19 40       0806*          db 25,0x40 ; plot_pt+mv_rel
040675 FF 00       0807*  @x1: 	dw 319-64
040677 EF 00       0808*  @y1: 	dw 239
040679             0809*  ; now the main event
040679             0810*  ; VDU 23, 27, &21, bitmapId; 0;
040679 17 1B 21    0811*          db 23,27,0x21
04067C 00 20 00 00 0812*  @bufId: dw 0x2000,0x0000
040680             0813*  @end: ; no padding required
040680             0814*  
040680             0815*  vdu_buff_screen_paste_tiles:
040680 21 8B 06 04 0816*          ld hl,@begin
040684 01 0B 00 00 0817*          ld bc,@end-@begin
040688 5B DF       0818*          rst.lil $18
04068A C9          0819*          ret
04068B             0820*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
04068B 17 1B 20    0821*  @begin:    db 23,27,0x20
04068E 00 20       0822*  @bufferId: dw 0x2000
040690             0823*  ; VDU 25, mode, x; y;: PLOT command
040690 19 ED       0824*             db 25,0xED ; plot_bmp+dr_abs_fg
040692 00 00 01 00 0825*             dw 0x0000,0x0001
040696             0826*  @end: ; no padding required
040696             0827*  
040696             0828*  ; VDU 23, 27, 2, w; h; col1; col2;: Create a solid colour rectangular bitmap
040696             0829*  ; VDU 23, 27, 3, x; y;: Draw current bitmap on screen at pixel position x, y
040696             0830*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer *
040696             0831*  ; Value	Meaning
040696             0832*  ; 0	RGBA8888 (4-bytes per pixel)
040696             0833*  ; 1	RGBA2222 (1-bytes per pixel)
040696             0834*  ; 2	Mono/Mask (1-bit per pixel)
040696             0835*  ; 3	Reserved for internal use by VDP ("native" format)VDP.
040696             0836*  ;     They have some significant limitations, and are not intended for general use.
040696             0837*  
040696             0838*  ; =========================================================================
040696             0839*  ; Sprites
040696             0840*  ; -------------------------------------------------------------------------
040696             0841*  ; VDU 23, 27, 4, n: Select sprite n
040696             0842*  ; VDU 23, 27, 5: Clear frames in current sprite
040696             0843*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
040696             0844*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
040696             0845*  ; VDU 23, 27, 7, n: Activate n sprites
040696             0846*  ; VDU 23, 27, 8: Select next frame of current sprite
040696             0847*  ; VDU 23, 27, 9: Select previous frame of current sprite
040696             0848*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
040696             0849*  ; VDU 23, 27, 11: Show current sprite
040696             0850*  ; VDU 23, 27, 12: Hide current sprite
040696             0851*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
040696             0852*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
040696             0853*  ; VDU 23, 27, 15: Update the sprites in the GPU
040696             0854*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
040696             0855*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
040696             0856*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
040696             0857*  
040696             0858*  ; =========================================================================
040696             0859*  ; Mouse cursor
040696             0860*  ; -------------------------------------------------------------------------
040696             0861*  ; VDU 23, 27, &40, hotX, hotY: Setup a mouse cursor with a hot spot at hotX, hotY
040696             0862*  
040696             0863*  ; #### from vdu_plot.asm ####
040696             0864*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
040696             0865*  ; PLOT code 	(Decimal) 	Effect
040696             0866*  ; &00-&07 	0-7 	Solid line, includes both ends
040696             0867*  plot_sl_both: equ 0x00
040696             0868*  
040696             0869*  ; &08-&0F 	8-15 	Solid line, final point omitted
040696             0870*  plot_sl_first: equ 0x08
040696             0871*  
040696             0872*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
040696             0873*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
040696             0874*  
040696             0875*  ; &20-&27 	32-39 	Solid line, first point omitted
040696             0876*  plot_sl_last: equ 0x20
040696             0877*  
040696             0878*  ; &28-&2F 	40-47 	Solid line, both points omitted
040696             0879*  plot_sl_none: equ 0x28
040696             0880*  
040696             0881*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
040696             0882*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
040696             0883*  
040696             0884*  ; &40-&47 	64-71 	Point plot
040696             0885*  plot_pt: equ 0x40
040696             0886*  
040696             0887*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
040696             0888*  plot_lf_lr_non_bg: equ 0x48
040696             0889*  
040696             0890*  ; &50-&57 	80-87 	Triangle fill
040696             0891*  plot_tf: equ 0x50
040696             0892*  
040696             0893*  ; &58-&5F 	88-95 	Line fill right to background §§
040696             0894*  plot_lf_r_bg: equ 0x58
040696             0895*  
040696             0896*  ; &60-&67 	96-103 	Rectangle fill
040696             0897*  plot_rf: equ 0x60
040696             0898*  
040696             0899*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
040696             0900*  plot_lf_lr_fg: equ 0x60
040696             0901*  
040696             0902*  ; &70-&77 	112-119 	Parallelogram fill
040696             0903*  plot_pf: equ 0x70
040696             0904*  
040696             0905*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
040696             0906*  plot_lf_r_non_fg: equ 0x78
040696             0907*  
040696             0908*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
040696             0909*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
040696             0910*  
040696             0911*  ; &90-&97 	144-151 	Circle outline
040696             0912*  plot_co: equ 0x90
040696             0913*  
040696             0914*  ; &98-&9F 	152-159 	Circle fill
040696             0915*  plot_cf: equ 0x98
040696             0916*  
040696             0917*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
040696             0918*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
040696             0919*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
040696             0920*  
040696             0921*  ; &B8-&BF 	184-191 	Rectangle copy/move
040696             0922*  plot_rcm: equ 0xB8
040696             0923*  
040696             0924*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
040696             0925*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
040696             0926*  ; &D0-&D7 	208-215 	Not defined
040696             0927*  ; &D8-&DF 	216-223 	Not defined
040696             0928*  ; &E0-&E7 	224-231 	Not defined
040696             0929*  
040696             0930*  ; &E8-&EF 	232-239 	Bitmap plot §
040696             0931*  plot_bmp: equ 0xE8
040696             0932*  
040696             0933*  ; &F0-&F7 	240-247 	Not defined
040696             0934*  ; &F8-&FF 	248-255 	Not defined
040696             0935*  
040696             0936*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
040696             0937*  ; Agon Console8 VDP 2.2.0
040696             0938*  
040696             0939*  ; Within each group of eight plot codes, the effects are as follows:
040696             0940*  ; Plot code 	Effect
040696             0941*  ; 0 	Move relative
040696             0942*  mv_rel: equ 0
040696             0943*  
040696             0944*  ; 1 	Plot relative in current foreground colour
040696             0945*  dr_rel_fg: equ 1
040696             0946*  
040696             0947*  ; 2 	Not supported (Plot relative in logical inverse colour)
040696             0948*  ; 3 	Plot relative in current background colour
040696             0949*  dr_rel_bg: equ 3
040696             0950*  
040696             0951*  ; 4 	Move absolute
040696             0952*  mv_abs: equ 4
040696             0953*  
040696             0954*  ; 5 	Plot absolute in current foreground colour
040696             0955*  dr_abs_fg: equ 5
040696             0956*  
040696             0957*  ; 6 	Not supported (Plot absolute in logical inverse colour)
040696             0958*  ; 7 	Plot absolute in current background colour
040696             0959*  dr_abs_bg: equ 7
040696             0960*  
040696             0961*  ; Codes 0-3 use the position data provided as part of the command
040696             0962*  ; as a relative position, adding the position given to the current
040696             0963*  ; graphical cursor position. Codes 4-7 use the position data provided
040696             0964*  ; as part of the command as an absolute position, setting the current
040696             0965*  ; graphical cursor position to the position given.
040696             0966*  
040696             0967*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
040696             0968*  ; current pixel colour. These operations cannot currently be supported
040696             0969*  ; by the graphics system the Agon VDP uses, so these codes are not
040696             0970*  ; supported. Support for these codes may be added in a future version
040696             0971*  ; of the VDP firmware.
040696             0972*  
040696             0973*  ; 16 colour palette constants
040696             0974*  c_black: equ 0
040696             0975*  c_red_dk: equ 1
040696             0976*  c_green_dk: equ 2
040696             0977*  c_yellow_dk: equ 3
040696             0978*  c_blue_dk: equ 4
040696             0979*  c_magenta_dk: equ 5
040696             0980*  c_cyan_dk: equ 6
040696             0981*  c_grey: equ 7
040696             0982*  c_grey_dk: equ 8
040696             0983*  c_red: equ 9
040696             0984*  c_green: equ 10
040696             0985*  c_yellow: equ 11
040696             0986*  c_blue: equ 12
040696             0987*  c_magenta: equ 13
040696             0988*  c_cyan: equ 14
040696             0989*  c_white: equ 15
040696             0990*  
040696             0991*  ; VDU 25, mode, x; y;: PLOT command
040696             0992*  ; inputs: a=mode, bc=x0, de=y0
040696             0993*  vdu_plot:
040696 32 B0 06 04 0994*      ld (@mode),a
04069A ED 43 B1 06 0995*      ld (@x0),bc
       04          
04069F ED 53 B3 06 0996*      ld (@y0),de
       04          
0406A4 21 AF 06 04 0997*  	ld hl,@cmd
0406A8 01 06 00 00 0998*  	ld bc,@end-@cmd
0406AC 5B DF       0999*  	rst.lil $18
0406AE C9          1000*  	ret
0406AF 19          1001*  @cmd:   db 25
0406B0 00          1002*  @mode:  db 0
0406B1 00 00       1003*  @x0: 	dw 0
0406B3 00 00       1004*  @y0: 	dw 0
0406B5 00          1005*  @end:   db 0 ; extra byte to soak up deu
0406B6             1006*  
0406B6             1007*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0406B6             1008*  ; &E8-&EF 	232-239 	Bitmap plot §
0406B6             1009*  ; VDU 25, mode, x; y;: PLOT command
0406B6             1010*  ; inputs: bc=x0, de=y0
0406B6             1011*  ; prerequisites: vdu_buff_select
0406B6             1012*  vdu_plot_bmp:
0406B6 ED 43 CD 06 1013*      ld (@x0),bc
       04          
0406BB ED 53 CF 06 1014*      ld (@y0),de
       04          
0406C0 21 CB 06 04 1015*  	ld hl,@cmd
0406C4 01 06 00 00 1016*  	ld bc,@end-@cmd
0406C8 5B DF       1017*  	rst.lil $18
0406CA C9          1018*  	ret
0406CB 19          1019*  @cmd:   db 25
0406CC ED          1020*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0406CD 00 00       1021*  @x0: 	dw 0x0000
0406CF 00 00       1022*  @y0: 	dw 0x0000
0406D1 00          1023*  @end:   db 0x00 ; padding
0406D2             1024*  
0406D2             1025*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0406D2             1026*  ; &E8-&EF 	232-239 	Bitmap plot §
0406D2             1027*  ; VDU 25, mode, x; y;: PLOT command
0406D2             1028*  ; inputs: bc=x0, de=y0
0406D2             1029*  ; USING 16.8 FIXED POINT COORDINATES
0406D2             1030*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
0406D2             1031*  ;   the fractional portiion of the inputs are truncated
0406D2             1032*  ;   leaving only the 16-bit integer portion
0406D2             1033*  ; prerequisites: vdu_buff_select
0406D2             1034*  vdu_plot_bmp168:
0406D2             1035*  ; populate in the reverse of normal to keep the
0406D2             1036*  ; inputs from stomping on each other
0406D2 ED 53 F0 06 1037*      ld (@y0-1),de
       04          
0406D7 ED 43 EE 06 1038*      ld (@x0-1),bc
       04          
0406DC 3E ED       1039*      ld a,plot_bmp+dr_abs_fg ; 0xED
0406DE 32 EE 06 04 1040*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
0406E2 21 ED 06 04 1041*  	ld hl,@cmd
0406E6 01 06 00 00 1042*  	ld bc,@end-@cmd
0406EA 5B DF       1043*  	rst.lil $18
0406EC C9          1044*  	ret
0406ED 19          1045*  @cmd:   db 25
0406EE ED          1046*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0406EF 00 00       1047*  @x0: 	dw 0x0000
0406F1 00 00       1048*  @y0: 	dw 0x0000
0406F3             1049*  @end:  ; no padding required b/c we shifted de right
0406F3             1050*  
0406F3             1051*  ; draw a filled rectangle
0406F3             1052*  vdu_plot_rf:
0406F3 ED 43 1A 07 1053*      ld (@x0),bc
       04          
0406F8 ED 53 1C 07 1054*      ld (@y0),de
       04          
0406FD DD 22 20 07 1055*      ld (@x1),ix
       04          
040702 FD 22 22 07 1056*      ld (@y1),iy
       04          
040707 3E 19       1057*      ld a,25 ; we have to reload the 2nd plot command
040709 32 1E 07 04 1058*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
04070D 21 18 07 04 1059*  	ld hl,@cmd0
040711 01 0C 00 00 1060*  	ld bc,@end-@cmd0
040715 5B DF       1061*  	rst.lil $18
040717 C9          1062*      ret
040718 19          1063*  @cmd0:  db 25 ; plot
040719 04          1064*  @arg0:  db plot_sl_both+mv_abs
04071A 00 00       1065*  @x0:    dw 0x0000
04071C 00 00       1066*  @y0:    dw 0x0000
04071E 19          1067*  @cmd1:  db 25 ; plot
04071F 65          1068*  @arg1:  db plot_rf+dr_abs_fg
040720 00 00       1069*  @x1:    dw 0x0000
040722 00 00       1070*  @y1:    dw 0x0000
040724 00          1071*  @end:   db 0x00 ; padding
040725             1072*  
040725             1073*  ; draw a filled circle
040725             1074*  vdu_plot_cf:
040725 ED 43 4C 07 1075*      ld (@x0),bc
       04          
04072A ED 53 4E 07 1076*      ld (@y0),de
       04          
04072F DD 22 52 07 1077*      ld (@x1),ix
       04          
040734 FD 22 54 07 1078*      ld (@y1),iy
       04          
040739 3E 19       1079*      ld a,25 ; we have to reload the 2nd plot command
04073B 32 50 07 04 1080*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
04073F 21 4A 07 04 1081*  	ld hl,@cmd0
040743 01 0C 00 00 1082*  	ld bc,@end-@cmd0
040747 5B DF       1083*  	rst.lil $18
040749 C9          1084*      ret
04074A 19          1085*  @cmd0:  db 25 ; plot
04074B 04          1086*  @arg0:  db plot_sl_both+mv_abs
04074C 00 00       1087*  @x0:    dw 0x0000
04074E 00 00       1088*  @y0:    dw 0x0000
040750 19          1089*  @cmd1:  db 25 ; plot
040751 9D          1090*  @arg1:  db plot_cf+dr_abs_fg
040752 00 00       1091*  @x1:    dw 0x0000
040754 00 00       1092*  @y1:    dw 0x0000
040756 00          1093*  @end:   db 0x00 ; padding
040757             1094*  
040757             1095*  ; #### from vdu_sprites.asm ####
040757             1096*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
040757             1097*  ; the VDP can support up to 256 sprites. They must be defined
040757             1098*  ; contiguously, and so the first sprite is sprite 0.
040757             1099*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
040757             1100*  ; Once a selection of sprites have been defined, you can activate
040757             1101*  ; them using the VDU 23, 27, 7, n command, where n is the number
040757             1102*  ; of sprites to activate. This will activate the first n sprites,
040757             1103*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
040757             1104*  
040757             1105*  ; A single sprite can have multiple "frames", referring to
040757             1106*  ; different bitmaps.
040757             1107*  ; (These bitmaps do not need to be the same size.)
040757             1108*  ; This allows a sprite to include an animation sequence,
040757             1109*  ; which can be stepped through one frame at a time, or picked
040757             1110*  ; in any order.
040757             1111*  
040757             1112*  ; Any format of bitmap can be used as a sprite frame. It should
040757             1113*  ; be noted however that "native" format bitmaps are not
040757             1114*  ; recommended for use as sprite frames, as they cannot get
040757             1115*  ; erased from the screen. (As noted above, the "native" bitmap
040757             1116*  ; format is not really intended for general use.) This is part
040757             1117*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
040757             1118*  ; screen are now stored in RGBA2222 format.
040757             1119*  
040757             1120*  ; An "active" sprite can be hidden, so it will stop being drawn,
040757             1121*  ; and then later shown again.
040757             1122*  
040757             1123*  ; Moving sprites around the screen is done by changing the
040757             1124*  ; position of the sprite. This can be done either by setting
040757             1125*  ; the absolute position of the sprite, or by moving the sprite
040757             1126*  ; by a given number of pixels. (Sprites are positioned using
040757             1127*  ; pixel coordinates, and not by the logical OS coordinate system.)
040757             1128*  ; In the current sprite system, sprites will not update their
040757             1129*  ; position on-screen until either another drawing operation is
040757             1130*  ; performed or an explicit VDU 23, 27, 15 command is performed.
040757             1131*  
040757             1132*  ; Here are the sprite commands:
040757             1133*  ;
040757             1134*  ; VDU 23, 27, 4,  n: Select sprite n
040757             1135*  ; inputs: a is the 8-bit sprite id
040757             1136*  ; vdu_sprite_select:
040757             1137*  
040757             1138*  ; VDU 23, 27, 5:  Clear frames in current sprite
040757             1139*  ; inputs: none
040757             1140*  ; prerequisites: vdu_sprite_select
040757             1141*  ; vdu_sprite_clear_frames:
040757             1142*  
040757             1143*  ; VDU 23, 27, 6,  n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
040757             1144*  ; inputs: a is the 8-bit bitmap number
040757             1145*  ; prerequisites: vdu_sprite_select
040757             1146*  ; vdu_sprite_add_bmp:
040757             1147*  
040757             1148*  ; VDU 23, 27, 7,  n: Activate n sprites
040757             1149*  ; inputs: a is the number of sprites to activate
040757             1150*  ; vdu_sprite_activate:
040757             1151*  
040757             1152*  ; VDU 23, 27, 8:  Select next frame of current sprite
040757             1153*  ; inputs: none
040757             1154*  ; prerequisites: vdu_sprite_select
040757             1155*  ; vdu_sprite_next_frame:
040757             1156*  
040757             1157*  ; VDU 23, 27, 9:  Select previous frame of current sprite
040757             1158*  ; inputs: none
040757             1159*  ; prerequisites: vdu_sprite_select
040757             1160*  ; vdu_sprite_prev_frame:
040757             1161*  
040757             1162*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
040757             1163*  ; inputs: a is frame number to select
040757             1164*  ; prerequisites: vdu_sprite_select
040757             1165*  ; vdu_sprite_select_frame:
040757             1166*  
040757             1167*  ; VDU 23, 27, 11: Show current sprite
040757             1168*  ; inputs: none
040757             1169*  ; prerequisites: vdu_sprite_select
040757             1170*  ; vdu_sprite_show:
040757             1171*  
040757             1172*  ; VDU 23, 27, 12: Hide current sprite
040757             1173*  ; inputs: none
040757             1174*  ; prerequisites: vdu_sprite_select
040757             1175*  ; vdu_sprite_hide:
040757             1176*  
040757             1177*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
040757             1178*  ; inputs: bc is x coordinate, de is y coordinate
040757             1179*  ; prerequisites: vdu_sprite_select
040757             1180*  ; vdu_sprite_move_abs:
040757             1181*  ;
040757             1182*  ; USING 16.8 FIXED POINT COORDINATES
040757             1183*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
040757             1184*  ;   the fractional portiion of the inputs are truncated
040757             1185*  ;   leaving only the 16-bit integer portion
040757             1186*  ; prerequisites: vdu_sprite_select
040757             1187*  ; vdu_sprite_move_abs168:
040757             1188*  
040757             1189*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
040757             1190*  ; inputs: bc is x coordinate, de is y coordinate
040757             1191*  ; prerequisites: vdu_sprite_select
040757             1192*  ; vdu_sprite_move_rel:
040757             1193*  ;
040757             1194*  ; USING 16.8 FIXED POINT COORDINATES
040757             1195*  ; inputs: ub.c is dx, ud.e is dy
040757             1196*  ;   the fractional portiion of the inputs are truncated
040757             1197*  ;   leaving only the 16-bit integer portion
040757             1198*  ; prerequisites: vdu_sprite_select
040757             1199*  ; vdu_sprite_move_rel168:
040757             1200*  
040757             1201*  ; VDU 23, 27, 15: Update the sprites in the GPU
040757             1202*  ; inputs: none
040757             1203*  ; vdu_sprite_update:
040757             1204*  
040757             1205*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
040757             1206*  ; inputs: none
040757             1207*  ; vdu_sprite_bmp_reset:
040757             1208*  
040757             1209*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
040757             1210*  ; inputs: none
040757             1211*  ; vdu_sprite_reset:
040757             1212*  
040757             1213*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
040757             1214*  ; inputs: a is the GCOL paint mode
040757             1215*  ; prerequisites: vdu_sprite_select
040757             1216*  ; vdu_sprite_set_gcol:
040757             1217*  
040757             1218*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
040757             1219*  ; inputs: hl=bufferId
040757             1220*  ; prerequisites: vdu_sprite_select
040757             1221*  ; vdu_sprite_add_buff:
040757             1222*  
040757             1223*  @dummy_label: ; dummy label to serve as a break from the above comments and the below code
040757             1224*  
040757             1225*  ; VDU 23, 27, 4, n: Select sprite n
040757             1226*  ; inputs: a is the 8-bit sprite id
040757             1227*  vdu_sprite_select:
040757 32 69 07 04 1228*      ld (@sprite),a
04075B 21 66 07 04 1229*      ld hl,@cmd
04075F 01 04 00 00 1230*      ld bc,@end-@cmd
040763 5B DF       1231*      rst.lil $18
040765 C9          1232*      ret
040766 17 1B 04    1233*  @cmd:    db 23,27,4
040769 00          1234*  @sprite: db 0x00
04076A             1235*  @end:
04076A             1236*  
04076A             1237*  ; VDU 23, 27, 5: Clear frames in current sprite
04076A             1238*  ; inputs: none
04076A             1239*  ; prerequisites: vdu_sprite_select
04076A             1240*  vdu_sprite_clear_frames:
04076A 21 75 07 04 1241*      ld hl,@cmd
04076E 01 03 00 00 1242*      ld bc,@end-@cmd
040772 5B DF       1243*      rst.lil $18
040774 C9          1244*      ret
040775 17 1B 05    1245*  @cmd: db 23,27,5
040778             1246*  @end:
040778             1247*  
040778             1248*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
040778             1249*  ; inputs: a is the 8-bit bitmap number
040778             1250*  ; prerequisites: vdu_sprite_select
040778             1251*  vdu_sprite_add_bmp:
040778 32 8A 07 04 1252*      ld (@bmp),a
04077C 21 87 07 04 1253*      ld hl,@cmd
040780 01 04 00 00 1254*      ld bc,@end-@cmd
040784 5B DF       1255*      rst.lil $18
040786 C9          1256*      ret
040787 17 1B 06    1257*  @cmd: db 23,27,6
04078A 00          1258*  @bmp: db 0x00
04078B             1259*  @end:
04078B             1260*  
04078B             1261*  ; VDU 23, 27, 7, n: Activate n sprites
04078B             1262*  ; inputs: a is the number of sprites to activate
04078B             1263*  vdu_sprite_activate:
04078B 32 9D 07 04 1264*      ld (@num),a
04078F 21 9A 07 04 1265*      ld hl,@cmd
040793 01 04 00 00 1266*      ld bc,@end-@cmd
040797 5B DF       1267*      rst.lil $18
040799 C9          1268*      ret
04079A 17 1B 07    1269*  @cmd: db 23,27,7
04079D 00          1270*  @num: db 0x00
04079E             1271*  @end:
04079E             1272*  
04079E             1273*  ; VDU 23, 27, 8: Select next frame of current sprite
04079E             1274*  ; inputs: none
04079E             1275*  ; prerequisites: vdu_sprite_select
04079E             1276*  vdu_sprite_next_frame:
04079E 21 A9 07 04 1277*      ld hl,@cmd
0407A2 01 03 00 00 1278*      ld bc,@end-@cmd
0407A6 5B DF       1279*      rst.lil $18
0407A8 C9          1280*      ret
0407A9 17 1B 08    1281*  @cmd: db 23,27,8
0407AC             1282*  @end:
0407AC             1283*  
0407AC             1284*  ; VDU 23, 27, 9: Select previous frame of current sprite
0407AC             1285*  ; inputs: none
0407AC             1286*  ; prerequisites: vdu_sprite_select
0407AC             1287*  vdu_sprite_prev_frame:
0407AC 21 B7 07 04 1288*      ld hl,@cmd
0407B0 01 03 00 00 1289*      ld bc,@end-@cmd
0407B4 5B DF       1290*      rst.lil $18
0407B6 C9          1291*      ret
0407B7 17 1B 09    1292*  @cmd: db 23,27,9
0407BA             1293*  @end:
0407BA             1294*  
0407BA             1295*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
0407BA             1296*  ; inputs: a is frame number to select
0407BA             1297*  ; prerequisites: vdu_sprite_select
0407BA             1298*  vdu_sprite_select_frame:
0407BA 32 CC 07 04 1299*      ld (@frame),a
0407BE 21 C9 07 04 1300*      ld hl,@cmd
0407C2 01 04 00 00 1301*      ld bc,@end-@cmd
0407C6 5B DF       1302*      rst.lil $18
0407C8 C9          1303*      ret
0407C9 17 1B 0A    1304*  @cmd:    db 23,27,10
0407CC 00          1305*  @frame:  db 0x00
0407CD             1306*  @end:
0407CD             1307*  
0407CD             1308*  ; VDU 23, 27, 11: Show current sprite
0407CD             1309*  ; inputs: none
0407CD             1310*  ; prerequisites: vdu_sprite_select
0407CD             1311*  vdu_sprite_show:
0407CD 21 D8 07 04 1312*      ld hl,@cmd
0407D1 01 03 00 00 1313*      ld bc,@end-@cmd
0407D5 5B DF       1314*      rst.lil $18
0407D7 C9          1315*      ret
0407D8 17 1B 0B    1316*  @cmd: db 23,27,11
0407DB             1317*  @end:
0407DB             1318*  
0407DB             1319*  ; VDU 23, 27, 12: Hide current sprite
0407DB             1320*  ; inputs: none
0407DB             1321*  ; prerequisites: vdu_sprite_select
0407DB             1322*  vdu_sprite_hide:
0407DB 21 E6 07 04 1323*      ld hl,@cmd
0407DF 01 03 00 00 1324*      ld bc,@end-@cmd
0407E3 5B DF       1325*      rst.lil $18
0407E5 C9          1326*      ret
0407E6 17 1B 0C    1327*  @cmd: db 23,27,12
0407E9             1328*  @end:
0407E9             1329*  
0407E9             1330*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
0407E9             1331*  ; inputs: bc is x coordinate, de is y coordinate
0407E9             1332*  ; prerequisites: vdu_sprite_select
0407E9             1333*  vdu_sprite_move_abs:
0407E9 ED 43 01 08 1334*      ld (@xpos),bc
       04          
0407EE ED 53 03 08 1335*      ld (@ypos),de
       04          
0407F3 21 FE 07 04 1336*      ld hl,@cmd
0407F7 01 07 00 00 1337*      ld bc,@end-@cmd
0407FB 5B DF       1338*      rst.lil $18
0407FD C9          1339*      ret
0407FE 17 1B 0D    1340*  @cmd:  db 23,27,13
040801 00 00       1341*  @xpos: dw 0x0000
040803 00 00       1342*  @ypos: dw 0x0000
040805 00          1343*  @end:  db 0x00 ; padding
040806             1344*  
040806             1345*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
040806             1346*  ; inputs: bc is x coordinate, de is y coordinate
040806             1347*  ; prerequisites: vdu_sprite_select
040806             1348*  vdu_sprite_move_rel:
040806 ED 43 1E 08 1349*      ld (@dx),bc
       04          
04080B ED 53 20 08 1350*      ld (@dy),de
       04          
040810 21 1B 08 04 1351*      ld hl,@cmd
040814 01 07 00 00 1352*      ld bc,@end-@cmd
040818 5B DF       1353*      rst.lil $18
04081A C9          1354*      ret
04081B 17 1B 0E    1355*  @cmd: db 23,27,14
04081E 00 00       1356*  @dx:  dw 0x0000
040820 00 00       1357*  @dy:  dw 0x0000
040822 00          1358*  @end: db 0x00 ; padding
040823             1359*  
040823             1360*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
040823             1361*  ; USING 16.8 FIXED POINT COORDINATES
040823             1362*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
040823             1363*  ;   the fractional portiion of the inputs are truncated
040823             1364*  ;   leaving only the 16-bit integer portion
040823             1365*  ; prerequisites: vdu_sprite_select
040823             1366*  vdu_sprite_move_abs168:
040823             1367*  ; populate in the reverse of normal to keep the
040823             1368*  ; inputs from stomping on each other
040823 ED 53 42 08 1369*      ld (@ypos-1),de
       04          
040828 ED 43 40 08 1370*      ld (@xpos-1),bc
       04          
04082D 3E 0D       1371*      ld a,13       ; restore the final byte of the command
04082F 32 40 08 04 1372*      ld (@cmd+2),a ; string that got stomped on by bcu
040833 21 3E 08 04 1373*      ld hl,@cmd
040837 01 07 00 00 1374*      ld bc,@end-@cmd
04083B 5B DF       1375*      rst.lil $18
04083D C9          1376*      ret
04083E 17 1B 0D    1377*  @cmd:  db 23,27,13
040841 00 00       1378*  @xpos: dw 0x0000
040843 00 00       1379*  @ypos: dw 0x0000
040845             1380*  @end:  ; no padding required b/c we shifted de right
040845             1381*  
040845             1382*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
040845             1383*  ; USING 16.8 FIXED POINT COORDINATES
040845             1384*  ; inputs: ub.c is dx, ud.e is dy
040845             1385*  ;   the fractional portiion of the inputs are truncated
040845             1386*  ;   leaving only the 16-bit integer portion
040845             1387*  ; prerequisites: vdu_sprite_select
040845             1388*  vdu_sprite_move_rel168:
040845             1389*  ; populate in the reverse of normal to keep the
040845             1390*  ; inputs from stomping on each other
040845 ED 53 64 08 1391*      ld (@dy-1),de
       04          
04084A ED 43 62 08 1392*      ld (@dx-1),bc
       04          
04084F 3E 0E       1393*      ld a,14       ; restore the final byte of the command
040851 32 62 08 04 1394*      ld (@cmd+2),a ; string that got stomped on by bcu
040855 21 60 08 04 1395*      ld hl,@cmd
040859 01 07 00 00 1396*      ld bc,@end-@cmd
04085D 5B DF       1397*      rst.lil $18
04085F C9          1398*      ret
040860 17 1B 0E    1399*  @cmd:  db 23,27,14
040863 00 00       1400*  @dx: dw 0x0000
040865 00 00       1401*  @dy: dw 0x0000
040867             1402*  @end:  ; no padding required b/c we shifted de right
040867             1403*  
040867             1404*  ; VDU 23, 27, 15: Update the sprites in the GPU
040867             1405*  ; inputs: none
040867             1406*  vdu_sprite_update:
040867 21 72 08 04 1407*      ld hl,@cmd
04086B 01 03 00 00 1408*      ld bc,@end-@cmd
04086F 5B DF       1409*      rst.lil $18
040871 C9          1410*      ret
040872 17 1B 0F    1411*  @cmd: db 23,27,15
040875             1412*  @end:
040875             1413*  
040875             1414*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
040875             1415*  ; inputs: none
040875             1416*  vdu_sprite_bmp_reset:
040875 21 80 08 04 1417*      ld hl,@cmd
040879 01 03 00 00 1418*      ld bc,@end-@cmd
04087D 5B DF       1419*      rst.lil $18
04087F C9          1420*      ret
040880 17 1B 10    1421*  @cmd: db 23,27,16
040883             1422*  @end:
040883             1423*  
040883             1424*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
040883             1425*  ; inputs: none
040883             1426*  vdu_sprite_reset:
040883 21 8E 08 04 1427*      ld hl,@cmd
040887 01 03 00 00 1428*      ld bc,@end-@cmd
04088B 5B DF       1429*      rst.lil $18
04088D C9          1430*      ret
04088E 17 1B 11    1431*  @cmd: db 23,27,17
040891             1432*  @end:
040891             1433*  
040891             1434*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
040891             1435*  ; inputs: a is the GCOL paint mode
040891             1436*  ; prerequisites: vdu_sprite_select
040891             1437*  vdu_sprite_set_gcol:
040891 32 A3 08 04 1438*      ld (@mode),a
040895 21 A0 08 04 1439*      ld hl,@cmd
040899 01 04 00 00 1440*      ld bc,@end-@cmd
04089D 5B DF       1441*      rst.lil $18
04089F C9          1442*      ret
0408A0 17 1B 12    1443*  @cmd:  db 23,27,18
0408A3 00          1444*  @mode: db 0x00
0408A4             1445*  @end:
0408A4             1446*  
0408A4             1447*  ; VDU 23, 27, &26, n;: Add bitmap bufferId
0408A4             1448*  ;     as a frame to current sprite using a 16-bit buffer ID
0408A4             1449*  ; inputs: hl=bufferId
0408A4             1450*  ; prerequisites: vdu_sprite_select
0408A4             1451*  vdu_sprite_add_buff:
0408A4 22 B6 08 04 1452*      ld (@bufferId),hl
0408A8 21 B3 08 04 1453*      ld hl,@cmd
0408AC 01 05 00 00 1454*      ld bc,@end-@cmd
0408B0 5B DF       1455*      rst.lil $18
0408B2 C9          1456*      ret
0408B3 17 1B 26    1457*  @cmd:      db 23,27,0x26
0408B6 00 00       1458*  @bufferId: dw 0x0000
0408B8 00          1459*  @end:      db 0x00 ; padding
0408B9             1460*  
0408B9             1461*  
0408B9             1462*  ; #### from sfx.asm ####
0408B9 00          1463*  sfx_last_channel: db 0x00 ; 8-bit value between 0 and 31
0408BA             1464*  
0408BA             1465*  vdu_clear_all_buffers:
0408BA             1466*  ; clear all buffers
0408BA 21 C5 08 04 1467*      ld hl,@beg
0408BE 01 06 00 00 1468*      ld bc,@end-@beg
0408C2 5B DF       1469*      rst.lil $18
0408C4 C9          1470*      ret
0408C5 17 00 A0    1471*  @beg: db 23,0,$A0
0408C8 FF FF       1472*        dw -1 ; clear all buffers
0408CA 02          1473*        db 2  ; command 2: clear a buffer
0408CB             1474*  @end:
0408CB             0342       include "pingo/src/asm/vdu_pingo.asm"
0408CB             0001*  ; Create Control Structure
0408CB             0002*  ; VDU 23, 0, &A0, sid; &49, 0, w; h; : Create Control Structure
0408CB             0003*  ; This command initializes a control structure used to do 3D rendering. The structure is housed inside the designated buffer. The buffer referred to by the scene ID (sid) is created, if it does not already exist.
0408CB             0004*  ; The given width and height determine the size of the final rendered scene.
0408CB             0005*  ; inputs: bc = w; de = h;
0408CB             0006*  vdu_3d_crt_ctl_str:
0408CB ED 43 E7 08 0007*      ld (@w),bc
       04          
0408D0 ED 53 E9 08 0008*      ld (@h),de
       04          
0408D5 21 E0 08 04 0009*      ld hl,@beg
0408D9 01 0B 00 00 0010*      ld bc,@end-@beg
0408DD 5B DF       0011*      rst.lil $18
0408DF C9          0012*      ret
0408E0 17 00 A0    0013*  @beg: db 23, 0, $A0
0408E3 64 00       0014*  @sid: dw sid
0408E5 49 00       0015*  @cmd: db $49, 0 ; command 0: create control structure
0408E7 00 00       0016*  @w:   dw 0x0000
0408E9 00 00       0017*  @h:   dw 0x0000
0408EB 00          0018*  @end: db 0x00 ; padding
0408EC             0019*  
0408EC             0020*  ; Define Mesh Vertices
0408EC             0021*  ; VDU 23, 0, &A0, sid; &49, 1, mid; n; x0; y0; z0; ... : Define Mesh Vertices
0408EC             0022*  ; This command establishes the list of mesh coordinates to be used to define a surface structure. The mesh may be referenced by multiple objects.
0408EC             0023*  ; The "n" parameter is the number of vertices, so the total number of coordinates specified equals n*3.
0408EC             0024*  ; inputs: hl = mid; bc = n; de = pointer to list of coordinates
0408EC             0025*  vdu_3d_def_msh_verts:
0408EC C5          0026*      push bc ; save n
0408ED 22 12 09 04 0027*      ld (@mid),hl
0408F1 ED 43 FA 0D 0028*      ld (@n),bc
       04          
0408F6 21 0B 09 04 0029*      ld hl,@beg
0408FA 01 0B 00 00 0030*      ld bc,@end-@beg
0408FE 5B DF       0031*      rst.lil $18
040900 E1          0032*      pop hl ; restore n
040901 E5          0033*      push hl ; save n
040902 29          0034*      add hl,hl ; n*2
040903 C1          0035*      pop bc ; restore n
040904 09          0036*      add hl,bc ; n*2+n = n*3 = total number of bytes in list of coordinates
040905 44          0037*      ld b,h
040906 4D          0038*      ld c,l ; bc = number of bytes
040907 EB          0039*      ex de,hl ; hl is pointer to list of coordinates
040908 5B DF       0040*      rst.lil $18
04090A C9          0041*      ret
04090B 17 00 A0    0042*  @beg: db 23, 0, $A0
04090E 64 00       0043*  @sid: dw sid
040910 49 01       0044*  @cmd: db $49, 1 ; command 1: define mesh vertices
040912 00 00       0045*  @mid: dw 0x0000
040914 00 00       0046*  @n:   dw 0x0000
040916 00          0047*  @end: db 0x00 ; padding
040917             0048*  
040917             0049*  ; Set Mesh Vertex Indexes
040917             0050*  ; VDU 23, 0, &A0, sid; &49, 2, mid; n; i0; ... : Set Mesh Vertex Indexes
040917             0051*  ; This command lists the indexes of the vertices that define a 3D mesh.
040917             0052*  ; Individual vertices are often referenced multiple times within a mesh, because they are often part of multiple surface triangles.
040917             0053*  ; Each index value ranges from 0 to the number of defined mesh vertices.
040917             0054*  ; The "n" parameter is the number of indexes, and must match the "n" in subcommand 4 (Set Texture Coordinate Indexes).
040917             0055*  ; inputs: hl = mid; bc = n; de = pointer to list of indexes
040917             0056*  vdu_3d_set_msh_vert_idxs:
040917 C5          0057*      push bc ; save n
040918 22 37 09 04 0058*      ld (@mid),hl
04091C ED 43 FA 0D 0059*      ld (@n),bc
       04          
040921 21 30 09 04 0060*      ld hl,@beg
040925 01 0B 00 00 0061*      ld bc,@end-@beg
040929 5B DF       0062*      rst.lil $18
04092B C1          0063*      pop bc ; restore n
04092C EB          0064*      ex de,hl ; hl is pointer to list of indexes
04092D 5B DF       0065*      rst.lil $18
04092F C9          0066*      ret
040930 17 00 A0    0067*  @beg: db 23, 0, $A0
040933 64 00       0068*  @sid: dw sid
040935 49 02       0069*  @cmd: db $49, 2 ; command 2: set mesh vertex indexes
040937 00 00       0070*  @mid: dw 0x0000
040939 00 00       0071*  @n:   dw 0x0000
04093B 00          0072*  @end: db 0x00 ; padding
04093C             0073*  
04093C             0074*  ; Define Texture Coordinates
04093C             0075*  ; VDU 23, 0, &A0, sid; &49, 3, mid; n; u0; v0; ... : Define Texture Coordinates
04093C             0076*  ; This command establishes the list of U/V texture coordinates that define texturing for a mesh.
04093C             0077*  ; The "n" parameter is the number of coordinate pairs, so the total number of coordinates specified equals n*2.
04093C             0078*  ; inputs: hl = mid; bc = n; de = pointer to list of coordinates
04093C             0079*  vdu_3d_def_tex_coords:
04093C C5          0080*      push bc ; save n
04093D 22 5F 09 04 0081*      ld (@mid),hl
040941 ED 43 FA 0D 0082*      ld (@n),bc
       04          
040946 21 58 09 04 0083*      ld hl,@beg
04094A 01 0B 00 00 0084*      ld bc,@end-@beg
04094E 5B DF       0085*      rst.lil $18
040950 E1          0086*      pop hl ; restore n
040951 29          0087*      add hl,hl ; n*2
040952 44          0088*      ld b,h
040953 4D          0089*      ld c,l ; bc = number of bytes
040954 EB          0090*      ex de,hl ; hl is pointer to list of coordinates
040955 5B DF       0091*      rst.lil $18
040957 C9          0092*      ret
040958 17 00 A0    0093*  @beg: db 23, 0, $A0
04095B 64 00       0094*  @sid: dw sid
04095D 49 03       0095*  @cmd: db $49, 3 ; command 3: define texture coordinates
04095F 00 00       0096*  @mid: dw 0x0000
040961 00 00       0097*  @n:   dw 0x0000
040963 00          0098*  @end: db 0x00 ; padding
040964             0099*  
040964             0100*  ; Set Texture Coordinate Indexes
040964             0101*  ; VDU 23, 0, &A0, sid; &49, 4, mid; n; i0; ... : Set Texture Coordinate Indexes
040964             0102*  ; This command lists the indexes of the coordinates that define a 3D texture for a mesh. Individual coordinates may be referenced multiple times within a texture, but that is not required.
040964             0103*  ; The number of indexes passed in this command must match the number of mesh indexes defining the mesh.
040964             0104*  ; Thus, each mesh vertex has texture coordinates associated with it.
040964             0105*  ; The "n" parameter is the number of indexes, and must match the "n" in subcommand 2 (Set Mesh Vertex Indexes).
040964             0106*  ; inputs: hl = mid; bc = n; de = pointer to list of indexes
040964             0107*  vdu_3d_set_tex_coord_idxs:
040964 C5          0108*      push bc ; save n
040965 22 84 09 04 0109*      ld (@mid),hl
040969 ED 43 FA 0D 0110*      ld (@n),bc
       04          
04096E 21 7D 09 04 0111*      ld hl,@beg
040972 01 0B 00 00 0112*      ld bc,@end-@beg
040976 5B DF       0113*      rst.lil $18
040978 C1          0114*      pop bc ; restore n
040979 EB          0115*      ex de,hl ; hl is pointer to list of indexes
04097A 5B DF       0116*      rst.lil $18
04097C C9          0117*      ret
04097D 17 00 A0    0118*  @beg: db 23, 0, $A0
040980 64 00       0119*  @sid: dw sid
040982 49 04       0120*  @cmd: db $49, 4 ; command 4: set texture coordinate indexes
040984 00 00       0121*  @mid: dw 0x0000
040986 00 00       0122*  @n:   dw 0x0000
040988 00          0123*  @end: db 0x00 ; padding
040989             0124*  
040989             0125*  ; Define Object
040989             0126*  ; VDU 23, 0, &A0, sid; &49, 5, oid; mid; bmid; : Create Object
040989             0127*  ; This command defines a renderable object in terms of its already-defined mesh, plus a reference to an existing bitmap that provides its coloring, via the texture coordinates used by the mesh.
040989             0128*  ; The same mesh can be used multiple times, with the same or different bitmaps for coloring. The bitmap must be in the RGBA8888 format (4 bytes per pixel).
040989             0129*  ; inputs: hl = oid; de = mid; bc = bmid;
040989             0130*  vdu_3d_def_obj:
040989 22 A9 09 04 0131*      ld (@oid),hl
04098D ED 53 AB 09 0132*      ld (@mid),de
       04          
040992 ED 43 AD 09 0133*      ld (@bmid),bc
       04          
040997 21 A2 09 04 0134*      ld hl,@beg
04099B 01 0D 00 00 0135*      ld bc,@end-@beg
04099F 5B DF       0136*      rst.lil $18
0409A1 C9          0137*      ret
0409A2 17 00 A0    0138*  @beg: db 23, 0, $A0
0409A5 64 00       0139*  @sid: dw sid
0409A7 49 05       0140*  @cmd: db $49, 5 ; command 5: define object
0409A9 00 00       0141*  @oid: dw 0x0000
0409AB 00 00       0142*  @mid: dw 0x0000
0409AD 00 00       0143*  @bmid: dw 0x0000
0409AF 00          0144*  @end: db 0x00 ; padding
0409B0             0145*  
0409B0             0146*  ; Set Object X Scale Factor
0409B0             0147*  ; VDU 23, 0, &A0, sid; &49, 6, oid; scalex; : Set Object X Scale Factor
0409B0             0148*  ; This command sets the X scale factor for an object.
0409B0             0149*  ; inputs: hl = oid; bc = scalex;
0409B0             0150*  vdu_3d_set_obj_x_scl:
0409B0 22 CB 09 04 0151*      ld (@oid),hl
0409B4 ED 43 CD 09 0152*      ld (@scalex),bc
       04          
0409B9 21 C4 09 04 0153*      ld hl,@beg
0409BD 01 0B 00 00 0154*      ld bc,@end-@beg
0409C1 5B DF       0155*      rst.lil $18
0409C3 C9          0156*      ret
0409C4 17 00 A0    0157*  @beg: db 23, 0, $A0
0409C7 64 00       0158*  @sid: dw sid
0409C9 49 06       0159*  @cmd: db $49, 6 ; command 6: set object x scale factor
0409CB 00 00       0160*  @oid: dw 0x0000
0409CD 00 00       0161*  @scalex: dw 0x0000
0409CF 00          0162*  @end: db 0x00 ; padding
0409D0             0163*  
0409D0             0164*  ; Set Object Y Scale Factor
0409D0             0165*  ; VDU 23, 0, &A0, sid; &49, 7, oid; scaley; : Set Object Y Scale Factor
0409D0             0166*  ; This command sets the Y scale factor for an object.
0409D0             0167*  ; inputs: hl = oid; bc = scaley;
0409D0             0168*  vdu_3d_set_obj_y_scl:
0409D0 22 EB 09 04 0169*      ld (@oid),hl
0409D4 ED 43 ED 09 0170*      ld (@scaley),bc
       04          
0409D9 21 E4 09 04 0171*      ld hl,@beg
0409DD 01 0B 00 00 0172*      ld bc,@end-@beg
0409E1 5B DF       0173*      rst.lil $18
0409E3 C9          0174*      ret
0409E4 17 00 A0    0175*  @beg: db 23, 0, $A0
0409E7 64 00       0176*  @sid: dw sid
0409E9 49 07       0177*  @cmd: db $49, 7 ; command 7: set object y scale factor
0409EB 00 00       0178*  @oid: dw 0x0000
0409ED 00 00       0179*  @scaley: dw 0x0000
0409EF 00          0180*  @end: db 0x00 ; padding
0409F0             0181*  
0409F0             0182*  ; Set Object Z Scale Factor
0409F0             0183*  ; VDU 23, 0, &A0, sid; &49, 8, oid; scalez; : Set Object Z Scale Factor
0409F0             0184*  ; This command sets the Z scale factor for an object.
0409F0             0185*  ; inputs: hl = oid; bc = scalez;
0409F0             0186*  vdu_3d_set_obj_z_scl:
0409F0 22 0B 0A 04 0187*      ld (@oid),hl
0409F4 ED 43 0D 0A 0188*      ld (@scalez),bc
       04          
0409F9 21 04 0A 04 0189*      ld hl,@beg
0409FD 01 0B 00 00 0190*      ld bc,@end-@beg
040A01 5B DF       0191*      rst.lil $18
040A03 C9          0192*      ret
040A04 17 00 A0    0193*  @beg: db 23, 0, $A0
040A07 64 00       0194*  @sid: dw sid
040A09 49 08       0195*  @cmd: db $49, 8 ; command 8: set object z scale factor
040A0B 00 00       0196*  @oid: dw 0x0000
040A0D 00 00       0197*  @scalez: dw 0x0000
040A0F 00          0198*  @end: db 0x00 ; padding
040A10             0199*  
040A10             0200*  ; Set Object XYZ Scale Factors
040A10             0201*  ; VDU 23, 0, &A0, sid; &49, 9, oid; scalex; scaley; scalez; : Set Object XYZ Scale Factors
040A10             0202*  ; This command sets the X, Y, and Z scale factors for an object.
040A10             0203*  ; inputs: hl = oid; ix = scalex; iy = scaley; bc = scalez;
040A10             0204*  vdu_3d_set_obj_xyz_scl:
040A10 22 35 0A 04 0205*      ld (@oid),hl
040A14 DD 22 37 0A 0206*      ld (@scalex),ix
       04          
040A19 FD 22 39 0A 0207*      ld (@scaley),iy
       04          
040A1E ED 43 3B 0A 0208*      ld (@scalez),bc
       04          
040A23 21 2E 0A 04 0209*      ld hl,@beg
040A27 01 0F 00 00 0210*      ld bc,@end-@beg
040A2B 5B DF       0211*      rst.lil $18
040A2D C9          0212*      ret
040A2E 17 00 A0    0213*  @beg: db 23, 0, $A0
040A31 64 00       0214*  @sid: dw sid
040A33 49 09       0215*  @cmd: db $49, 9 ; command 9: set object xyz scale factors
040A35 00 00       0216*  @oid: dw 0x0000
040A37 00 00       0217*  @scalex: dw 0x0000
040A39 00 00       0218*  @scaley: dw 0x0000
040A3B 00 00       0219*  @scalez: dw 0x0000
040A3D 00          0220*  @end: db 0x00 ; padding
040A3E             0221*  
040A3E             0222*  ; Set Object X Rotation Angle
040A3E             0223*  ; VDU 23, 0, &A0, sid; &49, 10, oid; anglex; : Set Object X Rotation Angle
040A3E             0224*  ; This command sets the X rotation angle for an object.
040A3E             0225*  ; inputs: hl = oid; bc = anglex;
040A3E             0226*  vdu_3d_set_obj_x_rot:
040A3E 22 59 0A 04 0227*      ld (@oid),hl
040A42 ED 43 5B 0A 0228*      ld (@anglex),bc
       04          
040A47 21 52 0A 04 0229*      ld hl,@beg
040A4B 01 0B 00 00 0230*      ld bc,@end-@beg
040A4F 5B DF       0231*      rst.lil $18
040A51 C9          0232*      ret
040A52 17 00 A0    0233*  @beg: db 23, 0, $A0
040A55 64 00       0234*  @sid: dw sid
040A57 49 0A       0235*  @cmd: db $49, 10 ; command 10: set object x rotation angle
040A59 00 00       0236*  @oid: dw 0x0000
040A5B 00 00       0237*  @anglex: dw 0x0000
040A5D 00          0238*  @end: db 0x00 ; padding
040A5E             0239*  
040A5E             0240*  ; Set Object Y Rotation Angle
040A5E             0241*  ; VDU 23, 0, &A0, sid; &49, 11, oid; angley; : Set Object Y Rotation Angle
040A5E             0242*  ; This command sets the Y rotation angle for an object.
040A5E             0243*  ; inputs: hl = oid; bc = angley;
040A5E             0244*  vdu_3d_set_obj_y_rot:
040A5E 22 79 0A 04 0245*      ld (@oid),hl
040A62 ED 43 7B 0A 0246*      ld (@angley),bc
       04          
040A67 21 72 0A 04 0247*      ld hl,@beg
040A6B 01 0B 00 00 0248*      ld bc,@end-@beg
040A6F 5B DF       0249*      rst.lil $18
040A71 C9          0250*      ret
040A72 17 00 A0    0251*  @beg: db 23, 0, $A0
040A75 64 00       0252*  @sid: dw sid
040A77 49 0B       0253*  @cmd: db $49, 11 ; command 11: set object y rotation angle
040A79 00 00       0254*  @oid: dw 0x0000
040A7B 00 00       0255*  @angley: dw 0x0000
040A7D 00          0256*  @end: db 0x00 ; padding
040A7E             0257*  
040A7E             0258*  ; Set Object Z Rotation Angle
040A7E             0259*  ; VDU 23, 0, &A0, sid; &49, 12, oid; anglez; : Set Object Z Rotation Angle
040A7E             0260*  ; This command sets the Z rotation angle for an object.
040A7E             0261*  ; inputs: hl = oid; bc = anglez;
040A7E             0262*  vdu_3d_set_obj_z_rot:
040A7E 22 99 0A 04 0263*      ld (@oid),hl
040A82 ED 43 9B 0A 0264*      ld (@anglez),bc
       04          
040A87 21 92 0A 04 0265*      ld hl,@beg
040A8B 01 0B 00 00 0266*      ld bc,@end-@beg
040A8F 5B DF       0267*      rst.lil $18
040A91 C9          0268*      ret
040A92 17 00 A0    0269*  @beg: db 23, 0, $A0
040A95 64 00       0270*  @sid: dw sid
040A97 49 0C       0271*  @cmd: db $49, 12 ; command 12: set object z rotation angle
040A99 00 00       0272*  @oid: dw 0x0000
040A9B 00 00       0273*  @anglez: dw 0x0000
040A9D 00          0274*  @end: db 0x00 ; padding
040A9E             0275*  
040A9E             0276*  ; Set Object XYZ Rotation Angles
040A9E             0277*  ; VDU 23, 0, &A0, sid; &49, 13, oid; anglex; angley; anglez; : Set Object XYZ Rotation Angles
040A9E             0278*  ; This command sets the X, Y, and Z rotation angles for an object.
040A9E             0279*  ; inputs: hl = oid; ix = anglex; iy = angley; bc = anglez;
040A9E             0280*  vdu_3d_set_obj_xyz_rot:
040A9E 22 C3 0A 04 0281*      ld (@oid),hl
040AA2 DD 22 C5 0A 0282*      ld (@anglex),ix
       04          
040AA7 FD 22 C7 0A 0283*      ld (@angley),iy
       04          
040AAC ED 43 C9 0A 0284*      ld (@anglez),bc
       04          
040AB1 21 BC 0A 04 0285*      ld hl,@beg
040AB5 01 0F 00 00 0286*      ld bc,@end-@beg
040AB9 5B DF       0287*      rst.lil $18
040ABB C9          0288*      ret
040ABC 17 00 A0    0289*  @beg: db 23, 0, $A0
040ABF 64 00       0290*  @sid: dw sid
040AC1 49 0D       0291*  @cmd: db $49, 13 ; command 13: set object xyz rotation angles
040AC3 00 00       0292*  @oid: dw 0x0000
040AC5 00 00       0293*  @anglex: dw 0x0000
040AC7 00 00       0294*  @angley: dw 0x0000
040AC9 00 00       0295*  @anglez: dw 0x0000
040ACB 00          0296*  @end: db 0x00 ; padding
040ACC             0297*  
040ACC             0298*  ; Set Object X Translation Distance
040ACC             0299*  ; VDU 23, 0, &A0, sid; &49, 14, oid; distx; : Set Object X Translation Distance
040ACC             0300*  ; This command sets the X translation distance for an object. Note that 3D translation of an object is independent of 2D translation of the the rendered bitmap.
040ACC             0301*  ; inputs: hl = oid; bc = distx;
040ACC             0302*  vdu_3d_set_obj_x_trans:
040ACC 22 E7 0A 04 0303*      ld (@oid),hl
040AD0 ED 43 E9 0A 0304*      ld (@distx),bc
       04          
040AD5 21 E0 0A 04 0305*      ld hl,@beg
040AD9 01 0B 00 00 0306*      ld bc,@end-@beg
040ADD 5B DF       0307*      rst.lil $18
040ADF C9          0308*      ret
040AE0 17 00 A0    0309*  @beg: db 23, 0, $A0
040AE3 64 00       0310*  @sid: dw sid
040AE5 49 0E       0311*  @cmd: db $49, 14 ; command 14: set object x translation distance
040AE7 00 00       0312*  @oid: dw 0x0000
040AE9 00 00       0313*  @distx: dw 0x0000
040AEB 00          0314*  @end: db 0x00 ; padding
040AEC             0315*  
040AEC             0316*  ; Set Object Y Translation Distance
040AEC             0317*  ; VDU 23, 0, &A0, sid; &49, 15, oid; disty; : Set Object Y Translation Distance
040AEC             0318*  ; This command sets the Y translation distance for an object. Note that 3D translation of an object is independent of 2D translation of the the rendered bitmap.
040AEC             0319*  ; inputs: hl = oid; bc = disty;
040AEC             0320*  vdu_3d_set_obj_y_trans:
040AEC 22 07 0B 04 0321*      ld (@oid),hl
040AF0 ED 43 09 0B 0322*      ld (@disty),bc
       04          
040AF5 21 00 0B 04 0323*      ld hl,@beg
040AF9 01 0B 00 00 0324*      ld bc,@end-@beg
040AFD 5B DF       0325*      rst.lil $18
040AFF C9          0326*      ret
040B00 17 00 A0    0327*  @beg: db 23, 0, $A0
040B03 64 00       0328*  @sid: dw sid
040B05 49 0F       0329*  @cmd: db $49, 15 ; command 15: set object y translation distance
040B07 00 00       0330*  @oid: dw 0x0000
040B09 00 00       0331*  @disty: dw 0x0000
040B0B 00          0332*  @end: db 0x00 ; padding
040B0C             0333*  
040B0C             0334*  ; Set Object Z Translation Distance
040B0C             0335*  ; VDU 23, 0, &A0, sid; &49, 16, oid; distz; : Set Object Z Translation Distance
040B0C             0336*  ; This command sets the Z translation distance for an object. Note that 3D translation of an object is independent of 2D translation of the the rendered bitmap.
040B0C             0337*  ; inputs: hl = oid; bc = distz;
040B0C             0338*  vdu_3d_set_obj_z_trans:
040B0C 22 27 0B 04 0339*      ld (@oid),hl
040B10 ED 43 29 0B 0340*      ld (@distz),bc
       04          
040B15 21 20 0B 04 0341*      ld hl,@beg
040B19 01 0B 00 00 0342*      ld bc,@end-@beg
040B1D 5B DF       0343*      rst.lil $18
040B1F C9          0344*      ret
040B20 17 00 A0    0345*  @beg: db 23, 0, $A0
040B23 64 00       0346*  @sid: dw sid
040B25 49 10       0347*  @cmd: db $49, 16 ; command 16: set object z translation distance
040B27 00 00       0348*  @oid: dw 0x0000
040B29 00 00       0349*  @distz: dw 0x0000
040B2B 00          0350*  @end: db 0x00 ; padding
040B2C             0351*  
040B2C             0352*  ; Set Object XYZ Translation Distances
040B2C             0353*  ; VDU 23, 0, &A0, sid; &49, 17, oid; distx; disty; distz; : Set Object XYZ Translation Distances
040B2C             0354*  ; This command sets the X, Y, and Z translation distances for an object. Note that 3D translation of an object is independent of 2D translation of the the rendered bitmap.
040B2C             0355*  ; inputs: hl = oid; ix = distx; iy = disty; bc = distz;
040B2C             0356*  vdu_3d_set_obj_xyz_trans:
040B2C 22 51 0B 04 0357*      ld (@oid),hl
040B30 DD 22 53 0B 0358*      ld (@distx),ix
       04          
040B35 FD 22 55 0B 0359*      ld (@disty),iy
       04          
040B3A ED 43 57 0B 0360*      ld (@distz),bc
       04          
040B3F 21 4A 0B 04 0361*      ld hl,@beg
040B43 01 0F 00 00 0362*      ld bc,@end-@beg
040B47 5B DF       0363*      rst.lil $18
040B49 C9          0364*      ret
040B4A 17 00 A0    0365*  @beg: db 23, 0, $A0
040B4D 64 00       0366*  @sid: dw sid
040B4F 49 11       0367*  @cmd: db $49, 17 ; command 17: set object xyz translation distances
040B51 00 00       0368*  @oid: dw 0x0000
040B53 00 00       0369*  @distx: dw 0x0000
040B55 00 00       0370*  @disty: dw 0x0000
040B57 00 00       0371*  @distz: dw 0x0000
040B59 00          0372*  @end: db 0x00 ; padding
040B5A             0373*  
040B5A             0374*  ; Set Camera X Rotation Angle
040B5A             0375*  ; VDU 23, 0, &A0, sid; &49, 18, anglex; : Set Camera X Rotation Angle
040B5A             0376*  ; This command sets the X rotation angle for the camera.
040B5A             0377*  ; inputs: hl = anglex;
040B5A             0378*  vdu_3d_set_cam_x_rot:
040B5A 22 70 0B 04 0379*      ld (@anglex),hl
040B5E 21 69 0B 04 0380*      ld hl,@beg
040B62 01 09 00 00 0381*      ld bc,@end-@beg
040B66 5B DF       0382*      rst.lil $18
040B68 C9          0383*      ret
040B69 17 00 A0    0384*  @beg: db 23, 0, $A0
040B6C 64 00       0385*  @sid: dw sid
040B6E 49 12       0386*  @cmd: db $49, 18 ; command 18: set camera x rotation angle
040B70 00 00       0387*  @anglex: dw 0x0000
040B72 00          0388*  @end: db 0x00 ; padding
040B73             0389*  
040B73             0390*  ; Set Camera Y Rotation Angle
040B73             0391*  ; VDU 23, 0, &A0, sid; &49, 19, angley; : Set Camera Y Rotation Angle
040B73             0392*  ; This command sets the Y rotation angle for the camera.
040B73             0393*  ; inputs: hl = angley;
040B73             0394*  vdu_3d_set_cam_y_rot:
040B73 22 89 0B 04 0395*      ld (@angley),hl
040B77 21 82 0B 04 0396*      ld hl,@beg
040B7B 01 09 00 00 0397*      ld bc,@end-@beg
040B7F 5B DF       0398*      rst.lil $18
040B81 C9          0399*      ret
040B82 17 00 A0    0400*  @beg: db 23, 0, $A0
040B85 64 00       0401*  @sid: dw sid
040B87 49 13       0402*  @cmd: db $49, 19 ; command 19: set camera y rotation angle
040B89 00 00       0403*  @angley: dw 0x0000
040B8B 00          0404*  @end: db 0x00 ; padding
040B8C             0405*  
040B8C             0406*  ; Set Camera Z Rotation Angle
040B8C             0407*  ; VDU 23, 0, &A0, sid; &49, 20, anglez; : Set Camera Z Rotation Angle
040B8C             0408*  ; This command sets the Z rotation angle for the camera.
040B8C             0409*  ; inputs: hl = anglez;
040B8C             0410*  vdu_3d_set_cam_z_rot:
040B8C 22 A2 0B 04 0411*      ld (@anglez),hl
040B90 21 9B 0B 04 0412*      ld hl,@beg
040B94 01 09 00 00 0413*      ld bc,@end-@beg
040B98 5B DF       0414*      rst.lil $18
040B9A C9          0415*      ret
040B9B 17 00 A0    0416*  @beg: db 23, 0, $A0
040B9E 64 00       0417*  @sid: dw sid
040BA0 49 14       0418*  @cmd: db $49, 20 ; command 20: set camera z rotation angle
040BA2 00 00       0419*  @anglez: dw 0x0000
040BA4 00          0420*  @end: db 0x00 ; padding
040BA5             0421*  
040BA5             0422*  ; Set Camera XYZ Rotation Angles
040BA5             0423*  ; VDU 23, 0, &A0, sid; &49, 21, anglex; angley; anglez; : Set Camera XYZ Rotation Angles
040BA5             0424*  ; This command sets the X, Y, and Z rotation angles for the camera.
040BA5             0425*  ; inputs: ix = anglex; iy = angley; hl = anglez;
040BA5             0426*  vdu_3d_set_cam_xyz_rot:
040BA5 DD 22 C5 0B 0427*      ld (@anglex),ix
       04          
040BAA FD 22 C7 0B 0428*      ld (@angley),iy
       04          
040BAF 22 C9 0B 04 0429*      ld (@anglez),hl
040BB3 21 BE 0B 04 0430*      ld hl,@beg
040BB7 01 0D 00 00 0431*      ld bc,@end-@beg
040BBB 5B DF       0432*      rst.lil $18
040BBD C9          0433*      ret
040BBE 17 00 A0    0434*  @beg: db 23, 0, $A0
040BC1 64 00       0435*  @sid: dw sid
040BC3 49 15       0436*  @cmd: db $49, 21 ; command 21: set camera xyz rotation angles
040BC5 00 00       0437*  @anglex: dw 0x0000
040BC7 00 00       0438*  @angley: dw 0x0000
040BC9 00 00       0439*  @anglez: dw 0x0000
040BCB 00          0440*  @end: db 0x00 ; padding
040BCC             0441*  
040BCC             0442*  ; Set Camera X Translation Distance
040BCC             0443*  ; VDU 23, 0, &A0, sid; &49, 22, distx; : Set Camera X Translation Distance
040BCC             0444*  ; This command sets the X translation distance for the camera. Note that 3D translation of the camera is independent of 2D translation of the the rendered bitmap.
040BCC             0445*  ; inputs: hl = distx;
040BCC             0446*  vdu_3d_set_cam_x_trans:
040BCC 22 E2 0B 04 0447*      ld (@distx),hl
040BD0 21 DB 0B 04 0448*      ld hl,@beg
040BD4 01 09 00 00 0449*      ld bc,@end-@beg
040BD8 5B DF       0450*      rst.lil $18
040BDA C9          0451*      ret
040BDB 17 00 A0    0452*  @beg: db 23, 0, $A0
040BDE 64 00       0453*  @sid: dw sid
040BE0 49 16       0454*  @cmd: db $49, 22 ; command 22: set camera x translation distance
040BE2 00 00       0455*  @distx: dw 0x0000
040BE4 00          0456*  @end: db 0x00 ; padding
040BE5             0457*  
040BE5             0458*  ; Set Camera Y Translation Distance
040BE5             0459*  ; VDU 23, 0, &A0, sid; &49, 23, disty; : Set Camera Y Translation Distance
040BE5             0460*  ; This command sets the Y translation distance for the camera. Note that 3D translation of the camera is independent of 2D translation of the the rendered bitmap.
040BE5             0461*  ; inputs: hl = disty;
040BE5             0462*  vdu_3d_set_cam_y_trans:
040BE5 22 FB 0B 04 0463*      ld (@disty),hl
040BE9 21 F4 0B 04 0464*      ld hl,@beg
040BED 01 09 00 00 0465*      ld bc,@end-@beg
040BF1 5B DF       0466*      rst.lil $18
040BF3 C9          0467*      ret
040BF4 17 00 A0    0468*  @beg: db 23, 0, $A0
040BF7 64 00       0469*  @sid: dw sid
040BF9 49 17       0470*  @cmd: db $49, 23 ; command 23: set camera y translation distance
040BFB 00 00       0471*  @disty: dw 0x0000
040BFD 00          0472*  @end: db 0x00 ; padding
040BFE             0473*  
040BFE             0474*  ; Set Camera Z Translation Distance
040BFE             0475*  ; VDU 23, 0, &A0, sid; &49, 24, distz; : Set Camera Z Translation Distance
040BFE             0476*  ; This command sets the Z translation distance for the camera. Note that 3D translation of the camera is independent of 2D translation of the the rendered bitmap.
040BFE             0477*  ; inputs: hl = distz;
040BFE             0478*  vdu_3d_set_cam_z_trans:
040BFE 22 14 0C 04 0479*      ld (@distz),hl
040C02 21 0D 0C 04 0480*      ld hl,@beg
040C06 01 09 00 00 0481*      ld bc,@end-@beg
040C0A 5B DF       0482*      rst.lil $18
040C0C C9          0483*      ret
040C0D 17 00 A0    0484*  @beg: db 23, 0, $A0
040C10 64 00       0485*  @sid: dw sid
040C12 49 18       0486*  @cmd: db $49, 24 ; command 24: set camera z translation distance
040C14 00 00       0487*  @distz: dw 0x0000
040C16 00          0488*  @end: db 0x00 ; padding
040C17             0489*  
040C17             0490*  ; Set Camera XYZ Translation Distances
040C17             0491*  ; VDU 23, 0, &A0, sid; &49, 25, distx; disty; distz; : Set Camera XYZ Translation Distances
040C17             0492*  ; This command sets the X, Y, and Z translation distances for the camera. Note that 3D translation of the camera is independent of 2D translation of the the rendered bitmap.
040C17             0493*  ; inputs: ix = distx; iy = disty; hl = distz;
040C17             0494*  vdu_3d_set_cam_xyz_trans:
040C17 DD 22 37 0C 0495*      ld (@distx),ix
       04          
040C1C FD 22 39 0C 0496*      ld (@disty),iy
       04          
040C21 22 3B 0C 04 0497*      ld (@distz),hl
040C25 21 30 0C 04 0498*      ld hl,@beg
040C29 01 0D 00 00 0499*      ld bc,@end-@beg
040C2D 5B DF       0500*      rst.lil $18
040C2F C9          0501*      ret
040C30 17 00 A0    0502*  @beg: db 23, 0, $A0
040C33 64 00       0503*  @sid: dw sid
040C35 49 19       0504*  @cmd: db $49, 25 ; command 25: set camera xyz translation distances
040C37 00 00       0505*  @distx: dw 0x0000
040C39 00 00       0506*  @disty: dw 0x0000
040C3B 00 00       0507*  @distz: dw 0x0000
040C3D 00          0508*  @end: db 0x00 ; padding
040C3E             0509*  
040C3E             0510*  ; Set Scene X Scale Factor
040C3E             0511*  ; VDU 23, 0, &A0, sid; &49, 26, scalex; : Set Scene X Scale Factor
040C3E             0512*  ; This command sets the X scale factor for the scene.
040C3E             0513*  ; inputs: hl = scalex;
040C3E             0514*  vdu_3d_set_scn_x_scl:
040C3E 22 54 0C 04 0515*      ld (@scalex),hl
040C42 21 4D 0C 04 0516*      ld hl,@beg
040C46 01 09 00 00 0517*      ld bc,@end-@beg
040C4A 5B DF       0518*      rst.lil $18
040C4C C9          0519*      ret
040C4D 17 00 A0    0520*  @beg: db 23, 0, $A0
040C50 64 00       0521*  @sid: dw sid
040C52 49 1A       0522*  @cmd: db $49, 26 ; command 26: set scene x scale factor
040C54 00 00       0523*  @scalex: dw 0x0000
040C56 00          0524*  @end: db 0x00 ; padding
040C57             0525*  
040C57             0526*  ; Set Scene Y Scale Factor
040C57             0527*  ; VDU 23, 0, &A0, sid; &49, 27, scaley; : Set Scene Y Scale Factor
040C57             0528*  ; This command sets the Y scale factor for the scene.
040C57             0529*  ; inputs: hl = scaley;
040C57             0530*  vdu_3d_set_scn_y_scl:
040C57 22 6D 0C 04 0531*      ld (@scaley),hl
040C5B 21 66 0C 04 0532*      ld hl,@beg
040C5F 01 09 00 00 0533*      ld bc,@end-@beg
040C63 5B DF       0534*      rst.lil $18
040C65 C9          0535*      ret
040C66 17 00 A0    0536*  @beg: db 23, 0, $A0
040C69 64 00       0537*  @sid: dw sid
040C6B 49 1B       0538*  @cmd: db $49, 27 ; command 27: set scene y scale factor
040C6D 00 00       0539*  @scaley: dw 0x0000
040C6F 00          0540*  @end: db 0x00 ; padding
040C70             0541*  
040C70             0542*  ; Set Scene Z Scale Factor
040C70             0543*  ; VDU 23, 0, &A0, sid; &49, 28, scalez; : Set Scene Z Scale Factor
040C70             0544*  ; This command sets the Z scale factor for the scene.
040C70             0545*  ; inputs: hl = scalez;
040C70             0546*  vdu_3d_set_scn_z_scl:
040C70 22 86 0C 04 0547*      ld (@scalez),hl
040C74 21 7F 0C 04 0548*      ld hl,@beg
040C78 01 09 00 00 0549*      ld bc,@end-@beg
040C7C 5B DF       0550*      rst.lil $18
040C7E C9          0551*      ret
040C7F 17 00 A0    0552*  @beg: db 23, 0, $A0
040C82 64 00       0553*  @sid: dw sid
040C84 49 1C       0554*  @cmd: db $49, 28 ; command 28: set scene z scale factor
040C86 00 00       0555*  @scalez: dw 0x0000
040C88 00          0556*  @end: db 0x00 ; padding
040C89             0557*  
040C89             0558*  ; Set Scene XYZ Scale Factors
040C89             0559*  ; VDU 23, 0, &A0, sid; &49, 29, scalex; scaley; scalez; : Set Scene XYZ Scale Factors
040C89             0560*  ; This command sets the X, Y, and Z scale factors for the scene.
040C89             0561*  ; inputs: ix = scalex; iy = scaley; hl = scalez;
040C89             0562*  vdu_3d_set_scn_xyz_scl:
040C89 DD 22 A9 0C 0563*      ld (@scalex),ix
       04          
040C8E FD 22 AB 0C 0564*      ld (@scaley),iy
       04          
040C93 22 AD 0C 04 0565*      ld (@scalez),hl
040C97 21 A2 0C 04 0566*      ld hl,@beg
040C9B 01 0D 00 00 0567*      ld bc,@end-@beg
040C9F 5B DF       0568*      rst.lil $18
040CA1 C9          0569*      ret
040CA2 17 00 A0    0570*  @beg: db 23, 0, $A0
040CA5 64 00       0571*  @sid: dw sid
040CA7 49 1D       0572*  @cmd: db $49, 29 ; command 29: set scene xyz scale factors
040CA9 00 00       0573*  @scalex: dw 0x0000
040CAB 00 00       0574*  @scaley: dw 0x0000
040CAD 00 00       0575*  @scalez: dw 0x0000
040CAF 00          0576*  @end: db 0x00 ; padding
040CB0             0577*  ; Set Scene X Rotation Angle
040CB0             0578*  ; VDU 23, 0, &A0, sid; &49, 30, anglex; : Set Scene X Rotation Angle
040CB0             0579*  ; This command sets the X rotation angle for the scene.
040CB0             0580*  ; inputs: hl = anglex;
040CB0             0581*  vdu_3d_set_scn_x_rot:
040CB0 22 C6 0C 04 0582*      ld (@anglex),hl
040CB4 21 BF 0C 04 0583*      ld hl,@beg
040CB8 01 09 00 00 0584*      ld bc,@end-@beg
040CBC 5B DF       0585*      rst.lil $18
040CBE C9          0586*      ret
040CBF 17 00 A0    0587*  @beg: db 23, 0, $A0
040CC2 64 00       0588*  @sid: dw sid
040CC4 49 1E       0589*  @cmd: db $49, 30 ; command 30: set scene x rotation angle
040CC6 00 00       0590*  @anglex: dw 0x0000
040CC8 00          0591*  @end: db 0x00 ; padding
040CC9             0592*  
040CC9             0593*  ; Set Scene Y Rotation Angle
040CC9             0594*  ; VDU 23, 0, &A0, sid; &49, 31, angley; : Set Scene Y Rotation Angle
040CC9             0595*  ; This command sets the Y rotation angle for the scene.
040CC9             0596*  ; inputs: hl = angley;
040CC9             0597*  vdu_3d_set_scn_y_rot:
040CC9 22 DF 0C 04 0598*      ld (@angley),hl
040CCD 21 D8 0C 04 0599*      ld hl,@beg
040CD1 01 09 00 00 0600*      ld bc,@end-@beg
040CD5 5B DF       0601*      rst.lil $18
040CD7 C9          0602*      ret
040CD8 17 00 A0    0603*  @beg: db 23, 0, $A0
040CDB 64 00       0604*  @sid: dw sid
040CDD 49 1F       0605*  @cmd: db $49, 31 ; command 31: set scene y rotation angle
040CDF 00 00       0606*  @angley: dw 0x0000
040CE1 00          0607*  @end: db 0x00 ; padding
040CE2             0608*  
040CE2             0609*  ; Set Scene Z Rotation Angle
040CE2             0610*  ; VDU 23, 0, &A0, sid; &49, 32, anglez; : Set Scene Z Rotation Angle
040CE2             0611*  ; This command sets the Z rotation angle for the scene.
040CE2             0612*  ; inputs: hl = anglez;
040CE2             0613*  vdu_3d_set_scn_z_rot:
040CE2 22 F8 0C 04 0614*      ld (@anglez),hl
040CE6 21 F1 0C 04 0615*      ld hl,@beg
040CEA 01 09 00 00 0616*      ld bc,@end-@beg
040CEE 5B DF       0617*      rst.lil $18
040CF0 C9          0618*      ret
040CF1 17 00 A0    0619*  @beg: db 23, 0, $A0
040CF4 64 00       0620*  @sid: dw sid
040CF6 49 20       0621*  @cmd: db $49, 32 ; command 32: set scene z rotation angle
040CF8 00 00       0622*  @anglez: dw 0x0000
040CFA 00          0623*  @end: db 0x00 ; padding
040CFB             0624*  
040CFB             0625*  ; Set Scene XYZ Rotation Angles
040CFB             0626*  ; VDU 23, 0, &A0, sid; &49, 33, anglex; angley; anglez; : Set Scene XYZ Rotation Angles
040CFB             0627*  ; This command sets the X, Y, and Z rotation angles for the scene.
040CFB             0628*  ; inputs: ix = anglex; iy = angley; hl = anglez;
040CFB             0629*  vdu_3d_set_scn_xyz_rot:
040CFB DD 22 1B 0D 0630*      ld (@anglex),ix
       04          
040D00 FD 22 1D 0D 0631*      ld (@angley),iy
       04          
040D05 22 1F 0D 04 0632*      ld (@anglez),hl
040D09 21 14 0D 04 0633*      ld hl,@beg
040D0D 01 0D 00 00 0634*      ld bc,@end-@beg
040D11 5B DF       0635*      rst.lil $18
040D13 C9          0636*      ret
040D14 17 00 A0    0637*  @beg: db 23, 0, $A0
040D17 64 00       0638*  @sid: dw sid
040D19 49 21       0639*  @cmd: db $49, 33 ; command 33: set scene xyz rotation angles
040D1B 00 00       0640*  @anglex: dw 0x0000
040D1D 00 00       0641*  @angley: dw 0x0000
040D1F 00 00       0642*  @anglez: dw 0x0000
040D21 00          0643*  @end: db 0x00 ; padding
040D22             0644*  ; Set Scene X Translation Distance
040D22             0645*  ; VDU 23, 0, &A0, sid; &49, 34, distx; : Set Scene X Translation Distance
040D22             0646*  ; This command sets the X translation distance for the scene. Note that 3D translation of the scene is independent of 2D translation of the the rendered bitmap.
040D22             0647*  ; inputs: hl = distx;
040D22             0648*  vdu_3d_set_scn_x_trans:
040D22 22 38 0D 04 0649*      ld (@distx),hl
040D26 21 31 0D 04 0650*      ld hl,@beg
040D2A 01 09 00 00 0651*      ld bc,@end-@beg
040D2E 5B DF       0652*      rst.lil $18
040D30 C9          0653*      ret
040D31 17 00 A0    0654*  @beg: db 23, 0, $A0
040D34 64 00       0655*  @sid: dw sid
040D36 49 22       0656*  @cmd: db $49, 34 ; command 34: set scene x translation distance
040D38 00 00       0657*  @distx: dw 0x0000
040D3A 00          0658*  @end: db 0x00 ; padding
040D3B             0659*  
040D3B             0660*  ; Set Scene Y Translation Distance
040D3B             0661*  ; VDU 23, 0, &A0, sid; &49, 35, disty; : Set Scene Y Translation Distance
040D3B             0662*  ; This command sets the Y translation distance for the scene. Note that 3D translation of the scene is independent of 2D translation of the the rendered bitmap.
040D3B             0663*  ; inputs: hl = disty;
040D3B             0664*  vdu_3d_set_scn_y_trans:
040D3B 22 51 0D 04 0665*      ld (@disty),hl
040D3F 21 4A 0D 04 0666*      ld hl,@beg
040D43 01 09 00 00 0667*      ld bc,@end-@beg
040D47 5B DF       0668*      rst.lil $18
040D49 C9          0669*      ret
040D4A 17 00 A0    0670*  @beg: db 23, 0, $A0
040D4D 64 00       0671*  @sid: dw sid
040D4F 49 23       0672*  @cmd: db $49, 35 ; command 35: set scene y translation distance
040D51 00 00       0673*  @disty: dw 0x0000
040D53 00          0674*  @end: db 0x00 ; padding
040D54             0675*  
040D54             0676*  ; Set Scene Z Translation Distance
040D54             0677*  ; VDU 23, 0, &A0, sid; &49, 36, distz; : Set Scene Z Translation Distance
040D54             0678*  ; This command sets the Z translation distance for the scene. Note that 3D translation of the scene is independent of 2D translation of the the rendered bitmap.
040D54             0679*  ; inputs: hl = distz;
040D54             0680*  vdu_3d_set_scn_z_trans:
040D54 22 6A 0D 04 0681*      ld (@distz),hl
040D58 21 63 0D 04 0682*      ld hl,@beg
040D5C 01 09 00 00 0683*      ld bc,@end-@beg
040D60 5B DF       0684*      rst.lil $18
040D62 C9          0685*      ret
040D63 17 00 A0    0686*  @beg: db 23, 0, $A0
040D66 64 00       0687*  @sid: dw sid
040D68 49 24       0688*  @cmd: db $49, 36 ; command 36: set scene z translation distance
040D6A 00 00       0689*  @distz: dw 0x0000
040D6C 00          0690*  @end: db 0x00 ; padding
040D6D             0691*  
040D6D             0692*  ; Set Scene XYZ Translation Distances
040D6D             0693*  ; VDU 23, 0, &A0, sid; &49, 37, distx; disty; distz; : Set Scene XYZ Translation Distances
040D6D             0694*  ; This command sets the X, Y, and Z translation distances for the scene. Note that 3D translation of the scene is independent of 2D translation of the the rendered bitmap.
040D6D             0695*  ; inputs: ix = distx; iy = disty; hl = distz;
040D6D             0696*  vdu_3d_set_scn_xyz_trans:
040D6D DD 22 8D 0D 0697*      ld (@distx),ix
       04          
040D72 FD 22 8F 0D 0698*      ld (@disty),iy
       04          
040D77 22 91 0D 04 0699*      ld (@distz),hl
040D7B 21 86 0D 04 0700*      ld hl,@beg
040D7F 01 0D 00 00 0701*      ld bc,@end-@beg
040D83 5B DF       0702*      rst.lil $18
040D85 C9          0703*      ret
040D86 17 00 A0    0704*  @beg: db 23, 0, $A0
040D89 64 00       0705*  @sid: dw sid
040D8B 49 25       0706*  @cmd: db $49, 37 ; command 37: set scene xyz translation distances
040D8D 00 00       0707*  @distx: dw 0x0000
040D8F 00 00       0708*  @disty: dw 0x0000
040D91 00 00       0709*  @distz: dw 0x0000
040D93 00          0710*  @end: db 0x00 ; padding
040D94             0711*  
040D94             0712*  ; Render To Bitmap
040D94             0713*  ; VDU 23, 0, &A0, sid; &49, 38, bmid; : Render To Bitmap
040D94             0714*  ; This command uses information provided by the above commands to render the 3D scene onto the specified bitmap.
040D94             0715*  ; This command must be used in order to perform the render operation; it does not happen automatically when other commands change some of the render parameters.
040D94             0716*  ; inputs: bc = bmid;
040D94             0717*  vdu_3d_render_to_bitmap:
040D94 ED 43 AB 0D 0718*      ld (@bmid),bc
       04          
040D99 21 A4 0D 04 0719*      ld hl,@beg
040D9D 01 09 00 00 0720*      ld bc,@end-@beg
040DA1 5B DF       0721*      rst.lil $18
040DA3 C9          0722*      ret
040DA4 17 00 A0    0723*  @beg: db 23, 0, $A0
040DA7 64 00       0724*  @sid: dw sid
040DA9 49 26       0725*  @cmd: db $49, 38 ; command 38: render to bitmap
040DAB 00 00       0726*  @bmid: dw 0x0000
040DAD 00          0727*  @end: db 0x00 ; padding
040DAE             0728*  
040DAE             0729*  ; Delete Control Structure
040DAE             0730*  ; VDU 23, 0, &A0, sid; &49, 39 : Delete Control Structure
040DAE             0731*  ; This command deinitializes an existing control structure, assuming that it exists in the designated buffer. The buffer is subsequently deleted, as part of processing for this command.
040DAE             0732*  ; inputs: none
040DAE             0733*  vdu_3d_del_ctl_str:
040DAE 21 B9 0D 04 0734*      ld hl,@beg
040DB2 01 07 00 00 0735*      ld bc,@end-@beg
040DB6 5B DF       0736*      rst.lil $18
040DB8 C9          0737*      ret
040DB9 17 00 A0    0738*  @beg: db 23, 0, $A0
040DBC 64 00       0739*  @sid: dw sid
040DBE 49 27       0740*  @cmd: db $49, 39 ; command 39: delete control structure
040DC0             0741*  @end:
040DC0             0343       include "pingo/src/asm/functions.asm"
040DC0             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040DC0             0002*  ; Print a zero-terminated string
040DC0             0003*  ; HL: Pointer to string
040DC0             0004*  printString:
040DC0 C5          0005*  	PUSH	BC
040DC1 01 00 00 00 0006*  	LD		BC,0
040DC5 3E 00       0007*  	LD 	 	A,0
040DC7 5B DF       0008*  	RST.LIL 18h
040DC9 C1          0009*  	POP		BC
040DCA C9          0010*  	RET
040DCB             0011*  ; print a VDU sequence
040DCB             0012*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040DCB             0013*  sendVDUsequence:
040DCB C5          0014*  	PUSH	BC
040DCC 01 00 00 00 0015*  	LD		BC, 0
040DD0 4E          0016*  	LD		C, (HL)
040DD1 5B DF       0017*  	RST.LIL	18h
040DD3 C1          0018*  	POP		BC
040DD4 C9          0019*  	RET
040DD5             0020*  ; Print Newline sequence to VDP
040DD5             0021*  printNewLine:
040DD5 3E 0D       0022*  	LD	A, '\r'
040DD7 5B D7       0023*  	RST.LIL 10h
040DD9 3E 0A       0024*  	LD	A, '\n'
040DDB 5B D7       0025*  	RST.LIL 10h
040DDD C9          0026*  	RET
040DDE             0027*  ; Print a 24-bit HEX number
040DDE             0028*  ; HLU: Number to print
040DDE             0029*  printHex24:
040DDE E5          0030*  	PUSH	HL
040DDF 21 02 00 00 0031*  	LD		HL, 2
040DE3 39          0032*  	ADD		HL, SP
040DE4 7E          0033*  	LD		A, (HL)
040DE5 E1          0034*  	POP		HL
040DE6 CD F0 0D 04 0035*  	CALL	printHex8
040DEA             0036*  ; Print a 16-bit HEX number
040DEA             0037*  ; HL: Number to print
040DEA             0038*  printHex16:
040DEA 7C          0039*  	LD		A,H
040DEB CD F0 0D 04 0040*  	CALL	printHex8
040DEF 7D          0041*  	LD		A,L
040DF0             0042*  ; Print an 8-bit HEX number
040DF0             0043*  ; A: Number to print
040DF0             0044*  printHex8:
040DF0 4F          0045*  	LD		C,A
040DF1 1F          0046*  	RRA
040DF2 1F          0047*  	RRA
040DF3 1F          0048*  	RRA
040DF4 1F          0049*  	RRA
040DF5 CD FA 0D 04 0050*  	CALL	@F
040DF9 79          0051*  	LD		A,C
040DFA             0052*  @@:
040DFA E6 0F       0053*  	AND		0Fh
040DFC C6 90       0054*  	ADD		A,90h
040DFE 27          0055*  	DAA
040DFF CE 40       0056*  	ADC		A,40h
040E01 27          0057*  	DAA
040E02 5B D7       0058*  	RST.LIL	10h
040E04 C9          0059*  	RET
040E05             0060*  
040E05             0061*  ; Print a 0x HEX prefix
040E05             0062*  DisplayHexPrefix:
040E05 3E 30       0063*  	LD	A, '0'
040E07 5B D7       0064*  	RST.LIL 10h
040E09 3E 78       0065*  	LD	A, 'x'
040E0B 5B D7       0066*  	RST.LIL 10h
040E0D C9          0067*  	RET
040E0E             0068*  
040E0E             0069*  
040E0E             0070*  ; Prints the right justified decimal value in HL without leading zeroes
040E0E             0071*  ; HL : Value to print
040E0E             0072*  printDec:
040E0E 11 32 0E 04 0073*  	LD	 DE, _printDecBuffer
040E12 CD 3B 0E 04 0074*  	CALL Num2String
040E16             0075*  ; BEGIN MY CODE
040E16             0076*  ; replace leading zeroes with spaces
040E16 21 32 0E 04 0077*      LD	 HL, _printDecBuffer
040E1A 06 07       0078*      ld   B, 7 ; if HL was 0, we want to keep the final zero
040E1C             0079*  @loop:
040E1C 7E          0080*      LD	 A, (HL)
040E1D FE 30       0081*      CP	 '0'
040E1F C2 2D 0E 04 0082*      JP	 NZ, @done
040E23 3E 20       0083*      LD   A, ' '
040E25 77          0084*      LD	 (HL), A
040E26 23          0085*      INC	 HL
040E27 CD 6D 03 04 0086*      CALL vdu_cursor_forward
040E2B 10 EF       0087*      DJNZ @loop
040E2D             0088*  @done:
040E2D             0089*  ; END MY CODE
040E2D             0090*  	; LD	 HL, _printDecBuffer
040E2D CD C0 0D 04 0091*  	CALL printString
040E31 C9          0092*  	RET
040E32 00 00 00 00 0093*  _printDecBuffer: blkb 9,0 ; nine bytes full of zeroes
       00 00 00 00 
       00          
040E3B             0094*  
040E3B             0095*  ; This routine converts the value from HL into it's ASCII representation,
040E3B             0096*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040E3B             0097*  ; so it will allways be 8 characters length
040E3B             0098*  ; HL : Value to convert to string
040E3B             0099*  ; DE : pointer to buffer, at least 8 byte + 0
040E3B             0100*  Num2String:
040E3B 01 80 69 67 0101*  	LD	 BC,-10000000
040E3F CD 72 0E 04 0102*  	CALL OneDigit
040E43 01 C0 BD F0 0103*  	LD	 BC,-1000000
040E47 CD 72 0E 04 0104*  	CALL OneDigit
040E4B 01 60 79 FE 0105*  	LD	 BC,-100000
040E4F CD 72 0E 04 0106*  	CALL OneDigit
040E53 01 F0 D8 FF 0107*  	LD   BC,-10000
040E57 CD 72 0E 04 0108*  	CALL OneDigit
040E5B 01 18 FC FF 0109*  	LD   BC,-1000
040E5F CD 72 0E 04 0110*  	CALL OneDigit
040E63 01 9C FF FF 0111*  	LD   BC,-100
040E67 CD 72 0E 04 0112*  	CALL OneDigit
040E6B 0E F6       0113*  	LD   C,-10
040E6D CD 72 0E 04 0114*  	CALL OneDigit
040E71 48          0115*  	LD   C,B
040E72             0116*  OneDigit:
040E72 3E 2F       0117*  	LD   A,'0'-1
040E74             0118*  DivideMe:
040E74 3C          0119*  	INC  A
040E75 09          0120*  	ADD  HL,BC
040E76 38 FC       0121*  	JR   C,DivideMe
040E78 ED 42       0122*  	SBC  HL,BC
040E7A 12          0123*  	LD   (DE),A
040E7B 13          0124*  	INC  DE
040E7C C9          0125*  	RET
040E7D             0126*  
040E7D             0127*  
040E7D             0128*  ; #### new functions added by Brandon R. Gates ####
040E7D             0129*  
040E7D             0130*  ; print the binary representation of the 8-bit value in a
040E7D             0131*  ; destroys a, hl, bc
040E7D             0132*  printBin8:
040E7D 06 08       0133*      ld b,8      ; loop counter for 8 bits
040E7F 21 9A 0E 04 0134*      ld hl,@cmd  ; set hl to the low byte of the output string
040E83             0135*                  ; (which will be the high bit of the value in a)
040E83             0136*  @loop:
040E83 07          0137*      rlca ; put the next highest bit into carry
040E84 38 04       0138*      jr c,@one
040E86 36 30       0139*      ld (hl),'0'
040E88 18 02       0140*      jr @next_bit
040E8A             0141*  @one:
040E8A 36 31       0142*      ld (hl),'1'
040E8C             0143*  @next_bit:
040E8C 23          0144*      inc hl
040E8D 10 F4       0145*      djnz @loop
040E8F             0146*  ; print it
040E8F 21 9A 0E 04 0147*  	ld hl,@cmd
040E93 01 08 00 00 0148*  	ld bc,@end-@cmd
040E97 5B DF       0149*  	rst.lil $18
040E99 C9          0150*  	ret
040E9A             0151*  @cmd: ds 8 ; eight bytes for eight bits
040EA2             0152*  @end:
040EA2             0153*  
040EA2             0154*  ; print the binary representation of the 8-bit value in a
040EA2             0155*  ; in reverse order (lsb first)
040EA2             0156*  ; destroys a, hl, bc
040EA2             0157*  printBin8Rev:
040EA2 06 08       0158*      ld b,8      ; loop counter for 8 bits
040EA4 21 BF 0E 04 0159*      ld hl,@cmd  ; set hl to the low byte of the output string
040EA8             0160*                  ; (which will be the high bit of the value in a)
040EA8             0161*  @loop:
040EA8 0F          0162*      rrca ; put the next lowest bit into carry
040EA9 38 04       0163*      jr c,@one
040EAB 36 30       0164*      ld (hl),'0'
040EAD 18 02       0165*      jr @next_bit
040EAF             0166*  @one:
040EAF 36 31       0167*      ld (hl),'1'
040EB1             0168*  @next_bit:
040EB1 23          0169*      inc hl
040EB2 10 F4       0170*      djnz @loop
040EB4             0171*  ; print it
040EB4 21 BF 0E 04 0172*  	ld hl,@cmd
040EB8 01 08 00 00 0173*  	ld bc,@end-@cmd
040EBC 5B DF       0174*  	rst.lil $18
040EBE C9          0175*  	ret
040EBF             0176*  @cmd: ds 8 ; eight bytes for eight bits
040EC7             0177*  @end:
040EC7             0178*  
040EC7             0179*  ; print registers to screen in hexidecimal format
040EC7             0180*  ; inputs: none
040EC7             0181*  ; outputs: values of every register printed to screen
040EC7             0182*  ;    values of each register in global scratch memory
040EC7             0183*  ; destroys: nothing
040EC7             0184*  stepRegistersHex:
040EC7             0185*  ; store everything in scratch
040EC7 22 CA 10 04 0186*      ld (uhl),hl
040ECB ED 43 CD 10 0187*      ld (ubc),bc
       04          
040ED0 ED 53 D0 10 0188*      ld (ude),de
       04          
040ED5 DD 22 D3 10 0189*      ld (uix),ix
       04          
040EDA FD 22 D6 10 0190*      ld (uiy),iy
       04          
040EDF F5          0191*      push af ; fml
040EE0 E1          0192*      pop hl  ; thanks, zilog
040EE1 22 C7 10 04 0193*      ld (uaf),hl
040EE5 F5          0194*      push af ; dammit
040EE6             0195*  
040EE6             0196*  ; home the cursor
040EE6 CD B4 04 04 0197*      call vdu_home_cursor
040EEA             0198*  
040EEA             0199*  ; print each register
040EEA 21 53 10 04 0200*      ld hl,str_afu
040EEE CD C0 0D 04 0201*      call printString
040EF2 2A C7 10 04 0202*      ld hl,(uaf)
040EF6 CD DE 0D 04 0203*      call printHex24
040EFA CD D5 0D 04 0204*      call printNewLine
040EFE             0205*  
040EFE 21 57 10 04 0206*      ld hl,str_hlu
040F02 CD C0 0D 04 0207*      call printString
040F06 2A CA 10 04 0208*      ld hl,(uhl)
040F0A CD DE 0D 04 0209*      call printHex24
040F0E CD D5 0D 04 0210*      call printNewLine
040F12             0211*  
040F12 21 5B 10 04 0212*      ld hl,str_bcu
040F16 CD C0 0D 04 0213*      call printString
040F1A 2A CD 10 04 0214*      ld hl,(ubc)
040F1E CD DE 0D 04 0215*      call printHex24
040F22 CD D5 0D 04 0216*      call printNewLine
040F26             0217*  
040F26 21 5F 10 04 0218*      ld hl,str_deu
040F2A CD C0 0D 04 0219*      call printString
040F2E 2A D0 10 04 0220*      ld hl,(ude)
040F32 CD DE 0D 04 0221*      call printHex24
040F36 CD D5 0D 04 0222*      call printNewLine
040F3A             0223*  
040F3A 21 63 10 04 0224*      ld hl,str_ixu
040F3E CD C0 0D 04 0225*      call printString
040F42 2A D3 10 04 0226*      ld hl,(uix)
040F46 CD DE 0D 04 0227*      call printHex24
040F4A CD D5 0D 04 0228*      call printNewLine
040F4E             0229*  
040F4E 21 67 10 04 0230*      ld hl,str_iyu
040F52 CD C0 0D 04 0231*      call printString
040F56 2A D6 10 04 0232*      ld hl,(uiy)
040F5A CD DE 0D 04 0233*      call printHex24
040F5E CD D5 0D 04 0234*      call printNewLine
040F62             0235*  
040F62             0236*      ; call vsync
040F62             0237*  
040F62 CD D5 0D 04 0238*      call printNewLine
040F66             0239*  
040F66             0240*  ; check for right shift key and quit if pressed
040F66             0241*  	MOSCALL mos_getkbmap
040F66 3E 1E       0001*M 			LD	A, function
040F68 5B CF       0002*M 			RST.LIL	08h
040F6A             0242*  @stayhere:
040F6A             0243*  ; 7 RightShift
040F6A DD CB 00 76 0244*      bit 6,(ix+0)
040F6E 20 02       0245*      jr nz,@RightShift
040F70 18 F8       0246*      jr @stayhere
040F72             0247*  @RightShift:
040F72 DD CB 0E 86 0248*      res 0,(ix+14) ; debounce the key (hopefully)
040F76 3E 80       0249*      ld a,%10000000
040F78 CD 25 13 04 0250*      call multiPurposeDelay
040F7C             0251*  
040F7C             0252*  ; restore everything
040F7C 2A CA 10 04 0253*      ld hl, (uhl)
040F80 ED 4B CD 10 0254*      ld bc, (ubc)
       04          
040F85 ED 5B D0 10 0255*      ld de, (ude)
       04          
040F8A DD 2A D3 10 0256*      ld ix, (uix)
       04          
040F8F FD 2A D6 10 0257*      ld iy, (uiy)
       04          
040F94 F1          0258*      pop af
040F95             0259*  ; all done
040F95 C9          0260*      ret
040F96             0261*  
040F96             0262*  ; print registers to screen in hexidecimal format
040F96             0263*  ; inputs: none
040F96             0264*  ; outputs: values of every register printed to screen
040F96             0265*  ;    values of each register in global scratch memory
040F96             0266*  ; destroys: nothing
040F96             0267*  dumpRegistersHex:
040F96             0268*  ; store everything in scratch
040F96 22 CA 10 04 0269*      ld (uhl),hl
040F9A ED 43 CD 10 0270*      ld (ubc),bc
       04          
040F9F ED 53 D0 10 0271*      ld (ude),de
       04          
040FA4 DD 22 D3 10 0272*      ld (uix),ix
       04          
040FA9 FD 22 D6 10 0273*      ld (uiy),iy
       04          
040FAE F5          0274*      push af ; fml
040FAF E1          0275*      pop hl  ; thanks, zilog
040FB0 22 C7 10 04 0276*      ld (uaf),hl
040FB4 F5          0277*      push af ; dammit
040FB5             0278*  
040FB5             0279*  ; home the cursor
040FB5 CD B4 04 04 0280*      call vdu_home_cursor
040FB9             0281*  
040FB9             0282*  ; print each register
040FB9 21 53 10 04 0283*      ld hl,str_afu
040FBD CD C0 0D 04 0284*      call printString
040FC1 2A C7 10 04 0285*      ld hl,(uaf)
040FC5 CD DE 0D 04 0286*      call printHex24
040FC9 CD D5 0D 04 0287*      call printNewLine
040FCD             0288*  
040FCD 21 57 10 04 0289*      ld hl,str_hlu
040FD1 CD C0 0D 04 0290*      call printString
040FD5 2A CA 10 04 0291*      ld hl,(uhl)
040FD9 CD DE 0D 04 0292*      call printHex24
040FDD CD D5 0D 04 0293*      call printNewLine
040FE1             0294*  
040FE1 21 5B 10 04 0295*      ld hl,str_bcu
040FE5 CD C0 0D 04 0296*      call printString
040FE9 2A CD 10 04 0297*      ld hl,(ubc)
040FED CD DE 0D 04 0298*      call printHex24
040FF1 CD D5 0D 04 0299*      call printNewLine
040FF5             0300*  
040FF5 21 5F 10 04 0301*      ld hl,str_deu
040FF9 CD C0 0D 04 0302*      call printString
040FFD 2A D0 10 04 0303*      ld hl,(ude)
041001 CD DE 0D 04 0304*      call printHex24
041005 CD D5 0D 04 0305*      call printNewLine
041009             0306*  
041009 21 63 10 04 0307*      ld hl,str_ixu
04100D CD C0 0D 04 0308*      call printString
041011 2A D3 10 04 0309*      ld hl,(uix)
041015 CD DE 0D 04 0310*      call printHex24
041019 CD D5 0D 04 0311*      call printNewLine
04101D             0312*  
04101D 21 67 10 04 0313*      ld hl,str_iyu
041021 CD C0 0D 04 0314*      call printString
041025 2A D6 10 04 0315*      ld hl,(uiy)
041029 CD DE 0D 04 0316*      call printHex24
04102D CD D5 0D 04 0317*      call printNewLine
041031             0318*  
041031 CD D6 05 04 0319*      call vdu_vblank
041035             0320*  
041035 CD D5 0D 04 0321*      call printNewLine
041039             0322*  ; restore everything
041039 2A CA 10 04 0323*      ld hl, (uhl)
04103D ED 4B CD 10 0324*      ld bc, (ubc)
       04          
041042 ED 5B D0 10 0325*      ld de, (ude)
       04          
041047 DD 2A D3 10 0326*      ld ix, (uix)
       04          
04104C FD 2A D6 10 0327*      ld iy, (uiy)
       04          
041051 F1          0328*      pop af
041052             0329*  ; all done
041052 C9          0330*      ret
041053             0331*  
041053 61 66 3D 00 0332*  str_afu: db "af=",0
041057 68 6C 3D 00 0333*  str_hlu: db "hl=",0
04105B 62 63 3D 00 0334*  str_bcu: db "bc=",0
04105F 64 65 3D 00 0335*  str_deu: db "de=",0
041063 69 78 3D 00 0336*  str_ixu: db "ix=",0
041067 69 79 3D 00 0337*  str_iyu: db "iy=",0
04106B             0338*  
04106B             0339*  ; print udeuhl to screen in hexidecimal format
04106B             0340*  ; inputs: none
04106B             0341*  ; outputs: concatenated hexidecimal udeuhl
04106B             0342*  ; destroys: nothing
04106B             0343*  dumpUDEUHLHex:
04106B             0344*  ; store everything in scratch
04106B 22 CA 10 04 0345*      ld (uhl),hl
04106F ED 43 CD 10 0346*      ld (ubc),bc
       04          
041074 ED 53 D0 10 0347*      ld (ude),de
       04          
041079 DD 22 D3 10 0348*      ld (uix),ix
       04          
04107E FD 22 D6 10 0349*      ld (uiy),iy
       04          
041083 F5          0350*      push af
041084             0351*  
041084             0352*  ; print each register
041084             0353*  
041084 21 BE 10 04 0354*      ld hl,str_udeuhl
041088 CD C0 0D 04 0355*      call printString
04108C 2A D0 10 04 0356*      ld hl,(ude)
041090 CD DE 0D 04 0357*      call printHex24
041094 3E 2E       0358*  	ld a,'.'	; print a dot to separate the values
041096 5B D7       0359*  	rst.lil 10h
041098 2A CA 10 04 0360*      ld hl,(uhl)
04109C CD DE 0D 04 0361*      call printHex24
0410A0 CD D5 0D 04 0362*      call printNewLine
0410A4             0363*  
0410A4             0364*  ; restore everything
0410A4 2A CA 10 04 0365*      ld hl, (uhl)
0410A8 ED 4B CD 10 0366*      ld bc, (ubc)
       04          
0410AD ED 5B D0 10 0367*      ld de, (ude)
       04          
0410B2 DD 2A D3 10 0368*      ld ix, (uix)
       04          
0410B7 FD 2A D6 10 0369*      ld iy, (uiy)
       04          
0410BC F1          0370*      pop af
0410BD             0371*  ; all done
0410BD C9          0372*      ret
0410BE             0373*  
0410BE 75 64 65 2E 0374*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0410C7             0375*  
0410C7             0376*  ; global scratch memory for registers
0410C7 00 00 00    0377*  uaf: dl 0
0410CA 00 00 00    0378*  uhl: dl 0
0410CD 00 00 00    0379*  ubc: dl 0
0410D0 00 00 00    0380*  ude: dl 0
0410D3 00 00 00    0381*  uix: dl 0
0410D6 00 00 00    0382*  uiy: dl 0
0410D9 00 00 00    0383*  usp: dl 0
0410DC 00 00 00    0384*  upc: dl 0
0410DF             0385*  
0410DF             0386*  ; inputs: whatever is in the flags register
0410DF             0387*  ; outputs: binary representation of flags
0410DF             0388*  ;          with a header so we know which is what
0410DF             0389*  ; destroys: nothing
0410DF             0390*  ; preserves: everything
0410DF             0391*  dumpFlags:
0410DF             0392*  ; first we curse zilog for not giving direct access to flags
0410DF F5          0393*      push af ; this is so we can send it back unharmed
0410E0 F5          0394*      push af ; this is so we can pop it to hl
0410E1             0395*  ; store everything in scratch
0410E1 22 CA 10 04 0396*      ld (uhl),hl
0410E5 ED 43 CD 10 0397*      ld (ubc),bc
       04          
0410EA ED 53 D0 10 0398*      ld (ude),de
       04          
0410EF DD 22 D3 10 0399*      ld (uix),ix
       04          
0410F4 FD 22 D6 10 0400*      ld (uiy),iy
       04          
0410F9             0401*  ; next we print the header
0410F9 21 25 11 04 0402*      ld hl,@header
0410FD CD C0 0D 04 0403*      call printString
041101 E1          0404*      pop hl ; flags are now in l
041102 7D          0405*      ld a,l ; flags are now in a
041103 CD 7D 0E 04 0406*      call printBin8
041107 CD D5 0D 04 0407*  	call printNewLine
04110B             0408*  ; restore everything
04110B 2A CA 10 04 0409*      ld hl, (uhl)
04110F ED 4B CD 10 0410*      ld bc, (ubc)
       04          
041114 ED 5B D0 10 0411*      ld de, (ude)
       04          
041119 DD 2A D3 10 0412*      ld ix, (uix)
       04          
04111E FD 2A D6 10 0413*      ld iy, (uiy)
       04          
041123 F1          0414*      pop af ; send her home the way she came
041124 C9          0415*      ret
041125             0416*  ; Bit 7 (S): Sign flag
041125             0417*  ; Bit 6 (Z): Zero flag
041125             0418*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
041125             0419*  ; Bit 4 (H): Half Carry flag
041125             0420*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
041125             0421*  ; Bit 2 (PV): Parity/Overflow flag
041125             0422*  ; Bit 1 (N): Subtract flag
041125             0423*  ; Bit 0 (C): Carry flag
041125 53 5A 78 48 0424*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
041130             0425*  
041130             0426*  ; set all the bits in the flag register
041130             0427*  ; more of an academic exercise than anything useful
041130             0428*  ; inputs; none
041130             0429*  ; outputs; a=0,f=255
041130             0430*  ; destroys: flags, hl
041130             0431*  ; preserves: a, because why not
041130             0432*  setAllFlags:
041130 21 FF 00 00 0433*      ld hl,255
041134 67          0434*      ld h,a ; four cycles to preserve a is cheap
041135 E5          0435*      push hl
041136 F1          0436*      pop af
041137 C9          0437*      ret
041138             0438*  
041138             0439*  ; reset all the bits in the flag register
041138             0440*  ; unlike its inverse counterpart, this may actually be useful
041138             0441*  ; inputs; none
041138             0442*  ; outputs; a=0,f=0
041138             0443*  ; destroys: flags, hl
041138             0444*  ; preserves: a, because why not
041138             0445*  resetAllFlags:
041138 21 00 00 00 0446*      ld hl,0
04113C 67          0447*      ld h,a ; four cycles to preserve a is cheap
04113D E5          0448*      push hl
04113E F1          0449*      pop af
04113F C9          0450*      ret
041140             0451*  
041140             0452*  ; wait until user presses a key
041140             0453*  ; inputs: none
041140             0454*  ; outputs: none
041140             0455*  ; destroys: af,hl,ix
041140             0456*  waitKeypress:
041140             0457*      ; ld hl,str_press_shift
041140             0458*      ; call printString
041140             0459*      MOSCALL mos_sysvars
041140 3E 08       0001*M 			LD	A, function
041142 5B CF       0002*M 			RST.LIL	08h
041144 AF          0460*      xor a ; zero out any prior keypresses
041145 DD 77 05    0461*      ld (ix+sysvar_keyascii),a
041148             0462*  @loop:
041148 DD 7E 05    0463*      ld a,(ix+sysvar_keyascii)
04114B A7          0464*      and a
04114C C0          0465*      ret nz
04114D 18 F9       0466*      jr @loop
04114F             0467*  
04114F             0468*  ; wait until user presses return key
04114F             0469*  ; inputs: none
04114F             0470*  ; outputs: none
04114F             0471*  ; destroys: af,ix
04114F             0472*  waitReturn:
04114F             0473*  ; check for return key and quit if pressed
04114F             0474*      MOSCALL mos_sysvars
04114F 3E 08       0001*M 			LD	A, function
041151 5B CF       0002*M 			RST.LIL	08h
041153 AF          0475*      xor a ; zero out any prior keypresses
041154 DD 77 05    0476*      ld (ix+sysvar_keyascii),a
041157             0477*  @stayhere:
041157 DD 7E 05    0478*      ld a,(ix+sysvar_keyascii)
04115A FE 0D       0479*      cp 13
04115C 20 F9       0480*      jr nz,@stayhere
04115E 3E 80       0481*      ld a,%10000000
041160 CD 25 13 04 0482*      call multiPurposeDelay
041164 C9          0483*      ret
041165             0484*  
041165             0485*  ; print bytes from an address to the screen in hexidecimal format
041165             0486*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041165             0487*  ; outputs: values of each byte printed to screen separated by spaces
041165             0488*  ; destroys: nothing
041165             0489*  dumpMemoryHex:
041165             0490*  ; save all registers to the stack
041165 F5          0491*      push af
041166 C5          0492*      push bc
041167 D5          0493*      push de
041168 E5          0494*      push hl
041169 DD E5       0495*      push ix
04116B FD E5       0496*      push iy
04116D             0497*  
04116D             0498*  ; set b to be our loop counter
04116D 47          0499*      ld b,a
04116E             0500*  @loop:
04116E             0501*  ; print the byte
04116E 7E          0502*      ld a,(hl)
04116F CD F0 0D 04 0503*      call printHex8
041173             0504*  ; print a space
041173 3E 20       0505*      ld a,' '
041175 5B D7       0506*      rst.lil 10h
041177 23          0507*      inc hl
041178 10 F4       0508*      djnz @loop
04117A CD D5 0D 04 0509*      call printNewLine
04117E             0510*  
04117E             0511*  ; restore everything
04117E FD E1       0512*      pop iy
041180 DD E1       0513*      pop ix
041182 E1          0514*      pop hl
041183 D1          0515*      pop de
041184 C1          0516*      pop bc
041185 F1          0517*      pop af
041186             0518*  ; all done
041186 C9          0519*      ret
041187             0520*  
041187             0521*  
041187             0522*  ; print bytes from an address to the screen in binary format
041187             0523*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041187             0524*  ; outputs: values of each byte printed to screen separated by spaces
041187             0525*  ; destroys: nothing
041187             0526*  dumpMemoryBin:
041187             0527*  ; save all registers to the stack
041187 F5          0528*      push af
041188 C5          0529*      push bc
041189 D5          0530*      push de
04118A E5          0531*      push hl
04118B DD E5       0532*      push ix
04118D FD E5       0533*      push iy
04118F             0534*  
04118F             0535*  ; set b to be our loop counter
04118F 47          0536*      ld b,a
041190             0537*  @loop:
041190             0538*  ; print the byte
041190 7E          0539*      ld a,(hl)
041191 E5          0540*      push hl
041192 C5          0541*      push bc
041193 CD 7D 0E 04 0542*      call printBin8
041197 C1          0543*      pop bc
041198             0544*  ; print a space
041198 3E 20       0545*      ld a,' '
04119A 5B D7       0546*      rst.lil 10h
04119C E1          0547*      pop hl
04119D 23          0548*      inc hl
04119E 10 F0       0549*      djnz @loop
0411A0 CD D5 0D 04 0550*      call printNewLine
0411A4             0551*  
0411A4             0552*  ; restore everything
0411A4 FD E1       0553*      pop iy
0411A6 DD E1       0554*      pop ix
0411A8 E1          0555*      pop hl
0411A9 D1          0556*      pop de
0411AA C1          0557*      pop bc
0411AB F1          0558*      pop af
0411AC             0559*  ; all done
0411AC C9          0560*      ret
0411AD             0561*  
0411AD             0562*  ; print bytes from an address to the screen in binary format
0411AD             0563*  ; with the bits of each byte in reverse order (lsb first)
0411AD             0564*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0411AD             0565*  ; outputs: values of each byte printed to screen separated by spaces
0411AD             0566*  ; destroys: nothing
0411AD             0567*  dumpMemoryBinRev:
0411AD             0568*  ; save all registers to the stack
0411AD F5          0569*      push af
0411AE C5          0570*      push bc
0411AF D5          0571*      push de
0411B0 E5          0572*      push hl
0411B1 DD E5       0573*      push ix
0411B3 FD E5       0574*      push iy
0411B5             0575*  
0411B5             0576*  ; set b to be our loop counter
0411B5 47          0577*      ld b,a
0411B6             0578*  @loop:
0411B6             0579*  ; print the byte
0411B6 7E          0580*      ld a,(hl)
0411B7 E5          0581*      push hl
0411B8 C5          0582*      push bc
0411B9 CD A2 0E 04 0583*      call printBin8Rev
0411BD C1          0584*      pop bc
0411BE             0585*  ; print a space
0411BE 3E 20       0586*      ld a,' '
0411C0 5B D7       0587*      rst.lil 10h
0411C2 E1          0588*      pop hl
0411C3 23          0589*      inc hl
0411C4 10 F0       0590*      djnz @loop
0411C6 CD D5 0D 04 0591*      call printNewLine
0411CA             0592*  
0411CA             0593*  ; restore everything
0411CA FD E1       0594*      pop iy
0411CC DD E1       0595*      pop ix
0411CE E1          0596*      pop hl
0411CF D1          0597*      pop de
0411D0 C1          0598*      pop bc
0411D1 F1          0599*      pop af
0411D2             0600*  ; all done
0411D2 C9          0601*      ret
0411D3             0344       include "pingo/src/asm/timer.asm"
0411D3             0001*  ; Table 32. Timer Control Registers
0411D3             0002*  ; this constant is the base address of the timer control registers
0411D3             0003*  ; each timer takes three bytes:
0411D3             0004*  ;   0: control register
0411D3             0005*  ;   1: low byte of timer reset value
0411D3             0006*  ;   2: high byte of timer reset value
0411D3             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0411D3             0008*  ; which correctly force the high and upper bytes of the address bus to zero
0411D3             0009*  TMR_CTL:     equ 80h
0411D3             0010*  
0411D3             0011*  ; Timer Control Register Bit Definitions
0411D3             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0411D3             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
0411D3             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0411D3             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
0411D3             0016*                              ; the TMRx_CTL register is read.
0411D3             0017*  
0411D3             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0411D3             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0411D3             0020*  
0411D3             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0411D3             0022*                              ;  0,and counting stops when the end-of-count value is reached.
0411D3             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0411D3             0024*                              ; written to the counter when the end-of-count value is reached.
0411D3             0025*  
0411D3             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0411D3             0027*  CLK_DIV_256:  equ %00001100 ;
0411D3             0028*  CLK_DIV_64:   equ %00001000 ;
0411D3             0029*  CLK_DIV_16:   equ %00000100 ;
0411D3             0030*  CLK_DIV_4:    equ %00000000 ;
0411D3             0031*  
0411D3             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0411D3             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0411D3             0034*                              ; When a 1 is written to this bit,the values in the reload registers
0411D3             0035*                              ;  are loaded into the downcounter when the timer restarts. The
0411D3             0036*                              ; programmer must ensure that this bit is set to 1 each time
0411D3             0037*                              ; SINGLE-PASS mode is used.
0411D3             0038*  
0411D3             0039*  ; disable/enable the programmable reload timer
0411D3             0040*  PRT_EN_0:     equ %00000000 ;
0411D3             0041*  PRT_EN_1:     equ %00000001 ;
0411D3             0042*  
0411D3             0043*  ; Table 37. Timer Input Source Select Register
0411D3             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
0411D3             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0411D3             0046*  ;   00: System clock / CLK_DIV
0411D3             0047*  ;   01: RTC / CLK_DIV
0411D3             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
0411D3             0049*  ;   10: GPIO port B pin 1.
0411D3             0050*  ;   11: GPIO port B pin 1.
0411D3             0051*  TMR_ISS:   equ 92h ; register address
0411D3             0052*  
0411D3             0053*  ; Table 51. Real-Time Clock Control Register
0411D3             0054*  RTC_CTRL: equ EDh ; register address
0411D3             0055*  
0411D3             0056*  ; alarm interrupt disable/enable
0411D3             0057*  RTC_ALARM_0:    equ %00000000
0411D3             0058*  RTC_ALARM_1:    equ %10000000
0411D3             0059*  
0411D3             0060*  ; interrupt on alarm disable/enable
0411D3             0061*  RTC_INT_ENT_0:  equ %00000000
0411D3             0062*  RTC_INT_ENT_1:  equ %01000000
0411D3             0063*  
0411D3             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0411D3             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0411D3             0066*  
0411D3             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0411D3             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
0411D3             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0411D3             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
0411D3             0071*  
0411D3             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0411D3             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0411D3             0074*  
0411D3             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0411D3             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0411D3             0077*  
0411D3             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0411D3             0079*                                  ; RTC counter is enabled.
0411D3             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0411D3             0081*                                  ; RTC counter is disabled.
0411D3             0082*  
0411D3             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0411D3             0084*  
0411D3             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0411D3             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0411D3 00 00 00    0087*  prt_reload: dl 0x000000
0411D6             0088*  
0411D6             0089*  ; set PRT timer
0411D6             0090*  prt_set:
0411D6 21 00 00 00 0091*      ld hl,0
0411DA 22 24 12 04 0092*      ld (prt_irq_counter),hl
0411DE 2A D3 11 04 0093*      ld hl,(prt_reload)
0411E2 ED 29 84    0094*      out0 ($84),l
0411E5 ED 21 85    0095*  	out0 ($85),h
0411E8             0096*  ; disable timer
0411E8 3E 06       0097*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0411EA ED 39 83    0098*  	out0 ($83),a
0411ED             0099*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0411ED 3E 57       0100*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0411EF ED 39 83    0101*  	out0 ($83),a
0411F2 C9          0102*      ret
0411F3             0103*  
0411F3             0104*  ; ===============================================
0411F3             0105*  ; PRT Timer Interrupt Handling
0411F3             0106*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
0411F3             0107*  ; -----------------------------------------------
0411F3             0108*  prt_irq_init:
0411F3             0109*      ; set up interrupt vector table 2
0411F3 21 00 00 00 0110*  	ld hl,0
0411F7 3A 0C 01 00 0111*  	ld a,($10c)
0411FB 6F          0112*  	ld l,a
0411FC 3A 0D 01 00 0113*  	ld a,($10d)
041200 67          0114*  	ld h,a
041201             0115*  
041201             0116*  	; skip over CALL ($c3)
041201 23          0117*  	inc hl
041202             0118*  	; load address of jump into vector table 2 (in ram)
041202 ED 27       0119*  	ld hl,(hl)
041204             0120*  
041204             0121*  	; write CALL prt_irq_handler to vector table 2
041204 3E C3       0122*  	ld a,$c3
041206 77          0123*  	ld (hl),a
041207 23          0124*  	inc hl
041208 11 0F 12 04 0125*  	ld de,prt_irq_handler
04120C ED 1F       0126*  	ld (hl),de
04120E             0127*  
04120E C9          0128*      ret
04120F             0129*  
04120F             0130*  prt_irq_handler:
04120F F3          0131*  	di
041210 F5          0132*  	push af
041211 E5          0133*      push hl
041212 ED 38 83    0134*  	in0 a,($83)
041215 2A 24 12 04 0135*  	ld hl,(prt_irq_counter)
041219 23          0136*  	inc hl
04121A 22 24 12 04 0137*  	ld (prt_irq_counter),hl
04121E E1          0138*      pop hl
04121F F1          0139*  	pop af
041220 FB          0140*  	ei
041221 5B ED 4D    0141*  	reti.l
041224             0142*  
041224             0143*  prt_irq_counter:
041224 00 00 00    0144*  	.dl 0
041227             0145*  prt_irq_counter_saved:
041227 00 00 00    0146*      .dl 0
04122A             0147*  
04122A             0148*  prt_loop_reset:
04122A E5          0149*      push hl
04122B 21 00 00 00 0150*  	ld hl,0
04122F 22 24 12 04 0151*  	ld (prt_irq_counter),hl
041233 22 95 12 04 0152*      ld (prt_loop_counter),hl
041237 22 98 12 04 0153*      ld (prt_loops),hl
04123B CD D6 11 04 0154*      call prt_set
04123F E1          0155*      pop hl
041240 C9          0156*      ret
041241             0157*  
041241             0158*  prt_loop_start:
041241 E5          0159*      push hl
041242 21 00 00 00 0160*  	ld hl,0
041246 22 24 12 04 0161*  	ld (prt_irq_counter),hl
04124A E1          0162*      pop hl
04124B C9          0163*      ret
04124C             0164*  
04124C             0165*  prt_loop_stop:
04124C E5          0166*      push hl
04124D D5          0167*      push de
04124E 2A 24 12 04 0168*      ld hl,(prt_irq_counter)
041252 ED 5B 95 12 0169*      ld de,(prt_loop_counter)
       04          
041257 19          0170*      add hl,de
041258 22 95 12 04 0171*      ld (prt_loop_counter),hl
04125C 21 00 00 00 0172*      ld hl,0
041260 22 24 12 04 0173*      ld (prt_irq_counter),hl
041264 2A 98 12 04 0174*      ld hl,(prt_loops)
041268 23          0175*      inc hl
041269 22 98 12 04 0176*      ld (prt_loops),hl
04126D D1          0177*      pop de
04126E E1          0178*      pop hl
04126F C9          0179*      ret
041270             0180*  
041270             0181*  ; inputs: bc = y,x text coordinates to print
041270             0182*  prt_loop_print:
041270 F5          0183*      push af
041271 E5          0184*      push hl
041272 C5          0185*      push bc
041273 D5          0186*      push de
041274 DD E5       0187*      push ix
041276 FD E5       0188*      push iy
041278 CD B9 04 04 0189*      call vdu_move_cursor
04127C             0190*  
04127C 2A 95 12 04 0191*      ld hl,(prt_loop_counter)
041280 CD 0E 0E 04 0192*      call printDec
041284             0193*  
041284 2A 98 12 04 0194*      ld hl,(prt_loops)
041288 CD 0E 0E 04 0195*      call printDec
04128C             0196*  
04128C FD E1       0197*      pop iy
04128E DD E1       0198*      pop ix
041290 D1          0199*      pop de
041291 C1          0200*      pop bc
041292 E1          0201*      pop hl
041293 F1          0202*      pop af
041294 C9          0203*      ret
041295             0204*  
041295             0205*  prt_loop_counter:
041295 00 00 00    0206*      .dl 0
041298             0207*  prt_loops:
041298 00 00 00    0208*      .dl 0
04129B             0209*  
04129B             0210*  ; ===============================================
04129B             0211*  ; Timer functions
04129B             0212*  ; -----------------------------------------------
04129B             0213*  ; set a countdown timer
04129B             0214*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04129B             0215*  ; returns: hl = current time
04129B             0216*  tmr_set:
04129B FD 2F 03    0217*      ld (iy+3),hl            ; set time remaining
04129E             0218*      MOSCALL mos_sysvars     ; ix points to syvars table
04129E 3E 08       0001*M 			LD	A, function
0412A0 5B CF       0002*M 			RST.LIL	08h
0412A2 DD 27 00    0219*      ld hl,(ix+sysvar_time)  ; get current time
0412A5 FD 2F 00    0220*      ld (iy+0),hl            ; set start time
0412A8 C9          0221*      ret
0412A9             0222*  
0412A9             0223*  ; gets time remaining on a countdown timer
0412A9             0224*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0412A9             0225*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0412A9             0226*  ;          sign flags: pos = time not expired,zero or neg = time expired
0412A9             0227*  tmr_get:
0412A9             0228*      MOSCALL mos_sysvars     ; ix points to syvars table
0412A9 3E 08       0001*M 			LD	A, function
0412AB 5B CF       0002*M 			RST.LIL	08h
0412AD DD 17 00    0229*      ld de,(ix+sysvar_time)  ; get current time
0412B0 FD 27 00    0230*      ld hl,(iy+0)            ; get start time
0412B3 AF          0231*      xor a                   ; clear carry
0412B4 ED 52       0232*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0412B6 FD 17 03    0233*      ld de,(iy+3)            ; get timer set value
0412B9 AF          0234*      xor a                   ; clear carry
0412BA ED 5A       0235*      adc hl,de               ; hl = time remaining
0412BC             0236*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0412BC C9          0237*      ret
0412BD             0238*  
0412BD             0239*  tmr_test: ds 6 ; example of a buffer to hold timer data
0412C3             0240*  
0412C3 00 00 00    0241*  timestamp_now: dl 0
0412C6 00 00 00    0242*  timestamp_old: dl 0
0412C9 00 00 00    0243*  timestamp_chg: dl 0
0412CC             0244*  
0412CC             0245*  ; update the global timestamp from the system clock
0412CC             0246*  ; inputs: none
0412CC             0247*  ; returns: hl = time elapsed in 1/120ths of a second
0412CC             0248*  ;          de = current time
0412CC             0249*  ;          ix = pointer to syvars table
0412CC             0250*  ; destroys: af,hl,de,ix
0412CC             0251*  timestamp_tick:
0412CC ED 5B C3 12 0252*      ld de,(timestamp_now)   ; get previous time
       04          
0412D1 ED 53 C6 12 0253*      ld (timestamp_old),de   ; save previous time
       04          
0412D6             0254*      MOSCALL mos_sysvars     ; ix points to syvars table
0412D6 3E 08       0001*M 			LD	A, function
0412D8 5B CF       0002*M 			RST.LIL	08h
0412DA DD 27 00    0255*      ld hl,(ix+sysvar_time)  ; get current time
0412DD 22 C3 12 04 0256*      ld (timestamp_now),hl   ; save current time
0412E1 AF          0257*      xor a                   ; clear carry
0412E2 ED 52       0258*      sbc hl,de               ; hl = time elapsed
0412E4 22 C9 12 04 0259*      ld (timestamp_chg),hl   ; save elapsed time
0412E8 C9          0260*      ret
0412E9             0261*  
0412E9             0262*  ; set a countdown timer
0412E9             0263*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0412E9             0264*  ; requires: timestamp_tick to be called at least once before this function
0412E9             0265*  ; returns: hl = current time
0412E9             0266*  ; destroys: hl
0412E9             0267*  timestamp_tmr_set:
0412E9 FD 2F 03    0268*      ld (iy+3),hl            ; set time remaining
0412EC 2A C3 12 04 0269*      ld hl,(timestamp_now)   ; get current timestamp
0412F0 FD 2F 00    0270*      ld (iy+0),hl            ; set start time
0412F3 C9          0271*      ret
0412F4             0272*  
0412F4             0273*  ; gets time remaining on a countdown timer following the global timestamp
0412F4             0274*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0412F4             0275*  ; requires: timestamp_tick to be called at least once before this function
0412F4             0276*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0412F4             0277*  ;          sign flags: pos = time not expired,zero or neg = time expired
0412F4             0278*  ; destroys: af,hl,de
0412F4             0279*  timestamp_tmr_get:
0412F4 ED 5B C3 12 0280*      ld de,(timestamp_now)   ; get current timestamp
       04          
0412F9 FD 27 00    0281*      ld hl,(iy+0)            ; get start time
0412FC AF          0282*      xor a                   ; clear carry
0412FD ED 52       0283*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0412FF FD 17 03    0284*      ld de,(iy+3)            ; get timer set value
041302 AF          0285*      xor a                   ; clear carry
041303 ED 5A       0286*      adc hl,de               ; hl = time remaining
041305             0287*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
041305 C9          0288*      ret
041306             0289*  
041306             0290*  ; set a stopwatch
041306             0291*  ; returns: hl = start time
041306             0292*  ; destroys: hl,ix
041306             0293*  stopwatch_set:
041306             0294*      MOSCALL mos_sysvars     ; ix points to syvars table
041306 3E 08       0001*M 			LD	A, function
041308 5B CF       0002*M 			RST.LIL	08h
04130A DD 27 00    0295*      ld hl,(ix+sysvar_time)  ; get current time
04130D 22 22 13 04 0296*      ld (stopwatch_started),hl            ; set start time
041311 C9          0297*      ret
041312             0298*  
041312             0299*  ; gets time elapsed on a stopwatch
041312             0300*  ; returns: hl = time elapsed in 1/120ths of a second
041312             0301*  ; destroys: af,hl,de,ix
041312             0302*  stopwatch_get:
041312             0303*      MOSCALL mos_sysvars     ; ix points to syvars table
041312 3E 08       0001*M 			LD	A, function
041314 5B CF       0002*M 			RST.LIL	08h
041316 DD 27 00    0304*      ld hl,(ix+sysvar_time)  ; get current time
041319 ED 5B 22 13 0305*      ld de,(stopwatch_started)            ; get start time
       04          
04131E AF          0306*      xor a                   ; clear carry
04131F ED 52       0307*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
041321 C9          0308*      ret
041322             0309*  
041322             0310*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
041325             0311*  
041325             0312*  ; ------------------
041325             0313*  ; delay routine
041325             0314*  ; Author: Richard Turrnidge
041325             0315*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.asm
041325             0316*  ; routine waits a fixed time,then returns
041325             0317*  ; arrive with A =  the delay byte. One bit to be set only.
041325             0318*  ; eg. ld A,00000100b
041325             0319*  
041325             0320*  multiPurposeDelay:
041325 F5          0321*      push af
041326 C5          0322*      push bc
041327 DD E5       0323*      push ix
041329 47          0324*      ld b,a
04132A 3E 08       0325*      ld a,$08
04132C 5B CF       0326*      RST.LIL	08h                 ; get IX pointer to sysvars
04132E             0327*  
04132E             0328*  waitLoop:
04132E             0329*  
04132E DD 7E 00    0330*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
041331             0331*  
041331             0332*                                  ;   we check if bit set is same as last time we checked.
041331             0333*                                  ;   bit 0 - don't use
041331             0334*                                  ;   bit 1 - changes 64 times per second
041331             0335*                                  ;   bit 2 - changes 32 times per second
041331             0336*                                  ;   bit 3 - changes 16 times per second
041331             0337*  
041331             0338*                                  ;   bit 4 - changes 8 times per second
041331             0339*                                  ;   bit 5 - changes 4 times per second
041331             0340*                                  ;   bit 6 - changes 2 times per second
041331             0341*                                  ;   bit 7 - changes 1 times per second
041331 A0          0342*      and b
041332 4F          0343*      ld c,a
041333 3A 44 13 04 0344*      ld a,(oldTimeStamp)
041337 B9          0345*      cp c                        ; is A same as last value?
041338 28 F4       0346*      jr z,waitLoop              ; loop here if it is
04133A 79          0347*      ld a,c
04133B 32 44 13 04 0348*      ld (oldTimeStamp),a        ; set new value
04133F             0349*  
04133F DD E1       0350*      pop ix
041341 C1          0351*      pop bc
041342 F1          0352*      pop af
041343 C9          0353*      ret
041344             0354*  
041344 00          0355*  oldTimeStamp:   .db 00h
041345             0345   
041345 57 65 6C 63 0346   str_hello_world: db "Welcome to the Pingo 3D Demo!\r\n",0
       6F 6D 65 20 
       74 6F 20 74 
       68 65 20 50 
       69 6E 67 6F 
       20 33 44 20 
       44 65 6D 6F 
       21 0D 0A 00 
041365 43 72 65 61 0347   str_create_object: db "Creating 3D object.\r\n",0
       74 69 6E 67 
       20 33 44 20 
       6F 62 6A 65 
       63 74 2E 0D 
       0A 00       
04137B 53 63 61 6C 0348   str_scale_object: db "Scaling object.\r\n",0
       69 6E 67 20 
       6F 62 6A 65 
       63 74 2E 0D 
       0A 00       
04138D 43 72 65 61 0349   str_create_target_bitmap: db "Creating target bitmap.\r\n",0
       74 69 6E 67 
       20 74 61 72 
       67 65 74 20 
       62 69 74 6D 
       61 70 2E 0D 
       0A 00       
0413A7 53 65 74 74 0350   str_set_texture_pixel: db "Setting texture pixel.\r\n",0
       69 6E 67 20 
       74 65 78 74 
       75 72 65 20 
       70 69 78 65 
       6C 2E 0D 0A 
       00          
0413C0 43 72 65 61 0351   str_create_texture_bitmap: db "Creating texture bitmap.\r\n",0
       74 69 6E 67 
       20 74 65 78 
       74 75 72 65 
       20 62 69 74 
       6D 61 70 2E 
       0D 0A 00    
0413DB 53 65 6E 64 0352   str_zeroes: db "Sending some magic zeroes.\r\n",0
       69 6E 67 20 
       73 6F 6D 65 
       20 6D 61 67 
       69 63 20 7A 
       65 72 6F 65 
       73 2E 0D 0A 
       00          
0413F8 53 65 74 74 0353   str_set_tex_coord_idxs: db "Setting texture coordinate indices.\r\n",0
       69 6E 67 20 
       74 65 78 74 
       75 72 65 20 
       63 6F 6F 72 
       64 69 6E 61 
       74 65 20 69 
       6E 64 69 63 
       65 73 2E 0D 
       0A 00       
04141E 53 65 6E 64 0354   str_set_texture_coordinates: db "Sending texture coordinates.\r\n",0
       69 6E 67 20 
       74 65 78 74 
       75 72 65 20 
       63 6F 6F 72 
       64 69 6E 61 
       74 65 73 2E 
       0D 0A 00    
04143D 53 65 6E 64 0355   str_set_mesh_vertex_indexes: db "Sending vertex indexes.\r\n",0
       69 6E 67 20 
       76 65 72 74 
       65 78 20 69 
       6E 64 65 78 
       65 73 2E 0D 
       0A 00       
041457 53 65 6E 64 0356   str_send_vertices: db "Sending vertices.\r\n",0
       69 6E 67 20 
       76 65 72 74 
       69 63 65 73 
       2E 0D 0A 00 
04146B 53 65 74 74 0357   str_set_camera_x_rotation: db "Setting camera X rotation.\r\n",0
       69 6E 67 20 
       63 61 6D 65 
       72 61 20 58 
       20 72 6F 74 
       61 74 69 6F 
       6E 2E 0D 0A 
       00          
041488 53 65 74 74 0358   str_set_camera_distance: db "Setting camera distance.\r\n",0
       69 6E 67 20 
       63 61 6D 65 
       72 61 20 64 
       69 73 74 61 
       6E 63 65 2E 
       0D 0A 00    
0414A3 43 72 65 61 0359   str_create_control: db "Creating control structure.\r\n",0
       74 69 6E 67 
       20 63 6F 6E 
       74 72 6F 6C 
       20 73 74 72 
       75 63 74 75 
       72 65 2E 0D 
       0A 00       
0414C1 49 6E 69 74 0360   str_init_cmplt: db "Initialization complete.\r\n",0
       69 61 6C 69 
       7A 61 74 69 
       6F 6E 20 63 
       6F 6D 70 6C 
       65 74 65 2E 
       0D 0A 00    
0414DC 52 65 6E 64 0361   str_render_to_bitmap: db "Rendering to bitmap.\r\n",0
       65 72 69 6E 
       67 20 74 6F 
       20 62 69 74 
       6D 61 70 2E 
       0D 0A 00    
0414F3 44 69 73 70 0362   str_display_output_bitmap: db "Displaying output bitmap.\r\n",0
       6C 61 79 69 
       6E 67 20 6F 
       75 74 70 75 
       74 20 62 69 
       74 6D 61 70 
       2E 0D 0A 00 
