PC     Output      Line
040000             0001   	include "pingo/src/asm/mos_api.asm"
040000             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.asm
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
040000             0005*  ;			Added MOS error codes for return in HL
040000             0006*  ; Created:	03/08/2022
040000             0007*  ; Last Updated:	10/08/2023
040000             0008*  ;
040000             0009*  ; Modinfo:
040000             0010*  ; 05/08/2022:	Added mos_feof
040000             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0015*  ; 13/10/2022:	Added mos_oscli
040000             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0025*  ; 19/05/2023:	Added sysvar_scrMode
040000             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0027*  ; 03/08/2023:	Added mos_setkbvector
040000             0028*  ; 10/08/2023:	Added mos_getkbmap
040000             0029*  
040000             0030*  ; VDP control (VDU 23, 0, n)
040000             0031*  ;
040000             0032*  vdp_gp:				EQU 80h
040000             0033*  vdp_keycode:		EQU 81h
040000             0034*  vdp_cursor:			EQU	82h
040000             0035*  vdp_scrchar:		EQU	83h
040000             0036*  vdp_scrpixel:		EQU	84h
040000             0037*  vdp_audio:			EQU	85h
040000             0038*  vdp_mode:			EQU	86h
040000             0039*  vdp_rtc:			EQU	87h
040000             0040*  vdp_keystate:		EQU	88h
040000             0041*  vdp_logicalcoords:	EQU	C0h
040000             0042*  vdp_terminalmode:	EQU	FFh
040000             0043*  
040000             0044*  ; MOS high level functions
040000             0045*  ;
040000             0046*  mos_getkey:			EQU	00h
040000             0047*  mos_load:			EQU	01h
040000             0048*  mos_save:			EQU	02h
040000             0049*  mos_cd:				EQU	03h
040000             0050*  mos_dir:			EQU	04h
040000             0051*  mos_del:			EQU	05h
040000             0052*  mos_ren:			EQU	06h
040000             0053*  mos_mkdir:			EQU	07h
040000             0054*  mos_sysvars:		EQU	08h
040000             0055*  mos_editline:		EQU	09h
040000             0056*  mos_fopen:			EQU	0Ah
040000             0057*  mos_fclose:			EQU	0Bh
040000             0058*  mos_fgetc:			EQU	0Ch
040000             0059*  mos_fputc:			EQU	0Dh
040000             0060*  mos_feof:			EQU	0Eh
040000             0061*  mos_getError:		EQU	0Fh
040000             0062*  mos_oscli:			EQU	10h
040000             0063*  mos_copy:			EQU	11h
040000             0064*  mos_getrtc:			EQU	12h
040000             0065*  mos_setrtc:			EQU	13h
040000             0066*  mos_setintvector:	EQU	14h
040000             0067*  mos_uopen:			EQU	15h
040000             0068*  mos_uclose:			EQU	16h
040000             0069*  mos_ugetc:			EQU	17h
040000             0070*  mos_uputc:			EQU	18h
040000             0071*  mos_getfil:			EQU	19h
040000             0072*  mos_fread:			EQU	1Ah
040000             0073*  mos_fwrite:			EQU	1Bh
040000             0074*  mos_flseek:			EQU	1Ch
040000             0075*  mos_setkbvector:	EQU	1Dh
040000             0076*  mos_getkbmap:		EQU	1Eh
040000             0077*  
040000             0078*  ; MOS program exit codes
040000             0079*  ;
040000             0080*  EXIT_OK:				EQU  0;	"OK",
040000             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040000             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040000             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040000             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040000             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040000             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040000             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040000             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040000             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040000             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040000             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040000             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040000             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040000             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040000             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040000             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040000             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040000             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040000             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040000             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040000             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040000             0102*  ; FatFS file access functions
040000             0103*  ;
040000             0104*  ffs_fopen:			EQU	80h
040000             0105*  ffs_fclose:			EQU	81h
040000             0106*  ffs_fread:			EQU	82h
040000             0107*  ffs_fwrite:			EQU	83h
040000             0108*  ffs_flseek:			EQU	84h
040000             0109*  ffs_ftruncate:		EQU	85h
040000             0110*  ffs_fsync:			EQU	86h
040000             0111*  ffs_fforward:		EQU	87h
040000             0112*  ffs_fexpand:		EQU	88h
040000             0113*  ffs_fgets:			EQU	89h
040000             0114*  ffs_fputc:			EQU	8Ah
040000             0115*  ffs_fputs:			EQU	8Bh
040000             0116*  ffs_fprintf:		EQU	8Ch
040000             0117*  ffs_ftell:			EQU	8Dh
040000             0118*  ffs_feof:			EQU	8Eh
040000             0119*  ffs_fsize:			EQU	8Fh
040000             0120*  ffs_ferror:			EQU	90h
040000             0121*  
040000             0122*  ; FatFS directory access functions
040000             0123*  ;
040000             0124*  ffs_dopen:			EQU	91h
040000             0125*  ffs_dclose:			EQU	92h
040000             0126*  ffs_dread:			EQU	93h
040000             0127*  ffs_dfindfirst:		EQU	94h
040000             0128*  ffs_dfindnext:		EQU	95h
040000             0129*  
040000             0130*  ; FatFS file and directory management functions
040000             0131*  ;
040000             0132*  ffs_stat:			EQU	96h
040000             0133*  ffs_unlink:			EQU	97h
040000             0134*  ffs_rename:			EQU	98h
040000             0135*  ffs_chmod:			EQU	99h
040000             0136*  ffs_utime:			EQU	9Ah
040000             0137*  ffs_mkdir:			EQU	9Bh
040000             0138*  ffs_chdir:			EQU	9Ch
040000             0139*  ffs_chdrive:		EQU	9Dh
040000             0140*  ffs_getcwd:			EQU	9Eh
040000             0141*  
040000             0142*  ; FatFS volume management and system configuration functions
040000             0143*  ;
040000             0144*  ffs_mount:			EQU	9Fh
040000             0145*  ffs_mkfs:			EQU	A0h
040000             0146*  ffs_fdisk:			EQU	A1h
040000             0147*  ffs_getfree:		EQU	A2h
040000             0148*  ffs_getlabel:		EQU	A3h
040000             0149*  ffs_setlabel:		EQU	A4h
040000             0150*  ffs_setcp:			EQU	A5h
040000             0151*  
040000             0152*  ; File access modes
040000             0153*  ;
040000             0154*  fa_read:			EQU	01h
040000             0155*  fa_write:			EQU	02h
040000             0156*  fa_open_existing:	EQU	00h
040000             0157*  fa_create_new:		EQU	04h
040000             0158*  fa_create_always:	EQU	08h
040000             0159*  fa_open_always:		EQU	10h
040000             0160*  fa_open_append:		EQU	30h
040000             0161*  
040000             0162*  ; System variable indexes for api_sysvars
040000             0163*  ; Index into _sysvars in globals.asm
040000             0164*  ;
040000             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040000             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040000             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040000             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040000             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040000             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040000             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040000             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040000             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040000             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040000             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040000             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040000             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040000             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040000             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040000             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040000             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
040000             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0191*  
040000             0192*  ; Flags for the VPD protocol
040000             0193*  ;
040000             0194*  vdp_pflag_cursor:		EQU	00000001b
040000             0195*  vdp_pflag_scrchar:		EQU	00000010b
040000             0196*  vdp_pflag_point:		EQU	00000100b
040000             0197*  vdp_pflag_audio:		EQU	00001000b
040000             0198*  vdp_pflag_mode:			EQU	00010000b
040000             0199*  vdp_pflag_rtc:			EQU	00100000b
040000             0200*  
040000             0201*  ;
040000             0202*  ; FatFS structures
040000             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0204*  ;
040000             0205*  ; Object ID and allocation information (FFOBJID)
040000             0206*  ;
040000             0207*  ; Indexes into FFOBJID structure
040000             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040000             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040000             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
040000             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040000             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040000             0214*  ;
040000             0215*  ; File object structure (FIL)
040000             0216*  ;
040000             0217*  ; Indexes into FIL structure
040000             0218*  fil_obj:		EQU 0	; 15: Object identifier
040000             0219*  fil_flag:		EQU	15 	;  1: File status flags
040000             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
040000             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040000             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040000             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040000             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040000             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040000             0226*  ;
040000             0227*  ; Directory object structure (DIR)
040000             0228*  ; Indexes into DIR structure
040000             0229*  dir_obj:		EQU  0	; 15: Object identifier
040000             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
040000             0231*  dir_clust:		EQU	19	;  4: Current cluster
040000             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040000             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040000             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040000             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0236*  ;
040000             0237*  ; File information structure (FILINFO)
040000             0238*  ;
040000             0239*  ; Indexes into FILINFO structure
040000             0240*  filinfo_fsize:		EQU 0	;   4: File size
040000             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
040000             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
040000             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
040000             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
040000             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
040000             0246*  ;
040000             0247*  ; Macro for calling the API
040000             0248*  ; Parameters:
040000             0249*  ; - function: One of the function numbers listed above
040000             0250*  ;
040000             0251*  	MACRO	MOSCALL	function
040000             0252*  			LD	A, function
040000             0253*  			RST.LIL	08h
040000             0254*  	ENDMACRO
040000             0002   
040000             0003       .assume adl=1
040000             0004       .org 0x040000
040000             0005   
040000 C3 45 00 04 0006       jp start
040004             0007   
040004 FF FF FF FF 0008       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0009       .db "MOS"
040043 00          0010       .db 00h
040044 01          0011       .db 01h
040045             0012   
040045             0013   start:
040045 F5          0014       push af
040046 C5          0015       push bc
040047 D5          0016       push de
040048 DD E5       0017       push ix
04004A FD E5       0018       push iy
04004C             0019   
04004C CD 60 00 04 0020   	call init
040050 CD 07 03 04 0021       call main
040054             0022   
040054             0023   exit:
040054             0024   
040054 FD E1       0025       pop iy
040056 DD E1       0026       pop ix
040058 D1          0027       pop de
040059 C1          0028       pop bc
04005A F1          0029       pop af
04005B 21 00 00 00 0030       ld hl,0
04005F             0031   
04005F C9          0032       ret
040060             0033   
040060             0034   init:
040060 AF          0035       xor a
040061 CD 6B 05 04 0036       call vdu_set_scaling
040065 21 78 13 04 0037   	ld hl,str_hello_world
040069 CD F3 0D 04 0038   	call printString
04006D CD 72 00 04 0039       call cube_init
040071 C9          0040       ret
040072             0041   
040072             0042   ;   210 sid%=100: mid%=1: oid%=1: bmid1%=101: bmid2%=102
040072             0043   sid: equ 100
040072             0044   mid: equ 1
040072             0045   oid: equ 1
040072             0046   bmid1: equ 101
040072             0047   bmid2: equ 102
040072             0048   model_vertices: equ 8
040072             0049   model_indexes: equ 36
040072             0050   
040072             0051   obj_scale: equ 1*256
040072             0052   
040072             0053   ;   230 scene_width%=320: scene_height%=240
040072             0054   scene_width: equ 320
040072             0055   scene_height: equ 240
040072             0056   
040072             0057   ;   250 f=32767.0/256.0
040072             0058   ;   260 distx=0*f: disty=0*f: distz=-25*f
040072             0059   cam_f: equ 32767/256
040072             0060   cam_distx: equ 0*cam_f
040072             0061   cam_disty: equ 2*cam_f
040072             0062   cam_distz: equ -25*cam_f
040072             0063   
040072             0064   ;   280 pi2=PI*2.0: f=32767.0/pi2
040072             0065   ;   290 anglex=0.0*f
040072             0066   cam_anglex: equ 0
040072             0067   
040072             0068   cube_init:
040072             0069   ;   220 PRINT "Creating control structure"
040072 21 D6 14 04 0070       ld hl,str_create_control
040076 CD F3 0D 04 0071       call printString
04007A 21 88 00 04 0072       ld hl,@ccs_beg
04007E 01 0B 00 00 0073       ld bc,@ccs_end-@ccs_beg
040082 5B DF       0074       rst.lil $18
040084 C3 93 00 04 0075       jp @ccs_end
040088             0076   @ccs_beg:
040088             0077   ;   240 VDU 23,0, &A0, sid%; &49, 0, scene_width%; scene_height%; : REM Create Control Structure
040088 17 00 A0    0078       db 23,0,$A0
04008B 64 00       0079       dw sid
04008D 49 00       0080       db $49,0
04008F 40 01       0081       dw scene_width
040091 F0 00       0082       dw scene_height
040093             0083   @ccs_end:
040093             0084   
040093             0085   ; set camera distance
040093 21 BB 14 04 0086       ld hl,str_set_camera_distance
040097 CD F3 0D 04 0087       call printString
04009B 21 A9 00 04 0088       ld hl,@scd_beg
04009F 01 0D 00 00 0089       ld bc,@scd_end-@scd_beg
0400A3 5B DF       0090       rst.lil $18
0400A5 C3 B6 00 04 0091       jp @scd_end
0400A9             0092   @scd_beg:
0400A9             0093   ;   270 VDU 23,0, &A0, sid%; &49, 25, distx; disty; distz; : REM Set Camera XYZ Translation Distances
0400A9 17 00 A0    0094       db 23,0,$A0
0400AC 64 00       0095       dw sid
0400AE 49 19       0096       db $49,25
0400B0 00 00       0097       dw cam_distx
0400B2 FE 00       0098       dw cam_disty
0400B4 99 F3       0099       dw cam_distz
0400B6             0100   @scd_end:
0400B6             0101   
0400B6             0102   ; set camera x rotation
0400B6 21 9E 14 04 0103       ld hl,str_set_camera_x_rotation
0400BA CD F3 0D 04 0104       call printString
0400BE 21 CC 00 04 0105       ld hl,@scxr_beg
0400C2 01 09 00 00 0106       ld bc,@scxr_end-@scxr_beg
0400C6 5B DF       0107       rst.lil $18
0400C8 C3 D5 00 04 0108       jp @scxr_end
0400CC             0109   @scxr_beg:
0400CC             0110   ;   300 VDU 23,0, &A0, sid%; &49, 18, anglex; : REM Set Camera X Rotation Angle
0400CC 17 00 A0    0111       db 23,0,$A0
0400CF 64 00       0112       dw sid
0400D1 49 12       0113       db $49,18
0400D3 00 00       0114       dw cam_anglex
0400D5             0115   @scxr_end:
0400D5             0116   
0400D5             0117   ;   310 PRINT "Sending vertices using factor ";factor
0400D5 21 8A 14 04 0118       ld hl,str_send_vertices
0400D9 CD F3 0D 04 0119       call printString
0400DD 21 EB 00 04 0120       ld hl,@sv_beg
0400E1 01 3B 00 00 0121       ld bc,@sv_end-@sv_beg
0400E5 5B DF       0122       rst.lil $18
0400E7 C3 26 01 04 0123       jp @sv_end
0400EB             0124   @sv_beg:
0400EB             0125   ;   320 VDU 23,0, &A0, sid%; &49, 1, mid%; model_vertices%; : REM Define Mesh Vertices
0400EB 17 00 A0    0126       db 23,0,$A0
0400EE 64 00       0127       dw sid
0400F0 49 01       0128       db $49,1
0400F2 01 00 08 00 0129       dw mid, model_vertices
0400F6 FF 7F 01 80 0130       dw 32767, -32767, 32767
       FF 7F       
0400FC FF 7F FF 7F 0131       dw 32767, 32767, 32767
       FF 7F       
040102 FF 7F 01 80 0132       dw 32767, -32767, -32767
       01 80       
040108 FF 7F FF 7F 0133       dw 32767, 32767, -32767
       01 80       
04010E 01 80 01 80 0134       dw -32767, -32767, 32767
       FF 7F       
040114 01 80 FF 7F 0135       dw -32767, 32767, 32767
       FF 7F       
04011A 01 80 01 80 0136       dw -32767, -32767, -32767
       01 80       
040120 01 80 FF 7F 0137       dw -32767, 32767, -32767
       01 80       
040126             0138   @sv_end:
040126             0139   
040126             0140   ;   390 PRINT "Reading and sending vertex indexes"
040126 21 70 14 04 0141       ld hl,str_set_mesh_vertex_indexes
04012A CD F3 0D 04 0142       call printString
04012E 21 3C 01 04 0143       ld hl,@smvi_beg
040132 01 53 00 00 0144       ld bc,@smvi_end-@smvi_beg
040136 5B DF       0145       rst.lil $18
040138 C3 8F 01 04 0146       jp @smvi_done
04013C             0147   @smvi_beg:
04013C             0148   ;   400 VDU 23,0, &A0, sid%; &49, 2, mid%; model_indexes%; : REM Set Mesh Vertex Indexes
04013C 17 00 A0    0149       db 23,0,$A0
04013F 64 00       0150       dw sid
040141 49 02       0151       db $49,2
040143 01 00 24 00 0152       dw mid, model_indexes
040147 04 00 02 00 0153       dw 4, 2, 0
       00 00       
04014D 02 00 07 00 0154       dw 2, 7, 3
       03 00       
040153 06 00 05 00 0155       dw 6, 5, 7
       07 00       
040159 01 00 07 00 0156       dw 1, 7, 5
       05 00       
04015F 00 00 03 00 0157       dw 0, 3, 1
       01 00       
040165 04 00 01 00 0158       dw 4, 1, 5
       05 00       
04016B 04 00 06 00 0159       dw 4, 6, 2
       02 00       
040171 02 00 06 00 0160       dw 2, 6, 7
       07 00       
040177 06 00 04 00 0161       dw 6, 4, 5
       05 00       
04017D 01 00 03 00 0162       dw 1, 3, 7
       07 00       
040183 00 00 02 00 0163       dw 0, 2, 3
       03 00       
040189 04 00 00 00 0164       dw 4, 0, 1
       01 00       
04018F             0165   @smvi_end:
04018F             0166   @smvi_done:
04018F             0167   
04018F             0168   ;   470 PRINT "Sending texture coordinate indexes"
04018F 21 51 14 04 0169       ld hl,str_set_texture_coordinates
040193 CD F3 0D 04 0170       call printString
040197 21 A5 01 04 0171       ld hl,@stc_beg
04019B 01 0F 00 00 0172       ld bc,@stc_end-@stc_beg
04019F 5B DF       0173       rst.lil $18
0401A1 C3 B4 01 04 0174       jp @stc_end
0401A5             0175   @stc_beg:
0401A5             0176   ;   480 VDU 23,0, &A0, sid%; &49, 3, mid%; 1; 32768; 32768; : REM Define Texture Coordinates
0401A5 17 00 A0    0177       db 23,0,$A0
0401A8 64 00       0178       dw sid
0401AA 49 03       0179       db $49,3
0401AC 01 00       0180       dw mid
0401AE 01 00       0181       dw 1
0401B0 00 80       0182       dw 32768
0401B2 00 80       0183       dw 32768
0401B4             0184   @stc_end:
0401B4             0185   
0401B4 21 2B 14 04 0186       ld hl,str_set_tex_coord_idxs
0401B8 CD F3 0D 04 0187       call printString
0401BC 21 C8 01 04 0188       ld hl,@stci_beg
0401C0 01 53 00 00 0189       ld bc,@stci_end-@stci_beg
0401C4 C3 1B 02 04 0190       jp @stci_end
0401C8             0191   @stci_beg:
0401C8             0192   ;   490 VDU 23,0, &A0, sid%; &49, 4, mid%; model_indexes%; : REM Set Texture Coordinate Indexes
0401C8 17 00 A0    0193       db 23,0,$A0
0401CB 64 00       0194       dw sid
0401CD 49 04       0195       db $49,4
0401CF 01 00 24 00 0196       dw mid, model_indexes
0401D3             0197   ;   500 FOR i%=0 TO model_indexes%-1
0401D3             0198   ;   510   VDU 0;
0401D3             0199   ;   520 NEXT i%
0401D3 00 00 00 00 0200       blkw model_indexes, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04021B             0201   @stci_end:
04021B             0202   @stci_done:
04021B             0203   
04021B             0204   ;   530 PRINT "Creating texture bitmap"
04021B 21 F3 13 04 0205       ld hl,str_create_texture_bitmap
04021F CD F3 0D 04 0206       call printString
040223 21 31 02 04 0207       ld hl,@ctb_beg
040227 01 05 00 00 0208       ld bc,@ctb_end-@ctb_beg
04022B 5B DF       0209       rst.lil $18
04022D C3 36 02 04 0210       jp @ctb_end
040231             0211   @ctb_beg:
040231             0212   ;   540 VDU 23, 27, 0, bmid1%: REM Create a bitmap for a texture
040231 17 1B 00    0213       db 23,27,0
040234 65 00       0214       dw bmid1
040236             0215   @ctb_end:
040236             0216   
040236             0217   ;   550 PRINT "Setting texture pixel"
040236 21 DA 13 04 0218       ld hl,str_set_texture_pixel
04023A CD F3 0D 04 0219       call printString
04023E 21 4C 02 04 0220       ld hl,@stp_beg
040242 01 0B 00 00 0221       ld bc,@stp_end-@stp_beg
040246 5B DF       0222       rst.lil $18
040248 C3 57 02 04 0223       jp @stp_end
04024C             0224   @stp_beg:
04024C             0225   ;   560 VDU 23, 27, 1, 1; 1; &55, &AA, &FF, &C0 : REM Set a pixel in the bitmap
04024C 17 1B 01    0226       db 23,27,1
04024F 01 00 01 00 0227       dw 1,1
040253 55 AA FF C0 0228       db $55,$AA,$FF,$C0
040257             0229   @stp_end:
040257             0230   
040257             0231   ;   570 PRINT "Create 3D object"
040257 21 98 13 04 0232       ld hl,str_create_object
04025B CD F3 0D 04 0233       call printString
04025F 21 6D 02 04 0234       ld hl,@co_beg
040263 01 0D 00 00 0235       ld bc,@co_end-@co_beg
040267 5B DF       0236       rst.lil $18
040269 C3 7A 02 04 0237       jp @co_end
04026D             0238   @co_beg:
04026D             0239   ;   580 VDU 23,0, &A0, sid%; &49, 5, oid%; mid%; bmid1%+64000; : REM Create Object
04026D 17 00 A0    0240       db 23,0,$A0
040270 64 00       0241       dw sid
040272 49 05       0242       db $49,5
040274 01 00       0243       dw oid
040276 01 00       0244       dw mid
040278 65 FA       0245       dw bmid1+64000
04027A             0246   @co_end:
04027A             0247   
04027A             0248   ;   590 PRINT "Scale object"
04027A 21 AE 13 04 0249       ld hl,str_scale_object
04027E CD F3 0D 04 0250       call printString
040282             0251   ;   600 scale=1.0*256.0
040282 21 90 02 04 0252       ld hl,@so_beg
040286 01 0F 00 00 0253       ld bc,@so_end-@so_beg
04028A 5B DF       0254       rst.lil $18
04028C C3 9F 02 04 0255       jp @so_end
040290             0256   @so_beg:
040290             0257   ;   610 VDU 23, 0, &A0, sid%; &49, 9, oid%; scale; scale; scale; : REM Set Object XYZ Scale Factors
040290 17 00 A0    0258       db 23,0,$A0
040293 64 00       0259       dw sid
040295 49 09       0260       db $49,9
040297 01 00       0261       dw oid
040299 00 01       0262       dw obj_scale
04029B 00 01       0263       dw obj_scale
04029D 00 01       0264       dw obj_scale
04029F             0265   @so_end:
04029F             0266   
04029F             0267   ;   620 PRINT "Create target bitmap"
04029F 21 C0 13 04 0268       ld hl,str_create_target_bitmap
0402A3 CD F3 0D 04 0269       call printString
0402A7 21 B5 02 04 0270       ld hl,@ctb2_beg
0402AB 01 10 00 00 0271       ld bc,@ctb2_end-@ctb2_beg
0402AF 5B DF       0272       rst.lil $18
0402B1 C3 C5 02 04 0273       jp @ctb2_end
0402B5             0274   @ctb2_beg:
0402B5             0275   ;   630 VDU 23, 27, 0, bmid2% : REM Select output bitmap
0402B5 17 1B 00    0276       db 23,27,0
0402B8 66 00       0277       dw bmid2
0402BA             0278   ;   640 VDU 23, 27, 2, scene_width%; scene_height%; &0000; &00C0; : REM Create solid color bitmap
0402BA 17 1B 02    0279       db 23,27,2
0402BD 40 01       0280       dw scene_width
0402BF F0 00       0281       dw scene_height
0402C1 00 00       0282       dw $0000
0402C3 C0 00       0283       dw $00C0
0402C5             0284   @ctb2_end:
0402C5             0285   
0402C5 21 F4 14 04 0286       ld hl,str_init_cmplt
0402C9 CD F3 0D 04 0287       call printString
0402CD 3E 40       0288       ld a,%01000000
0402CF CD 58 13 04 0289       call multiPurposeDelay
0402D3             0290   
0402D3 C9          0291       ret
0402D4             0292   
0402D4 52 65 6E 64 0293   str_render_to_bitmap: db "Rendering to bitmap.\r\n",0
       65 72 69 6E 
       67 20 74 6F 
       20 62 69 74 
       6D 61 70 2E 
       0D 0A 00    
0402EB 44 69 73 70 0294   str_display_output_bitmap: db "Displaying output bitmap.\r\n",0
       6C 61 79 69 
       6E 67 20 6F 
       75 74 70 75 
       74 20 62 69 
       74 6D 61 70 
       2E 0D 0A 00 
040307             0295   
040307             0296   main:
040307 21 D4 02 04 0297       ld hl,str_render_to_bitmap
04030B CD F3 0D 04 0298       call printString
04030F 3E 40       0299       ld a,%01000000
040311 CD 58 13 04 0300       call multiPurposeDelay
040315             0301   ; draw the cube
040315 21 23 03 04 0302       ld hl,@bmpbeg
040319 01 09 00 00 0303       ld bc,@bmpend-@bmpbeg
04031D 5B DF       0304       rst.lil $18
04031F C3 2C 03 04 0305       jp @bmpend
040323             0306   @bmpbeg:
040323             0307   ; 6800 VDU 23, 0, &A0, sid%; &49, 38, bmid2%+64000; : REM Render To Bitmap
040323 17 00 A0    0308       db 23, 0, $A0 ; Render To Bitmap
040326 64 00       0309       dw sid
040328 49 26       0310       db $49, 38
04032A 66 FA       0311       dw bmid2+64000
04032C             0312   @bmpend:
04032C             0313   
04032C 21 EB 02 04 0314       ld hl,str_display_output_bitmap
040330 CD F3 0D 04 0315       call printString
040334 3E 40       0316       ld a,%01000000
040336 CD 58 13 04 0317       call multiPurposeDelay
04033A             0318   ; 6810 VDU 23, 27, 3, 0; 0; : REM Display output bitmap
04033A 21 48 03 04 0319       ld hl,@bmpdispbeg
04033E 01 07 00 00 0320       ld bc,@bmpdispend-@bmpdispbeg
040342 5B DF       0321       rst.lil $18
040344 C3 4F 03 04 0322       jp @bmpdispend
040348             0323   @bmpdispbeg:
040348 17 1B 03    0324       db 23, 27, 3 ; Display output bitmap
04034B 00 00 00 00 0325       dw 0, 0
04034F             0326   @bmpdispend:
04034F             0327   
04034F C9          0328   	ret
040350             0329   
040350             0330   	include "pingo/src/asm/vdu.asm"
040350             0001*  ; The following is a high-level list of the VDU sequences that are supported:
040350             0002*  ; VDU 0: Null (no operation)
040350             0003*  ; VDU 1: Send next character to “printer” (if “printer” is enabled) §§
040350             0004*  ; VDU 2: Enable “printer” §§
040350             0005*  ; VDU 3: Disable “printer” §§
040350             0006*  ; VDU 4: Write text at text cursor
040350             0007*  ; VDU 5: Write text at graphics cursor
040350             0008*  ; VDU 6: Enable screen (opposite of VDU 21) §§
040350             0009*  ; VDU 7: Make a short beep (BEL)
040350             0010*  ; VDU 8: Move cursor back one character
040350             0011*  ; VDU 9: Move cursor forward one character
040350             0012*  ; VDU 10: Move cursor down one line
040350             0013*  ; VDU 11: Move cursor up one line
040350             0014*  ; VDU 12: Clear text area (CLS)
040350             0015*  ; VDU 13: Carriage return
040350             0016*  ; VDU 14: Page mode On *
040350             0017*  ; VDU 15: Page mode Off *
040350             0018*  ; VDU 16: Clear graphics area (CLG)
040350             0019*  ; VDU 17, colour: Define text colour (COLOUR)
040350             0020*  ; VDU 18, mode, colour: Define graphics colour (GCOL mode, colour)
040350             0021*  ; VDU 19, l, p, r, g, b: Define logical colour (COLOUR l, p / COLOUR l, r, g, b)
040350             0022*  ; VDU 20: Reset palette and text/graphics colours and drawing modes §§
040350             0023*  ; VDU 21: Disable screen (turns of VDU command processing, except for VDU 1 and VDU 6) §§
040350             0024*  ; VDU 22, n: Select screen mode (MODE n)
040350             0025*  ; VDU 23, n: Re-program display character / System Commands
040350             0026*  ; VDU 24, left; bottom; right; top;: Set graphics viewport **
040350             0027*  ; VDU 25, mode, x; y;: PLOT command
040350             0028*  ; VDU 26: Reset graphics and text viewports **
040350             0029*  ; VDU 27, char: Output character to screen §
040350             0030*  ; VDU 28, left, bottom, right, top: Set text viewport **
040350             0031*  ; VDU 29, x; y;: Set graphics origin
040350             0032*  ; VDU 30: Home cursor
040350             0033*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
040350             0034*  ; VDU 127: Backspace
040350             0035*  
040350             0036*  ; VDU 0: Null (no operation)
040350             0037*  ;     On encountering a VDU 0 command, the VDP will do nothing.
040350             0038*  ;     This may be useful for padding out a VDU command sequence,
040350             0039*  ;     or for inserting a placeholder for a command that will be added later.
040350             0040*  ; inputs: none
040350             0041*  ; outputs: an empty byte somewhere in VDU
040350             0042*  ; destroys: a
040350             0043*  vdu_null:
040350 AF          0044*      xor a
040351 5B D7       0045*  	rst.lil $10
040353 C9          0046*  	ret
040354             0047*  
040354             0048*  ; VDU 1: Send next character to “printer” (if “printer” is enabled) §§
040354             0049*  ;     Ensures that the next character received by the VDP is sent through to
040354             0050*  ;     the “printer”, and not to the screen. This is useful for sending control
040354             0051*  ;     codes to the “printer”, or for sending data to the “printer” that is not
040354             0052*  ;     intended to be displayed on the screen. It allows characters that would
040354             0053*  ;     not otherwise normally be sent through to the “printer” to be sent.
040354             0054*  ;     If the “printer” has not been enabled then this command will just discard
040354             0055*  ;     the next byte sent to the VDP.
040354             0056*  ; inputs: a is the ascii code of the character to send
040354             0057*  ; prerequisites: "printer" must first be activated with VDU 2 (see below)
040354             0058*  ; outputs: a character on the serial terminal connected to the USB port
040354             0059*  ;           and the same character on the screen at the current text cursor location
040354             0060*  ; QUESTION: does it also advance the text cursor?
040354             0061*  ; destroys: hl, bc
040354             0062*  vdu_char_to_printer:
040354 32 64 03 04 0063*  	ld (@arg),a
040358 21 63 03 04 0064*  	ld hl,@cmd
04035C 01 02 00 00 0065*  	ld bc,@end-@cmd
040360 5B DF       0066*  	rst.lil $18
040362 C9          0067*  	ret
040363 01          0068*  @cmd: db 1
040364 00          0069*  @arg: db 0
040365             0070*  @end:
040365             0071*  
040365             0072*  ; VDU 2: Enable “printer” §§
040365             0073*  ;     Enables the “printer”.
040365             0074*  ;     In the context of the Agon platform, the “printer” is a serial
040365             0075*  ;     terminal that is connected to the VDP’s USB port. Typically
040365             0076*  ;     this port is used for power, but it can also be used to send and
040365             0077*  ;     receive data to and from the VDP.
040365             0078*  ;     When the “printer” is enabled, the VDP will send characters it receives
040365             0079*  ;     to the “printer” as well as to the screen. It will additionally send
040365             0080*  ;     through control codes 8-13. To send other control codes to the “printer”,
040365             0081*  ;     use the VDU 1 command.
040365             0082*  ;     The VDP will not send through other control codes to the printer,
040365             0083*  ;     and will will not send through data it receives as part of other commands.
040365             0084*  vdu_enable_printer:
040365 3E 02       0085*      ld a,2
040367 5B D7       0086*  	rst.lil $10
040369 C9          0087*  	ret
04036A             0088*  
04036A             0089*  ; VDU 3: Disable “printer” §§
04036A             0090*  ; inputs: none
04036A             0091*  ; outputs: a USB port bereft of communication with the VDP
04036A             0092*  ; destroys: a
04036A             0093*  vdu_disable_printer:
04036A 3E 03       0094*      ld a,3
04036C 5B D7       0095*  	rst.lil $10
04036E C9          0096*  	ret
04036F             0097*  
04036F             0098*  ; VDU 4: Write text at text cursor
04036F             0099*  ;     This causes text to be written at the current text cursor position.
04036F             0100*  ;     This is the default mode for text display.
04036F             0101*  ;     Text is written using the current text foreground and background colours.
04036F             0102*  ; inputs: a is the character to write to the screen
04036F             0103*  ; prerequisites: the text cursor at the intended position on screen
04036F             0104*  ; outputs: prints the character and moves text cursor right one position
04036F             0105*  ; destroys: a, hl, bc
04036F             0106*  vdu_char_to_text_cursor:
04036F 32 7F 03 04 0107*  	ld (@arg),a
040373 21 7E 03 04 0108*  	ld hl,@cmd
040377 01 02 00 00 0109*  	ld bc,@end-@cmd
04037B 5B DF       0110*  	rst.lil $18
04037D C9          0111*  	ret
04037E 04          0112*  @cmd: db 4
04037F 00          0113*  @arg: db 0
040380             0114*  @end:
040380             0115*  
040380             0116*  ; VDU 5: Write text at graphics cursor
040380             0117*  ;     This causes text to be written at the current graphics cursor position.
040380             0118*  ;     Using this, characters may be positioned at any graphics coordinate within
040380             0119*  ;     the graphics viewport. This is useful for positioning text over graphics,
040380             0120*  ;     or for positioning text at a specific location on the screen.
040380             0121*  ;     Characters are plotted using the current graphics foreground colour,
040380             0122*  ;     using the current graphics foreground plotting mode (see VDU 18).
040380             0123*  ;     The character background is transparent, and will not overwrite any
040380             0124*  ;     graphics that are already present at the character’s location.
040380             0125*  ;     The exception to this is VDU 27, the “delete” character, which backspaces
040380             0126*  ;     and deletes as per its usual behaviour, but will erase using the current
040380             0127*  ;     graphics background colour.
040380             0128*  ; inputs: a is the character to write to the screen
040380             0129*  ; prerequisites: the graphics cursor at the intended position on screen
040380             0130*  ; outputs: see the name of the function
040380             0131*  ; destroys: a, hl, bc
040380             0132*  vdu_char_to_gfx_cursor:
040380 32 90 03 04 0133*  	ld (@arg),a
040384 21 8F 03 04 0134*  	ld hl,@cmd
040388 01 02 00 00 0135*  	ld bc,@end-@cmd
04038C 5B DF       0136*  	rst.lil $18
04038E C9          0137*  	ret
04038F 05          0138*  @cmd: db 5
040390 00          0139*  @arg: db 0
040391             0140*  @end:
040391             0141*  
040391             0142*  ; VDU 6: Enable screen (opposite of VDU 21) §§
040391             0143*  ;     This enables the screen, and re-enables VDU command processing,
040391             0144*  ;     reversing the effect of VDU 21.
040391             0145*  ; inputs: none
040391             0146*  ; outputs: a functioning screen and VDU
040391             0147*  ; destroys: a
040391             0148*  vdu_enable_screen:
040391 3E 06       0149*      ld a,6
040393 5B D7       0150*  	rst.lil $10
040395 C9          0151*  	ret
040396             0152*  
040396             0153*  ; PASSES
040396             0154*  ; VDU 7: Make a short beep (BEL)
040396             0155*  ;     Plays a short beep sound on audio channel 0. If the audio channel
040396             0156*  ;     is already in use, or has been disabled, then this command will have no effect.
040396             0157*  ; inputs: none
040396             0158*  ; outputs: an unpleasant but thankfully short-lived audio tone
040396             0159*  ; destroys: a
040396             0160*  vdu_beep:
040396 3E 07       0161*      ld a,7
040398 5B D7       0162*  	rst.lil $10
04039A C9          0163*  	ret
04039B             0164*  
04039B             0165*  ; VDU 8: Move cursor back one character
04039B             0166*  ;     Moves the text cursor one character in the negative “X” direction.
04039B             0167*  ;     By default, when at the start of a line it will move to the end of
04039B             0168*  ;     the previous line (as defined by the current text viewport).
04039B             0169*  ;     If the cursor is also at the top of the screen then the viewport will scroll down.
04039B             0170*  ;     The cursor remains constrained to the current text viewport.
04039B             0171*  ;     When in VDU 5 mode and the graphics cursor is active, the viewport will not scroll.
04039B             0172*  ;     The cursor is just moved left by one character width.
04039B             0173*  ;     Further behaviour of the cursor can be controlled using the VDU 23,16 command.
04039B             0174*  ;     It should be noted that as of Console8 VDP 2.5.0, the cursor system does not
04039B             0175*  ;     support adjusting the direction of the cursor’s X axis, so this command
04039B             0176*  ;     will move the cursor to the left. This is likely to change in the future.
04039B             0177*  vdu_cursor_back:
04039B 3E 08       0178*      ld a,8
04039D 5B D7       0179*  	rst.lil $10
04039F C9          0180*  	ret
0403A0             0181*  
0403A0             0182*  ; VDU 9: Move cursor forward one character
0403A0             0183*  vdu_cursor_forward:
0403A0 3E 09       0184*      ld a,9
0403A2 5B D7       0185*  	rst.lil $10
0403A4 C9          0186*  	ret
0403A5             0187*  
0403A5             0188*  ; VDU 10: Move cursor down one line
0403A5             0189*  vdu_cursor_down:
0403A5 3E 0A       0190*      ld a,10
0403A7 5B D7       0191*  	rst.lil $10
0403A9 C9          0192*  	ret
0403AA             0193*  
0403AA             0194*  ; VDU 11: Move cursor up one line
0403AA             0195*  vdu_cursor_up:
0403AA 3E 0B       0196*      ld a,11
0403AC 5B D7       0197*  	rst.lil $10
0403AE C9          0198*  	ret
0403AF             0199*  
0403AF             0200*  ; VDU 12: Clear text area (CLS)
0403AF             0201*  vdu_cls:
0403AF 3E 0C       0202*      ld a,12
0403B1 5B D7       0203*  	rst.lil $10
0403B3 C9          0204*  	ret
0403B4             0205*  
0403B4             0206*  ; VDU 13: Carriage return
0403B4             0207*  vdu_cr:
0403B4 3E 0D       0208*      ld a,13
0403B6 5B D7       0209*  	rst.lil $10
0403B8 C9          0210*  	ret
0403B9             0211*  
0403B9             0212*  ; VDU 14: Page mode On *
0403B9             0213*  vdu_page_on:
0403B9 3E 0E       0214*      ld a,14
0403BB 5B D7       0215*  	rst.lil $10
0403BD C9          0216*  	ret
0403BE             0217*  
0403BE             0218*  ; VDU 15: Page mode Off *
0403BE             0219*  vdu_page_off:
0403BE 3E 0F       0220*      ld a,15
0403C0 5B D7       0221*  	rst.lil $10
0403C2 C9          0222*  	ret
0403C3             0223*  
0403C3             0224*  ; VDU 16: Clear graphics area (CLG)
0403C3             0225*  vdu_clg:
0403C3 3E 10       0226*      ld a,16
0403C5 5B D7       0227*  	rst.lil $10
0403C7 C9          0228*  	ret
0403C8             0229*  
0403C8             0230*  ; VDU 17, colour: Define text colour (COLOUR)
0403C8             0231*  vdu_colour_text:
0403C8 32 D8 03 04 0232*  	ld (@arg),a
0403CC 21 D7 03 04 0233*  	ld hl,@cmd
0403D0 01 02 00 00 0234*  	ld bc,@end-@cmd
0403D4 5B DF       0235*  	rst.lil $18
0403D6 C9          0236*  	ret
0403D7 11          0237*  @cmd: db 17
0403D8 00          0238*  @arg: db 0
0403D9             0239*  @end:
0403D9             0240*  
0403D9             0241*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0403D9             0242*  ; inputs: a is the plotting mode, c is the colour
0403D9             0243*  ; outputs: a VDU set to put pixels on the screen with the selected mode/colour
0403D9             0244*  vdu_gcol_fg:
0403D9             0245*  ; This command will set both the current graphics colour,
0403D9             0246*  ; and the current graphics plotting mode.
0403D9             0247*  ; As with VDU 17 the colour number will set the foreground colour
0403D9             0248*  ; if it is in the range 0-127, or the background colour if it is
0403D9             0249*  ; in the range 128-255, and will be interpreted in the same manner.
0403D9             0250*  ; Support for different plotting modes on Agon is currently very limited.
0403D9             0251*  ; The only fully supported mode is mode 0, which is the default mode.
0403D9             0252*  ; This mode will plot the given colour at the given graphics coordinate,
0403D9             0253*  ; and will overwrite any existing graphics at that coordinate. There is
0403D9             0254*  ; very limited support for mode 4, which will invert the colour of any
0403D9             0255*  ; existing graphics at the given coordinate, but this is not fully supported
0403D9             0256*  ; and may not work as expected.
0403D9             0257*  ; Support for other plotting modes, matching those provided by Acorn’s
0403D9             0258*  ; original VDU system, may be added in the future.
0403D9             0259*  ; This command is identical to the BASIC GCOL keyword.
0403D9 32 EE 03 04 0260*  	ld (@mode),a
0403DD 79          0261*      ld a,c
0403DE 32 EF 03 04 0262*      ld (@col),a
0403E2 21 ED 03 04 0263*  	ld hl,@cmd
0403E6 01 03 00 00 0264*  	ld bc,@end-@cmd
0403EA 5B DF       0265*  	rst.lil $18
0403EC C9          0266*  	ret
0403ED 12          0267*  @cmd: db 18
0403EE 00          0268*  @mode: db 0
0403EF 00          0269*  @col: db 0
0403F0             0270*  @end:
0403F0             0271*  
0403F0             0272*  vdu_gcol_bg:
0403F0 32 07 04 04 0273*  	ld (@mode),a
0403F4 79          0274*      ld a,c
0403F5 C6 80       0275*      add a,128
0403F7 32 08 04 04 0276*      ld (@col),a
0403FB 21 06 04 04 0277*  	ld hl,@cmd
0403FF 01 03 00 00 0278*  	ld bc,@end-@cmd
040403 5B DF       0279*  	rst.lil $18
040405 C9          0280*  	ret
040406 12          0281*  @cmd:  db 18
040407 00          0282*  @mode: db 0
040408 00          0283*  @col:  db 0
040409             0284*  @end:
040409             0285*  
040409             0286*  ; VDU 19, l, p, r, g, b: Define logical colour (COLOUR l, p / COLOUR l, r, g, b)
040409             0287*  ;     This command sets the colour palette, by mapping a logical colour
040409             0288*  ;     to a physical colour. This is useful for defining custom colours,
040409             0289*  ;     or for redefining the default colours.
040409             0290*  ;     If the physical colour number is given as 255 then the colour will
040409             0291*  ;     be defined using the red, green, and blue values given. If the physical
040409             0292*  ;     colour number is given as any other value then the colour will be defined
040409             0293*  ;     using the colour palette entry given by that number, up to colour number 63.
040409             0294*  ;     If the physical colour is not 255 then the red, green, and blue values
040409             0295*  ;     must still be provided, but will be ignored.
040409             0296*  ;     The values for red, green and blue must be given in the range 0-255.
040409             0297*  ;     You should note that the physical Agon hardware only supports 64 colours,
040409             0298*  ;     so the actual colour displayed may not be exactly the same as the colour
040409             0299*  ;     requested. The nearest colour will be chosen.
040409             0300*  ;     This command is equivalent to the BASIC COLOUR keyword.
040409             0301*  ; inputs: a=physcial colour, b=logical colour, chl=r,g,b
040409             0302*  vdu_def_log_colour:
040409 32 2E 04 04 0303*  	ld (@physical),a
04040D 47          0304*      ld b,a
04040E 32 2D 04 04 0305*      ld (@logical),a
040412 79          0306*      ld a,c
040413 32 2F 04 04 0307*      ld (@red),a
040417 7C          0308*      ld a,h
040418 32 30 04 04 0309*      ld (@green),a
04041C 7D          0310*      ld a,l
04041D 32 31 04 04 0311*      ld (@blue),a
040421 21 2C 04 04 0312*  	ld hl,@cmd
040425 01 06 00 00 0313*  	ld bc,@end-@cmd
040429 5B DF       0314*  	rst.lil $18
04042B C9          0315*  	ret
04042C 13          0316*  @cmd: db 19
04042D 00          0317*  @logical: db 0
04042E 00          0318*  @physical: db 0
04042F 00          0319*  @red: db 0
040430 00          0320*  @green: db 0
040431 00          0321*  @blue: db 0
040432             0322*  @end:
040432             0323*  
040432             0324*  ; VDU 20: Reset palette and text/graphics colours and drawing modes §§
040432             0325*  vdu_reset_gfx:
040432 3E 14       0326*      ld a,20
040434 5B D7       0327*  	rst.lil $10
040436 C9          0328*  	ret
040437             0329*  
040437             0330*  ; VDU 21: Disable screen (turns off VDU command processing,
040437             0331*  ; except for VDU 1 and VDU 6) §§
040437             0332*  vdu_disable_screen:
040437 3E 15       0333*      ld a,21
040439 5B D7       0334*  	rst.lil $10
04043B C9          0335*  	ret
04043C             0336*  
04043C             0337*  ; VDU 22, n: Select screen mode (MODE n)
04043C             0338*  ; Inputs: a, screen mode (8-bit unsigned integer), in the following list:
04043C             0339*  ; https://agonconsole8.github.io/agon-docs/VDP---Screen-Modes.html
04043C             0340*  ; Screen modes
04043C             0341*  ; Modes over 128 are double-buffered
04043C             0342*  ; From Version 1.04 or greater
04043C             0343*  ; Mode 	Horz 	Vert 	Cols 	Refresh
04043C             0344*  ; 0 	640 	480 	16 	    60hz
04043C             0345*  ; * 1 	640 	480 	4 	    60hz
04043C             0346*  ; 2 	640 	480 	2 	    60hz
04043C             0347*  ; 3 	640 	240 	64 	    60hz
04043C             0348*  ; 4 	640 	240 	16 	    60hz
04043C             0349*  ; 5 	640 	240 	4 	    60hz
04043C             0350*  ; 6 	640 	240 	2 	    60hz
04043C             0351*  ; ** 7 	n/a 	n/a 	16 	    60hz
04043C             0352*  ; 8 	320 	240 	64 	    60hz
04043C             0353*  ; 9 	320 	240 	16 	    60hz
04043C             0354*  ; 10 	320 	240 	4 	    60hz
04043C             0355*  ; 11 	320 	240 	2 	    60hz
04043C             0356*  ; 12 	320 	200 	64 	    70hz
04043C             0357*  ; 13 	320 	200 	16 	    70hz
04043C             0358*  ; 14 	320 	200 	4 	    70hz
04043C             0359*  ; 15 	320 	200 	2 	    70hz
04043C             0360*  ; 16 	800 	600 	4 	    60hz
04043C             0361*  ; 17 	800 	600 	2 	    60hz
04043C             0362*  ; 18 	1024 	768 	2 	    60hz
04043C             0363*  ; 129 	640 	480 	4 	    60hz
04043C             0364*  ; 130 	640 	480 	2 	    60hz
04043C             0365*  ; 132 	640 	240 	16 	    60hz
04043C             0366*  ; 133 	640 	240 	4 	    60hz
04043C             0367*  ; 134 	640 	240 	2 	    60hz
04043C             0368*  ; 136 	320 	240 	64 	    60hz
04043C             0369*  ; 137 	320 	240 	16 	    60hz
04043C             0370*  ; 138 	320 	240 	4 	    60hz
04043C             0371*  ; 139 	320 	240 	2 	    60hz
04043C             0372*  ; 140 	320 	200 	64 	    70hz
04043C             0373*  ; 141 	320 	200 	16 	    70hz
04043C             0374*  ; 142 	320 	200 	4 	    70hz
04043C             0375*  ; 143 	320 	200 	2 	    70hz
04043C             0376*  ; * Mode 1 is the “default” mode, and is the mode that the system will use on startup.
04043C             0377*  ; It is also the mode that the system will fall back to use if it was not possible to
04043C             0378*  ; change to the requested mode.
04043C             0379*  ; ** Mode 7 is the “Teletext” mode, and essentially works in a very similar manner to
04043C             0380*  ; the BBC Micro’s Teletext mode, which was also mode 7.
04043C             0381*  vdu_set_screen_mode:
04043C 32 4C 04 04 0382*  	ld (@arg),a
040440 21 4B 04 04 0383*  	ld hl,@cmd
040444 01 02 00 00 0384*  	ld bc,@end-@cmd
040448 5B DF       0385*  	rst.lil $18
04044A C9          0386*  	ret
04044B 16          0387*  @cmd: db 22 ; set screen mode
04044C 00          0388*  @arg: db 0  ; screen mode parameter
04044D             0389*  @end:
04044D             0390*  
04044D             0391*  ; VDU 23, n: Re-program display character / System Commands
04044D             0392*  ; inputs: a, ascii code; hl, pointer to bitmask data
04044D             0393*  vdu_define_character:
04044D 32 69 04 04 0394*  	ld (@ascii),a
040451 11 6A 04 04 0395*  	ld de,@data
040455 06 08       0396*  	ld b,8 ; loop counter for 8 bytes of data
040457             0397*  @loop:
040457 7E          0398*  	ld a,(hl)
040458 12          0399*  	ld (de),a
040459 23          0400*  	inc hl
04045A 13          0401*  	inc de
04045B 10 FA       0402*  	djnz @loop
04045D 21 68 04 04 0403*  	ld hl,@cmd
040461 01 0A 00 00 0404*  	ld bc,@end-@cmd
040465 5B DF       0405*  	rst.lil $18
040467 C9          0406*  	ret
040468 17          0407*  @cmd:   db 23
040469 00          0408*  @ascii: db 0
04046A             0409*  @data:  ds 8
040472             0410*  @end:
040472             0411*  
040472             0412*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
040472             0413*  ; NOTE: the order of the y-coordinate parameters are inverted
040472             0414*  ; 	because we have turned off logical screen scaling
040472             0415*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
040472             0416*  ; outputs; nothing
040472             0417*  ; destroys: a might make it out alive
040472             0418*  vdu_set_gfx_viewport:
040472 ED 43 92 04 0419*      ld (@x0),bc
       04          
040477 FD 22 94 04 0420*      ld (@y1),iy
       04          
04047C DD 22 96 04 0421*  	ld (@x1),ix
       04          
040481 ED 53 98 04 0422*  	ld (@y0),de
       04          
040486 21 91 04 04 0423*  	ld hl,@cmd
04048A 01 09 00 00 0424*  	ld bc,@end-@cmd
04048E 5B DF       0425*  	rst.lil $18
040490 C9          0426*  	ret
040491 18          0427*  @cmd:   db 24 ; set graphics viewport command
040492 00 00       0428*  @x0: 	dw 0x0000 ; set by bc
040494 00 00       0429*  @y1: 	dw 0x0000 ; set by iy
040496 00 00       0430*  @x1: 	dw 0x0000 ; set by ix
040498 00 00       0431*  @y0: 	dw 0x0000 ; set by de
04049A 00          0432*  @end:   db 0x00	  ; padding
04049B             0433*  
04049B             0434*  ; VDU 25, mode, x; y;: PLOT command
04049B             0435*  ; Implemented in vdu_plot.asm
04049B             0436*  
04049B             0437*  ; VDU 26: Reset graphics and text viewports **
04049B             0438*  vdu_reset_txt_gfx_view:
04049B 3E 1A       0439*      ld a,26
04049D 5B D7       0440*  	rst.lil $10
04049F C9          0441*  	ret
0404A0             0442*  
0404A0             0443*  ; PASSES
0404A0             0444*  ; VDU 27, char: Output character to screen §
0404A0             0445*  ; inputs: a is the ascii code of the character to draw
0404A0             0446*  vdu_draw_char:
0404A0 32 B0 04 04 0447*  	ld (@arg),a
0404A4 21 AF 04 04 0448*  	ld hl,@cmd
0404A8 01 02 00 00 0449*  	ld bc,@end-@cmd
0404AC 5B DF       0450*  	rst.lil $18
0404AE C9          0451*  	ret
0404AF 1B          0452*  @cmd: db 27
0404B0 00          0453*  @arg: db 0  ; ascii code of character to draw
0404B1             0454*  @end:
0404B1             0455*  
0404B1             0456*  ; VDU 28, left, bottom, right, top: Set text viewport **
0404B1             0457*  ; MIND THE LITTLE-ENDIANESS
0404B1             0458*  ; inputs: c=left,b=bottom,e=right,d=top
0404B1             0459*  ; outputs; nothing
0404B1             0460*  ; destroys: a might make it out alive
0404B1             0461*  vdu_set_txt_viewport:
0404B1 ED 43 C7 04 0462*      ld (@lb),bc
       04          
0404B6 ED 53 C9 04 0463*  	ld (@rt),de
       04          
0404BB 21 C6 04 04 0464*  	ld hl,@cmd
0404BF 01 05 00 00 0465*  	ld bc,@end-@cmd
0404C3 5B DF       0466*  	rst.lil $18
0404C5 C9          0467*  	ret
0404C6 1C          0468*  @cmd:   db 28 ; set text viewport command
0404C7 00 00       0469*  @lb: 	dw 0x0000 ; set by bc
0404C9 00 00       0470*  @rt: 	dw 0x0000 ; set by de
0404CB 00          0471*  @end:   db 0x00	  ; padding
0404CC             0472*  
0404CC             0473*  ; PASSES
0404CC             0474*  ; VDU 29, x; y;: Set graphics origin
0404CC             0475*  ; inputs: bc,de x,y coordinates
0404CC             0476*  vdu_set_gfx_origin:
0404CC ED 43 E2 04 0477*      ld (@x0),bc
       04          
0404D1 ED 53 E4 04 0478*      ld (@y0),de
       04          
0404D6 21 E1 04 04 0479*  	ld hl,@cmd
0404DA 01 05 00 00 0480*  	ld bc,@end-@cmd
0404DE 5B DF       0481*  	rst.lil $18
0404E0 C9          0482*  	ret
0404E1 1D          0483*  @cmd:	db 29
0404E2 00 00       0484*  @x0: 	dw 0
0404E4 00 00       0485*  @y0: 	dw 0
0404E6 00          0486*  @end: 	db 0 ; padding
0404E7             0487*  
0404E7             0488*  ; PASSES
0404E7             0489*  ; VDU 30: Home cursor
0404E7             0490*  vdu_home_cursor:
0404E7 3E 1E       0491*      ld a,30
0404E9 5B D7       0492*  	rst.lil $10
0404EB C9          0493*  	ret
0404EC             0494*  
0404EC             0495*  ; PASSES
0404EC             0496*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0404EC             0497*  ; inputs: c=x, b=y 8-bit unsigned integers
0404EC             0498*  vdu_move_cursor:
0404EC ED 43 FD 04 0499*      ld (@x0),bc
       04          
0404F1 21 FC 04 04 0500*  	ld hl,@cmd
0404F5 01 03 00 00 0501*  	ld bc,@end-@cmd
0404F9 5B DF       0502*  	rst.lil $18
0404FB C9          0503*  	ret
0404FC 1F          0504*  @cmd: 	db 31
0404FD 00          0505*  @x0:	db 0
0404FE 00          0506*  @y0: 	db 0
0404FF 00          0507*  @end: 	db 0 ; padding
040500             0508*  
040500             0509*  
040500             0510*  ; VDU 127: Backspace
040500             0511*  vdu_bksp:
040500 3E 7F       0512*      ld a,127
040502 5B D7       0513*  	rst.lil $10
040504 C9          0514*  	ret
040505             0515*  
040505             0516*  ; activate a bitmap in preparation to draw it
040505             0517*  ; inputs: a holding the bitmap index
040505             0518*  vdu_bmp_select:
040505 32 17 05 04 0519*  	ld (@bmp),a
040509 21 14 05 04 0520*  	ld hl,@cmd
04050D 01 04 00 00 0521*  	ld bc,@end-@cmd
040511 5B DF       0522*  	rst.lil $18
040513 C9          0523*  	ret
040514 17 1B 00    0524*  @cmd: db 23,27,0
040517 00          0525*  @bmp: db 0
040518             0526*  @end:
040518             0527*  
040518             0528*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
040518             0529*  ; inputs: hl=bufferId
040518             0530*  vdu_buff_select:
040518 22 2A 05 04 0531*  	ld (@bufferId),hl
04051C 21 27 05 04 0532*  	ld hl,@cmd
040520 01 05 00 00 0533*  	ld bc,@end-@cmd
040524 5B DF       0534*  	rst.lil $18
040526 C9          0535*  	ret
040527 17 1B 20    0536*  @cmd: db 23,27,0x20
04052A 00 00       0537*  @bufferId: dw 0x0000
04052C 00          0538*  @end: db 0x00 ; padding
04052D             0539*  
04052D             0540*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
04052D             0541*  ; inputs: a=format; bc=width; de=height
04052D             0542*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
04052D             0543*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
04052D             0544*  ; 0 	RGBA8888 (4-bytes per pixel)
04052D             0545*  ; 1 	RGBA2222 (1-bytes per pixel)
04052D             0546*  ; 2 	Mono/Mask (1-bit per pixel)
04052D             0547*  ; 3 	Reserved for internal use by VDP (“native” format)
04052D             0548*  vdu_bmp_create:
04052D ED 43 49 05 0549*      ld (@width),bc
       04          
040532 ED 53 4B 05 0550*      ld (@height),de
       04          
040537 32 4D 05 04 0551*      ld (@fmt),a
04053B 21 46 05 04 0552*  	ld hl,@cmd
04053F 01 08 00 00 0553*  	ld bc,@end-@cmd
040543 5B DF       0554*  	rst.lil $18
040545 C9          0555*  	ret
040546 17 1B 21    0556*  @cmd:       db 23,27,0x21
040549 00 00       0557*  @width:     dw 0x0000
04054B 00 00       0558*  @height:    dw 0x0000
04054D 00          0559*  @fmt:       db 0x00
04054E             0560*  @end:
04054E             0561*  
04054E             0562*  ; Draw a bitmap on the screen
04054E             0563*  ; inputs: bc, x-coordinate; de, y-coordinate
04054E             0564*  ; prerequisite: bitmap index set by e.g. vdu_bmp_select
04054E             0565*  vdu_bmp_draw:
04054E ED 43 66 05 0566*      ld (@x0),bc
       04          
040553 ED 53 68 05 0567*      ld (@y0),de
       04          
040558 21 63 05 04 0568*  	ld hl,@cmd
04055C 01 07 00 00 0569*  	ld bc,@end-@cmd
040560 5B DF       0570*  	rst.lil $18
040562 C9          0571*  	ret
040563 17 1B 03    0572*  @cmd: db 23,27,3
040566 00 00       0573*  @x0:  dw 0x0000
040568 00 00       0574*  @y0:  dw 0x0000
04056A 00          0575*  @end: db 0x00 ; padding
04056B             0576*  
04056B             0577*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
04056B             0578*  ; inputs: a is scaling mode, 1=on, 0=off
04056B             0579*  ; note: default setting on boot is scaling ON
04056B             0580*  vdu_set_scaling:
04056B 32 7D 05 04 0581*  	ld (@arg),a
04056F 21 7A 05 04 0582*  	ld hl,@cmd
040573 01 04 00 00 0583*  	ld bc,@end-@cmd
040577 5B DF       0584*  	rst.lil $18
040579 C9          0585*  	ret
04057A 17 00 C0    0586*  @cmd: db 23,0,0xC0
04057D 00          0587*  @arg: db 0  ; scaling on/off
04057E             0588*  @end:
04057E             0589*  
04057E             0590*  ; VDU 23, 0, &C3: Swap the screen buffer and/or wait for VSYNC **
04057E             0591*  ; 	Swap the screen buffer (double-buffered modes only) or wait for VSYNC
04057E             0592*  ; 	(all modes).
04057E             0593*  
04057E             0594*  ; 	This command will swap the screen buffer, if the current screen mode
04057E             0595*  ; 	is double-buffered, doing so at the next VSYNC. If the current screen
04057E             0596*  ; 	mode is not double-buffered then this command will wait for the next
04057E             0597*  ; 	VSYNC signal before returning. This can be used to synchronise the
04057E             0598*  ; 	screen with the vertical refresh rate of the monitor.
04057E             0599*  
04057E             0600*  ; 	Waiting for VSYNC can be useful for ensuring smooth graphical animation,
04057E             0601*  ; 	as it will prevent tearing of the screen.
04057E             0602*  ; inputs: none
04057E             0603*  ; outputs: none
04057E             0604*  ; destroys: hl, bc
04057E             0605*  vdu_flip:
04057E 21 89 05 04 0606*  	ld hl,@cmd
040582 01 03 00 00 0607*  	ld bc,@end-@cmd
040586 5B DF       0608*  	rst.lil $18
040588 C9          0609*  	ret
040589 17 00 C3    0610*  @cmd: db 23,0,0xC3
04058C             0611*  @end:
04058C             0612*  
04058C             0613*  ; Command 64: Compress a buffer
04058C             0614*  ; VDU 23, 0, &A0, targetBufferId; 64, sourceBufferId;
04058C             0615*  ; This command will compress the contents of a buffer, replacing the target buffer with the compressed data. Unless the target buffer is the same as the source, the source buffer will be left unchanged.
04058C             0616*  
04058C             0617*  
04058C             0618*  ; Command 65: Decompress a buffer
04058C             0619*  ; VDU 23, 0, &A0, targetBufferId; 65, sourceBufferId;
04058C             0620*  ; This command will decompress the contents of a buffer, replacing the target buffer with the decompressed data. Unless the target buffer is the same as the source, the source buffer will be left unchanged.
04058C             0621*  ; inputs: hl=sourceBufferId/targetBufferId
04058C             0622*  vdu_decompress_buffer:
04058C 22 A8 05 04 0623*  	ld (@targetBufferId),hl
040590 22 AB 05 04 0624*  	ld (@sourceBufferId),hl
040594 3E 41       0625*  	ld a,65
040596 32 AA 05 04 0626*  	ld (@cmd1),a ; restore the part of command that got stomped on
04059A 21 A5 05 04 0627*  	ld hl,@cmd
04059E 01 08 00 00 0628*  	ld bc,@end-@cmd
0405A2 5B DF       0629*  	rst.lil $18
0405A4 C9          0630*  	ret
0405A5 17 00 A0    0631*  @cmd: 	db 23,0,0xA0
0405A8 00 00       0632*  @targetBufferId: dw 0x0000
0405AA 41          0633*  @cmd1:	db 65
0405AB 00 00       0634*  @sourceBufferId: dw 0x0000
0405AD 00          0635*  @end: 	db 0x00 ; padding
0405AE             0636*  
0405AE             0637*  ; Command 65: Decompress a buffer
0405AE             0638*  ; VDU 23, 0, &A0, targetBufferId; 65, sourceBufferId;
0405AE             0639*  ; This command will decompress the contents of a buffer, replacing the target buffer with the decompressed data. Unless the target buffer is the same as the source, the source buffer will be left unchanged.
0405AE             0640*  ; inputs: hl=sourceBufferId/targetBufferId
0405AE             0641*  ; 0x7FFF for the source buffer is just an easy-to remember aribtrary value
0405AE             0642*  vdu_decompress_buffer_different:
0405AE 22 CE 05 04 0643*  	ld (@targetBufferId),hl
0405B2 21 FF 7F 00 0644*      ld hl,0x7FFF
0405B6 22 D1 05 04 0645*  	ld (@sourceBufferId),hl
0405BA 3E 41       0646*  	ld a,65
0405BC 32 D0 05 04 0647*  	ld (@cmd1),a ; restore the part of command that got stomped on
0405C0 21 CB 05 04 0648*  	ld hl,@cmd
0405C4 01 08 00 00 0649*  	ld bc,@end-@cmd
0405C8 5B DF       0650*  	rst.lil $18
0405CA C9          0651*  	ret
0405CB 17 00 A0    0652*  @cmd: 	db 23,0,0xA0
0405CE 00 00       0653*  @targetBufferId: dw 0x0000
0405D0 41          0654*  @cmd1:	db 65
0405D1 00 00       0655*  @sourceBufferId: dw 0x0000
0405D3 00          0656*  @end: 	db 0x00 ; padding
0405D4             0657*  
0405D4             0658*  ; #### from vdp.asm ####
0405D4             0659*  
0405D4             0660*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
0405D4             0661*  ; VDU 23, 7: Scrolling
0405D4             0662*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
0405D4             0663*  ; inputs: a, extent; l, direction; h; speed
0405D4             0664*  vdu_scroll_down:
0405D4 32 E9 05 04 0665*  	ld (@extent),a
0405D8 22 EA 05 04 0666*  	ld (@dir),hl ; implicitly populates @speed
0405DC 21 E7 05 04 0667*  	ld hl,@cmd
0405E0 01 05 00 00 0668*  	ld bc,@end-@cmd
0405E4 5B DF       0669*  	rst.lil $18     ;; Sending command to VDP
0405E6 C9          0670*  	ret
0405E7 17 07       0671*  @cmd:       db 23,7
0405E9 00          0672*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
0405EA 00          0673*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
0405EB 00          0674*  @speed:     db 0x00 ; pixels
0405EC 00          0675*  @end:		db 0x00 ; padding
0405ED             0676*  
0405ED             0677*  cursor_on:
0405ED 21 F8 05 04 0678*  	ld hl,@cmd
0405F1 01 03 00 00 0679*  	ld bc,@end-@cmd
0405F5 5B DF       0680*  	rst.lil $18
0405F7 C9          0681*  	ret
0405F8             0682*  @cmd:
0405F8 17 01 01    0683*  	db 23,1,1
0405FB             0684*  @end:
0405FB             0685*  
0405FB             0686*  cursor_off:
0405FB 21 06 06 04 0687*  	ld hl,@cmd
0405FF 01 03 00 00 0688*  	ld bc,@end-@cmd
040603 5B DF       0689*  	rst.lil $18
040605 C9          0690*  	ret
040606             0691*  @cmd:
040606 17 01 00    0692*  	db 23,1,0
040609             0693*  @end:
040609             0694*  
040609 DD E5       0695*  vdu_vblank:		PUSH 	IX			; Wait for VBLANK interrupt
04060B             0696*  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
04060B 3E 08       0001*M 			LD	A, function
04060D 5B CF       0002*M 			RST.LIL	08h
04060F DD 7E 00    0697*  			LD	A, (IX + sysvar_time + 0)
040612 DD BE 00    0698*  @wait:			CP 	A, (IX + sysvar_time + 0)
040615 28 FB       0699*  			JR	Z, @wait
040617 DD E1       0700*  			POP	IX
040619 C9          0701*  			RET
04061A             0702*  
04061A             0703*  ; #### from vdu_bmp.asm ####
04061A             0704*  ; =========================================================================
04061A             0705*  ; Bitmaps
04061A             0706*  ; -------------------------------------------------------------------------
04061A             0707*  ; VDU 23, 27, 0, n: Select bitmap n
04061A             0708*  ; VDU 23, 27, &20, bufferId;: Select bitmap using a 16-bit buffer ID *
04061A             0709*  ; VDU 23, 27, 1, w; h; b1, b2 ... bn: Load colour bitmap data into current bitmap
04061A             0710*  
04061A             0711*  ; VDU 23, 27, 1, n, 0, 0;: Capture screen data into bitmap n *
04061A             0712*  ; VDU 23, 27, &21, bitmapId; 0; : same, but to 16-bit buffer ID *
04061A             0713*  ; Any PLOT, or VDU 25, style command will push the graphics cursor position -
04061A             0714*  ; typically "move" style plot commands are used to define the rectangle.
04061A             0715*  ; To be clear, this command should be performed after two "move" style PLOT commands.
04061A             0716*  ; inputs: hl; target bufferId
04061A             0717*  ; all the following are in 16.8 fixed point format
04061A             0718*  ;   ub.c; top-left x coordinate
04061A             0719*  ;   ud.e; top-left y coordinate
04061A             0720*  ;   ui.x; width
04061A             0721*  ;   ui.y; height
04061A             0722*  vdu_buff_screen_capture168:
04061A ED 53 51 06 0723*          ld (@y0-1),de
       04          
04061F ED 43 4F 06 0724*          ld (@x0-1),bc
       04          
040624 3E 44       0725*          ld a,0x44 ; plot_pt+mv_abs
040626 32 4F 06 04 0726*          ld (@x0-1),a
04062A             0727*  
04062A DD 22 56 06 0728*          ld (@x1),ix
       04          
04062F FD 22 58 06 0729*          ld (@y1),iy
       04          
040634 3E 17       0730*          ld a,23
040636 32 5A 06 04 0731*          ld (@y1+2),a
04063A             0732*  
04063A 22 5D 06 04 0733*          ld (@bufId),hl
04063E AF          0734*          xor a
04063F 32 5F 06 04 0735*          ld (@bufId+2),a
040643             0736*  
040643 21 4E 06 04 0737*          ld hl,@begin
040647 01 13 00 00 0738*          ld bc,@end-@begin
04064B 5B DF       0739*          rst.lil $18
04064D C9          0740*          ret
04064E             0741*  @begin:
04064E             0742*  ; absolute move gfx cursor to top-left screen coordinate
04064E             0743*  ; VDU 25, mode, x; y;: PLOT command
04064E 19 44       0744*          db 25,0x44 ; plot_pt+mv_abs
040650 40 00       0745*  @x0: 	dw 64
040652 40 00       0746*  @y0: 	dw 64
040654             0747*  ; relative move gfx cursor to bottom-right screen coordinate
040654             0748*  ; VDU 25, mode, x; y;: PLOT command
040654 19 40       0749*          db 25,0x40 ; plot_pt+mv_rel
040656 0F 00       0750*  @x1: 	dw 15
040658 0F 00       0751*  @y1: 	dw 15
04065A             0752*  ; now the main event
04065A             0753*  ; VDU 23, 27, &21, bitmapId; 0;
04065A 17 1B 21    0754*          db 23,27,0x21
04065D 00 20 00 00 0755*  @bufId: dw 0x2000,0x0000
040661             0756*  @end: ; no padding required
040661             0757*  
040661             0758*  vdu_buff_screen_capture_full:
040661 21 6C 06 04 0759*          ld hl,@begin
040665 01 13 00 00 0760*          ld bc,@end-@begin
040669 5B DF       0761*          rst.lil $18
04066B C9          0762*          ret
04066C             0763*  @begin:
04066C             0764*  ; absolute move gfx cursor to top-left screen coordinate
04066C             0765*  ; VDU 25, mode, x; y;: PLOT command
04066C 19 44       0766*          db 25,0x44 ; plot_pt+mv_abs
04066E 00 00       0767*  @x0: 	dw 0
040670 00 00       0768*  @y0: 	dw 0
040672             0769*  ; relative move gfx cursor to bottom-right screen coordinate
040672             0770*  ; VDU 25, mode, x; y;: PLOT command
040672 19 40       0771*          db 25,0x40 ; plot_pt+mv_rel
040674 3F 01       0772*  @x1: 	dw 319
040676 EF 00       0773*  @y1: 	dw 239
040678             0774*  ; now the main event
040678             0775*  ; VDU 23, 27, &21, bitmapId; 0;
040678 17 1B 21    0776*          db 23,27,0x21
04067B 00 20 00 00 0777*  @bufId: dw 0x2000,0x0000
04067F             0778*  @end: ; no padding required
04067F             0779*  
04067F             0780*  vdu_buff_screen_paste_full:
04067F 21 8A 06 04 0781*          ld hl,@begin
040683 01 0B 00 00 0782*          ld bc,@end-@begin
040687 5B DF       0783*          rst.lil $18
040689 C9          0784*          ret
04068A             0785*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
04068A 17 1B 20    0786*  @begin:    db 23,27,0x20
04068D 00 20       0787*  @bufferId: dw 0x2000
04068F             0788*  ; VDU 25, mode, x; y;: PLOT command
04068F 19 ED       0789*             db 25,0xED ; plot_bmp+dr_abs_fg
040691 00 00 00 00 0790*             dw 0x0000,0x0000
040695             0791*  @end: ; no padding required
040695             0792*  
040695             0793*  vdu_buff_screen_capture_tiles:
040695 21 A0 06 04 0794*          ld hl,@begin
040699 01 13 00 00 0795*          ld bc,@end-@begin
04069D 5B DF       0796*          rst.lil $18
04069F C9          0797*          ret
0406A0             0798*  @begin:
0406A0             0799*  ; absolute move gfx cursor to top-left screen coordinate
0406A0             0800*  ; VDU 25, mode, x; y;: PLOT command
0406A0 19 44       0801*          db 25,0x44 ; plot_pt+mv_abs
0406A2 00 00       0802*  @x0: 	dw 0
0406A4 00 00       0803*  @y0: 	dw 0
0406A6             0804*  ; relative move gfx cursor to bottom-right screen coordinate
0406A6             0805*  ; VDU 25, mode, x; y;: PLOT command
0406A6 19 40       0806*          db 25,0x40 ; plot_pt+mv_rel
0406A8 FF 00       0807*  @x1: 	dw 319-64
0406AA EF 00       0808*  @y1: 	dw 239
0406AC             0809*  ; now the main event
0406AC             0810*  ; VDU 23, 27, &21, bitmapId; 0;
0406AC 17 1B 21    0811*          db 23,27,0x21
0406AF 00 20 00 00 0812*  @bufId: dw 0x2000,0x0000
0406B3             0813*  @end: ; no padding required
0406B3             0814*  
0406B3             0815*  vdu_buff_screen_paste_tiles:
0406B3 21 BE 06 04 0816*          ld hl,@begin
0406B7 01 0B 00 00 0817*          ld bc,@end-@begin
0406BB 5B DF       0818*          rst.lil $18
0406BD C9          0819*          ret
0406BE             0820*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0406BE 17 1B 20    0821*  @begin:    db 23,27,0x20
0406C1 00 20       0822*  @bufferId: dw 0x2000
0406C3             0823*  ; VDU 25, mode, x; y;: PLOT command
0406C3 19 ED       0824*             db 25,0xED ; plot_bmp+dr_abs_fg
0406C5 00 00 01 00 0825*             dw 0x0000,0x0001
0406C9             0826*  @end: ; no padding required
0406C9             0827*  
0406C9             0828*  ; VDU 23, 27, 2, w; h; col1; col2;: Create a solid colour rectangular bitmap
0406C9             0829*  ; VDU 23, 27, 3, x; y;: Draw current bitmap on screen at pixel position x, y
0406C9             0830*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer *
0406C9             0831*  ; Value	Meaning
0406C9             0832*  ; 0	RGBA8888 (4-bytes per pixel)
0406C9             0833*  ; 1	RGBA2222 (1-bytes per pixel)
0406C9             0834*  ; 2	Mono/Mask (1-bit per pixel)
0406C9             0835*  ; 3	Reserved for internal use by VDP ("native" format)VDP.
0406C9             0836*  ;     They have some significant limitations, and are not intended for general use.
0406C9             0837*  
0406C9             0838*  ; =========================================================================
0406C9             0839*  ; Sprites
0406C9             0840*  ; -------------------------------------------------------------------------
0406C9             0841*  ; VDU 23, 27, 4, n: Select sprite n
0406C9             0842*  ; VDU 23, 27, 5: Clear frames in current sprite
0406C9             0843*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
0406C9             0844*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
0406C9             0845*  ; VDU 23, 27, 7, n: Activate n sprites
0406C9             0846*  ; VDU 23, 27, 8: Select next frame of current sprite
0406C9             0847*  ; VDU 23, 27, 9: Select previous frame of current sprite
0406C9             0848*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
0406C9             0849*  ; VDU 23, 27, 11: Show current sprite
0406C9             0850*  ; VDU 23, 27, 12: Hide current sprite
0406C9             0851*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
0406C9             0852*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
0406C9             0853*  ; VDU 23, 27, 15: Update the sprites in the GPU
0406C9             0854*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
0406C9             0855*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
0406C9             0856*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
0406C9             0857*  
0406C9             0858*  ; =========================================================================
0406C9             0859*  ; Mouse cursor
0406C9             0860*  ; -------------------------------------------------------------------------
0406C9             0861*  ; VDU 23, 27, &40, hotX, hotY: Setup a mouse cursor with a hot spot at hotX, hotY
0406C9             0862*  
0406C9             0863*  ; #### from vdu_plot.asm ####
0406C9             0864*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0406C9             0865*  ; PLOT code 	(Decimal) 	Effect
0406C9             0866*  ; &00-&07 	0-7 	Solid line, includes both ends
0406C9             0867*  plot_sl_both: equ 0x00
0406C9             0868*  
0406C9             0869*  ; &08-&0F 	8-15 	Solid line, final point omitted
0406C9             0870*  plot_sl_first: equ 0x08
0406C9             0871*  
0406C9             0872*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0406C9             0873*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0406C9             0874*  
0406C9             0875*  ; &20-&27 	32-39 	Solid line, first point omitted
0406C9             0876*  plot_sl_last: equ 0x20
0406C9             0877*  
0406C9             0878*  ; &28-&2F 	40-47 	Solid line, both points omitted
0406C9             0879*  plot_sl_none: equ 0x28
0406C9             0880*  
0406C9             0881*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0406C9             0882*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0406C9             0883*  
0406C9             0884*  ; &40-&47 	64-71 	Point plot
0406C9             0885*  plot_pt: equ 0x40
0406C9             0886*  
0406C9             0887*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
0406C9             0888*  plot_lf_lr_non_bg: equ 0x48
0406C9             0889*  
0406C9             0890*  ; &50-&57 	80-87 	Triangle fill
0406C9             0891*  plot_tf: equ 0x50
0406C9             0892*  
0406C9             0893*  ; &58-&5F 	88-95 	Line fill right to background §§
0406C9             0894*  plot_lf_r_bg: equ 0x58
0406C9             0895*  
0406C9             0896*  ; &60-&67 	96-103 	Rectangle fill
0406C9             0897*  plot_rf: equ 0x60
0406C9             0898*  
0406C9             0899*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
0406C9             0900*  plot_lf_lr_fg: equ 0x60
0406C9             0901*  
0406C9             0902*  ; &70-&77 	112-119 	Parallelogram fill
0406C9             0903*  plot_pf: equ 0x70
0406C9             0904*  
0406C9             0905*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
0406C9             0906*  plot_lf_r_non_fg: equ 0x78
0406C9             0907*  
0406C9             0908*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
0406C9             0909*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0406C9             0910*  
0406C9             0911*  ; &90-&97 	144-151 	Circle outline
0406C9             0912*  plot_co: equ 0x90
0406C9             0913*  
0406C9             0914*  ; &98-&9F 	152-159 	Circle fill
0406C9             0915*  plot_cf: equ 0x98
0406C9             0916*  
0406C9             0917*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
0406C9             0918*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
0406C9             0919*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
0406C9             0920*  
0406C9             0921*  ; &B8-&BF 	184-191 	Rectangle copy/move
0406C9             0922*  plot_rcm: equ 0xB8
0406C9             0923*  
0406C9             0924*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0406C9             0925*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0406C9             0926*  ; &D0-&D7 	208-215 	Not defined
0406C9             0927*  ; &D8-&DF 	216-223 	Not defined
0406C9             0928*  ; &E0-&E7 	224-231 	Not defined
0406C9             0929*  
0406C9             0930*  ; &E8-&EF 	232-239 	Bitmap plot §
0406C9             0931*  plot_bmp: equ 0xE8
0406C9             0932*  
0406C9             0933*  ; &F0-&F7 	240-247 	Not defined
0406C9             0934*  ; &F8-&FF 	248-255 	Not defined
0406C9             0935*  
0406C9             0936*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
0406C9             0937*  ; Agon Console8 VDP 2.2.0
0406C9             0938*  
0406C9             0939*  ; Within each group of eight plot codes, the effects are as follows:
0406C9             0940*  ; Plot code 	Effect
0406C9             0941*  ; 0 	Move relative
0406C9             0942*  mv_rel: equ 0
0406C9             0943*  
0406C9             0944*  ; 1 	Plot relative in current foreground colour
0406C9             0945*  dr_rel_fg: equ 1
0406C9             0946*  
0406C9             0947*  ; 2 	Not supported (Plot relative in logical inverse colour)
0406C9             0948*  ; 3 	Plot relative in current background colour
0406C9             0949*  dr_rel_bg: equ 3
0406C9             0950*  
0406C9             0951*  ; 4 	Move absolute
0406C9             0952*  mv_abs: equ 4
0406C9             0953*  
0406C9             0954*  ; 5 	Plot absolute in current foreground colour
0406C9             0955*  dr_abs_fg: equ 5
0406C9             0956*  
0406C9             0957*  ; 6 	Not supported (Plot absolute in logical inverse colour)
0406C9             0958*  ; 7 	Plot absolute in current background colour
0406C9             0959*  dr_abs_bg: equ 7
0406C9             0960*  
0406C9             0961*  ; Codes 0-3 use the position data provided as part of the command
0406C9             0962*  ; as a relative position, adding the position given to the current
0406C9             0963*  ; graphical cursor position. Codes 4-7 use the position data provided
0406C9             0964*  ; as part of the command as an absolute position, setting the current
0406C9             0965*  ; graphical cursor position to the position given.
0406C9             0966*  
0406C9             0967*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0406C9             0968*  ; current pixel colour. These operations cannot currently be supported
0406C9             0969*  ; by the graphics system the Agon VDP uses, so these codes are not
0406C9             0970*  ; supported. Support for these codes may be added in a future version
0406C9             0971*  ; of the VDP firmware.
0406C9             0972*  
0406C9             0973*  ; 16 colour palette constants
0406C9             0974*  c_black: equ 0
0406C9             0975*  c_red_dk: equ 1
0406C9             0976*  c_green_dk: equ 2
0406C9             0977*  c_yellow_dk: equ 3
0406C9             0978*  c_blue_dk: equ 4
0406C9             0979*  c_magenta_dk: equ 5
0406C9             0980*  c_cyan_dk: equ 6
0406C9             0981*  c_grey: equ 7
0406C9             0982*  c_grey_dk: equ 8
0406C9             0983*  c_red: equ 9
0406C9             0984*  c_green: equ 10
0406C9             0985*  c_yellow: equ 11
0406C9             0986*  c_blue: equ 12
0406C9             0987*  c_magenta: equ 13
0406C9             0988*  c_cyan: equ 14
0406C9             0989*  c_white: equ 15
0406C9             0990*  
0406C9             0991*  ; VDU 25, mode, x; y;: PLOT command
0406C9             0992*  ; inputs: a=mode, bc=x0, de=y0
0406C9             0993*  vdu_plot:
0406C9 32 E3 06 04 0994*      ld (@mode),a
0406CD ED 43 E4 06 0995*      ld (@x0),bc
       04          
0406D2 ED 53 E6 06 0996*      ld (@y0),de
       04          
0406D7 21 E2 06 04 0997*  	ld hl,@cmd
0406DB 01 06 00 00 0998*  	ld bc,@end-@cmd
0406DF 5B DF       0999*  	rst.lil $18
0406E1 C9          1000*  	ret
0406E2 19          1001*  @cmd:   db 25
0406E3 00          1002*  @mode:  db 0
0406E4 00 00       1003*  @x0: 	dw 0
0406E6 00 00       1004*  @y0: 	dw 0
0406E8 00          1005*  @end:   db 0 ; extra byte to soak up deu
0406E9             1006*  
0406E9             1007*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0406E9             1008*  ; &E8-&EF 	232-239 	Bitmap plot §
0406E9             1009*  ; VDU 25, mode, x; y;: PLOT command
0406E9             1010*  ; inputs: bc=x0, de=y0
0406E9             1011*  ; prerequisites: vdu_buff_select
0406E9             1012*  vdu_plot_bmp:
0406E9 ED 43 00 07 1013*      ld (@x0),bc
       04          
0406EE ED 53 02 07 1014*      ld (@y0),de
       04          
0406F3 21 FE 06 04 1015*  	ld hl,@cmd
0406F7 01 06 00 00 1016*  	ld bc,@end-@cmd
0406FB 5B DF       1017*  	rst.lil $18
0406FD C9          1018*  	ret
0406FE 19          1019*  @cmd:   db 25
0406FF ED          1020*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
040700 00 00       1021*  @x0: 	dw 0x0000
040702 00 00       1022*  @y0: 	dw 0x0000
040704 00          1023*  @end:   db 0x00 ; padding
040705             1024*  
040705             1025*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
040705             1026*  ; &E8-&EF 	232-239 	Bitmap plot §
040705             1027*  ; VDU 25, mode, x; y;: PLOT command
040705             1028*  ; inputs: bc=x0, de=y0
040705             1029*  ; USING 16.8 FIXED POINT COORDINATES
040705             1030*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
040705             1031*  ;   the fractional portiion of the inputs are truncated
040705             1032*  ;   leaving only the 16-bit integer portion
040705             1033*  ; prerequisites: vdu_buff_select
040705             1034*  vdu_plot_bmp168:
040705             1035*  ; populate in the reverse of normal to keep the
040705             1036*  ; inputs from stomping on each other
040705 ED 53 23 07 1037*      ld (@y0-1),de
       04          
04070A ED 43 21 07 1038*      ld (@x0-1),bc
       04          
04070F 3E ED       1039*      ld a,plot_bmp+dr_abs_fg ; 0xED
040711 32 21 07 04 1040*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
040715 21 20 07 04 1041*  	ld hl,@cmd
040719 01 06 00 00 1042*  	ld bc,@end-@cmd
04071D 5B DF       1043*  	rst.lil $18
04071F C9          1044*  	ret
040720 19          1045*  @cmd:   db 25
040721 ED          1046*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
040722 00 00       1047*  @x0: 	dw 0x0000
040724 00 00       1048*  @y0: 	dw 0x0000
040726             1049*  @end:  ; no padding required b/c we shifted de right
040726             1050*  
040726             1051*  ; draw a filled rectangle
040726             1052*  vdu_plot_rf:
040726 ED 43 4D 07 1053*      ld (@x0),bc
       04          
04072B ED 53 4F 07 1054*      ld (@y0),de
       04          
040730 DD 22 53 07 1055*      ld (@x1),ix
       04          
040735 FD 22 55 07 1056*      ld (@y1),iy
       04          
04073A 3E 19       1057*      ld a,25 ; we have to reload the 2nd plot command
04073C 32 51 07 04 1058*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
040740 21 4B 07 04 1059*  	ld hl,@cmd0
040744 01 0C 00 00 1060*  	ld bc,@end-@cmd0
040748 5B DF       1061*  	rst.lil $18
04074A C9          1062*      ret
04074B 19          1063*  @cmd0:  db 25 ; plot
04074C 04          1064*  @arg0:  db plot_sl_both+mv_abs
04074D 00 00       1065*  @x0:    dw 0x0000
04074F 00 00       1066*  @y0:    dw 0x0000
040751 19          1067*  @cmd1:  db 25 ; plot
040752 65          1068*  @arg1:  db plot_rf+dr_abs_fg
040753 00 00       1069*  @x1:    dw 0x0000
040755 00 00       1070*  @y1:    dw 0x0000
040757 00          1071*  @end:   db 0x00 ; padding
040758             1072*  
040758             1073*  ; draw a filled circle
040758             1074*  vdu_plot_cf:
040758 ED 43 7F 07 1075*      ld (@x0),bc
       04          
04075D ED 53 81 07 1076*      ld (@y0),de
       04          
040762 DD 22 85 07 1077*      ld (@x1),ix
       04          
040767 FD 22 87 07 1078*      ld (@y1),iy
       04          
04076C 3E 19       1079*      ld a,25 ; we have to reload the 2nd plot command
04076E 32 83 07 04 1080*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
040772 21 7D 07 04 1081*  	ld hl,@cmd0
040776 01 0C 00 00 1082*  	ld bc,@end-@cmd0
04077A 5B DF       1083*  	rst.lil $18
04077C C9          1084*      ret
04077D 19          1085*  @cmd0:  db 25 ; plot
04077E 04          1086*  @arg0:  db plot_sl_both+mv_abs
04077F 00 00       1087*  @x0:    dw 0x0000
040781 00 00       1088*  @y0:    dw 0x0000
040783 19          1089*  @cmd1:  db 25 ; plot
040784 9D          1090*  @arg1:  db plot_cf+dr_abs_fg
040785 00 00       1091*  @x1:    dw 0x0000
040787 00 00       1092*  @y1:    dw 0x0000
040789 00          1093*  @end:   db 0x00 ; padding
04078A             1094*  
04078A             1095*  ; #### from vdu_sprites.asm ####
04078A             1096*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
04078A             1097*  ; the VDP can support up to 256 sprites. They must be defined
04078A             1098*  ; contiguously, and so the first sprite is sprite 0.
04078A             1099*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
04078A             1100*  ; Once a selection of sprites have been defined, you can activate
04078A             1101*  ; them using the VDU 23, 27, 7, n command, where n is the number
04078A             1102*  ; of sprites to activate. This will activate the first n sprites,
04078A             1103*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
04078A             1104*  
04078A             1105*  ; A single sprite can have multiple "frames", referring to
04078A             1106*  ; different bitmaps.
04078A             1107*  ; (These bitmaps do not need to be the same size.)
04078A             1108*  ; This allows a sprite to include an animation sequence,
04078A             1109*  ; which can be stepped through one frame at a time, or picked
04078A             1110*  ; in any order.
04078A             1111*  
04078A             1112*  ; Any format of bitmap can be used as a sprite frame. It should
04078A             1113*  ; be noted however that "native" format bitmaps are not
04078A             1114*  ; recommended for use as sprite frames, as they cannot get
04078A             1115*  ; erased from the screen. (As noted above, the "native" bitmap
04078A             1116*  ; format is not really intended for general use.) This is part
04078A             1117*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
04078A             1118*  ; screen are now stored in RGBA2222 format.
04078A             1119*  
04078A             1120*  ; An "active" sprite can be hidden, so it will stop being drawn,
04078A             1121*  ; and then later shown again.
04078A             1122*  
04078A             1123*  ; Moving sprites around the screen is done by changing the
04078A             1124*  ; position of the sprite. This can be done either by setting
04078A             1125*  ; the absolute position of the sprite, or by moving the sprite
04078A             1126*  ; by a given number of pixels. (Sprites are positioned using
04078A             1127*  ; pixel coordinates, and not by the logical OS coordinate system.)
04078A             1128*  ; In the current sprite system, sprites will not update their
04078A             1129*  ; position on-screen until either another drawing operation is
04078A             1130*  ; performed or an explicit VDU 23, 27, 15 command is performed.
04078A             1131*  
04078A             1132*  ; Here are the sprite commands:
04078A             1133*  ;
04078A             1134*  ; VDU 23, 27, 4,  n: Select sprite n
04078A             1135*  ; inputs: a is the 8-bit sprite id
04078A             1136*  ; vdu_sprite_select:
04078A             1137*  
04078A             1138*  ; VDU 23, 27, 5:  Clear frames in current sprite
04078A             1139*  ; inputs: none
04078A             1140*  ; prerequisites: vdu_sprite_select
04078A             1141*  ; vdu_sprite_clear_frames:
04078A             1142*  
04078A             1143*  ; VDU 23, 27, 6,  n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
04078A             1144*  ; inputs: a is the 8-bit bitmap number
04078A             1145*  ; prerequisites: vdu_sprite_select
04078A             1146*  ; vdu_sprite_add_bmp:
04078A             1147*  
04078A             1148*  ; VDU 23, 27, 7,  n: Activate n sprites
04078A             1149*  ; inputs: a is the number of sprites to activate
04078A             1150*  ; vdu_sprite_activate:
04078A             1151*  
04078A             1152*  ; VDU 23, 27, 8:  Select next frame of current sprite
04078A             1153*  ; inputs: none
04078A             1154*  ; prerequisites: vdu_sprite_select
04078A             1155*  ; vdu_sprite_next_frame:
04078A             1156*  
04078A             1157*  ; VDU 23, 27, 9:  Select previous frame of current sprite
04078A             1158*  ; inputs: none
04078A             1159*  ; prerequisites: vdu_sprite_select
04078A             1160*  ; vdu_sprite_prev_frame:
04078A             1161*  
04078A             1162*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
04078A             1163*  ; inputs: a is frame number to select
04078A             1164*  ; prerequisites: vdu_sprite_select
04078A             1165*  ; vdu_sprite_select_frame:
04078A             1166*  
04078A             1167*  ; VDU 23, 27, 11: Show current sprite
04078A             1168*  ; inputs: none
04078A             1169*  ; prerequisites: vdu_sprite_select
04078A             1170*  ; vdu_sprite_show:
04078A             1171*  
04078A             1172*  ; VDU 23, 27, 12: Hide current sprite
04078A             1173*  ; inputs: none
04078A             1174*  ; prerequisites: vdu_sprite_select
04078A             1175*  ; vdu_sprite_hide:
04078A             1176*  
04078A             1177*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
04078A             1178*  ; inputs: bc is x coordinate, de is y coordinate
04078A             1179*  ; prerequisites: vdu_sprite_select
04078A             1180*  ; vdu_sprite_move_abs:
04078A             1181*  ;
04078A             1182*  ; USING 16.8 FIXED POINT COORDINATES
04078A             1183*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
04078A             1184*  ;   the fractional portiion of the inputs are truncated
04078A             1185*  ;   leaving only the 16-bit integer portion
04078A             1186*  ; prerequisites: vdu_sprite_select
04078A             1187*  ; vdu_sprite_move_abs168:
04078A             1188*  
04078A             1189*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
04078A             1190*  ; inputs: bc is x coordinate, de is y coordinate
04078A             1191*  ; prerequisites: vdu_sprite_select
04078A             1192*  ; vdu_sprite_move_rel:
04078A             1193*  ;
04078A             1194*  ; USING 16.8 FIXED POINT COORDINATES
04078A             1195*  ; inputs: ub.c is dx, ud.e is dy
04078A             1196*  ;   the fractional portiion of the inputs are truncated
04078A             1197*  ;   leaving only the 16-bit integer portion
04078A             1198*  ; prerequisites: vdu_sprite_select
04078A             1199*  ; vdu_sprite_move_rel168:
04078A             1200*  
04078A             1201*  ; VDU 23, 27, 15: Update the sprites in the GPU
04078A             1202*  ; inputs: none
04078A             1203*  ; vdu_sprite_update:
04078A             1204*  
04078A             1205*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
04078A             1206*  ; inputs: none
04078A             1207*  ; vdu_sprite_bmp_reset:
04078A             1208*  
04078A             1209*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
04078A             1210*  ; inputs: none
04078A             1211*  ; vdu_sprite_reset:
04078A             1212*  
04078A             1213*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
04078A             1214*  ; inputs: a is the GCOL paint mode
04078A             1215*  ; prerequisites: vdu_sprite_select
04078A             1216*  ; vdu_sprite_set_gcol:
04078A             1217*  
04078A             1218*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
04078A             1219*  ; inputs: hl=bufferId
04078A             1220*  ; prerequisites: vdu_sprite_select
04078A             1221*  ; vdu_sprite_add_buff:
04078A             1222*  
04078A             1223*  @dummy_label: ; dummy label to serve as a break from the above comments and the below code
04078A             1224*  
04078A             1225*  ; VDU 23, 27, 4, n: Select sprite n
04078A             1226*  ; inputs: a is the 8-bit sprite id
04078A             1227*  vdu_sprite_select:
04078A 32 9C 07 04 1228*      ld (@sprite),a
04078E 21 99 07 04 1229*      ld hl,@cmd
040792 01 04 00 00 1230*      ld bc,@end-@cmd
040796 5B DF       1231*      rst.lil $18
040798 C9          1232*      ret
040799 17 1B 04    1233*  @cmd:    db 23,27,4
04079C 00          1234*  @sprite: db 0x00
04079D             1235*  @end:
04079D             1236*  
04079D             1237*  ; VDU 23, 27, 5: Clear frames in current sprite
04079D             1238*  ; inputs: none
04079D             1239*  ; prerequisites: vdu_sprite_select
04079D             1240*  vdu_sprite_clear_frames:
04079D 21 A8 07 04 1241*      ld hl,@cmd
0407A1 01 03 00 00 1242*      ld bc,@end-@cmd
0407A5 5B DF       1243*      rst.lil $18
0407A7 C9          1244*      ret
0407A8 17 1B 05    1245*  @cmd: db 23,27,5
0407AB             1246*  @end:
0407AB             1247*  
0407AB             1248*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
0407AB             1249*  ; inputs: a is the 8-bit bitmap number
0407AB             1250*  ; prerequisites: vdu_sprite_select
0407AB             1251*  vdu_sprite_add_bmp:
0407AB 32 BD 07 04 1252*      ld (@bmp),a
0407AF 21 BA 07 04 1253*      ld hl,@cmd
0407B3 01 04 00 00 1254*      ld bc,@end-@cmd
0407B7 5B DF       1255*      rst.lil $18
0407B9 C9          1256*      ret
0407BA 17 1B 06    1257*  @cmd: db 23,27,6
0407BD 00          1258*  @bmp: db 0x00
0407BE             1259*  @end:
0407BE             1260*  
0407BE             1261*  ; VDU 23, 27, 7, n: Activate n sprites
0407BE             1262*  ; inputs: a is the number of sprites to activate
0407BE             1263*  vdu_sprite_activate:
0407BE 32 D0 07 04 1264*      ld (@num),a
0407C2 21 CD 07 04 1265*      ld hl,@cmd
0407C6 01 04 00 00 1266*      ld bc,@end-@cmd
0407CA 5B DF       1267*      rst.lil $18
0407CC C9          1268*      ret
0407CD 17 1B 07    1269*  @cmd: db 23,27,7
0407D0 00          1270*  @num: db 0x00
0407D1             1271*  @end:
0407D1             1272*  
0407D1             1273*  ; VDU 23, 27, 8: Select next frame of current sprite
0407D1             1274*  ; inputs: none
0407D1             1275*  ; prerequisites: vdu_sprite_select
0407D1             1276*  vdu_sprite_next_frame:
0407D1 21 DC 07 04 1277*      ld hl,@cmd
0407D5 01 03 00 00 1278*      ld bc,@end-@cmd
0407D9 5B DF       1279*      rst.lil $18
0407DB C9          1280*      ret
0407DC 17 1B 08    1281*  @cmd: db 23,27,8
0407DF             1282*  @end:
0407DF             1283*  
0407DF             1284*  ; VDU 23, 27, 9: Select previous frame of current sprite
0407DF             1285*  ; inputs: none
0407DF             1286*  ; prerequisites: vdu_sprite_select
0407DF             1287*  vdu_sprite_prev_frame:
0407DF 21 EA 07 04 1288*      ld hl,@cmd
0407E3 01 03 00 00 1289*      ld bc,@end-@cmd
0407E7 5B DF       1290*      rst.lil $18
0407E9 C9          1291*      ret
0407EA 17 1B 09    1292*  @cmd: db 23,27,9
0407ED             1293*  @end:
0407ED             1294*  
0407ED             1295*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
0407ED             1296*  ; inputs: a is frame number to select
0407ED             1297*  ; prerequisites: vdu_sprite_select
0407ED             1298*  vdu_sprite_select_frame:
0407ED 32 FF 07 04 1299*      ld (@frame),a
0407F1 21 FC 07 04 1300*      ld hl,@cmd
0407F5 01 04 00 00 1301*      ld bc,@end-@cmd
0407F9 5B DF       1302*      rst.lil $18
0407FB C9          1303*      ret
0407FC 17 1B 0A    1304*  @cmd:    db 23,27,10
0407FF 00          1305*  @frame:  db 0x00
040800             1306*  @end:
040800             1307*  
040800             1308*  ; VDU 23, 27, 11: Show current sprite
040800             1309*  ; inputs: none
040800             1310*  ; prerequisites: vdu_sprite_select
040800             1311*  vdu_sprite_show:
040800 21 0B 08 04 1312*      ld hl,@cmd
040804 01 03 00 00 1313*      ld bc,@end-@cmd
040808 5B DF       1314*      rst.lil $18
04080A C9          1315*      ret
04080B 17 1B 0B    1316*  @cmd: db 23,27,11
04080E             1317*  @end:
04080E             1318*  
04080E             1319*  ; VDU 23, 27, 12: Hide current sprite
04080E             1320*  ; inputs: none
04080E             1321*  ; prerequisites: vdu_sprite_select
04080E             1322*  vdu_sprite_hide:
04080E 21 19 08 04 1323*      ld hl,@cmd
040812 01 03 00 00 1324*      ld bc,@end-@cmd
040816 5B DF       1325*      rst.lil $18
040818 C9          1326*      ret
040819 17 1B 0C    1327*  @cmd: db 23,27,12
04081C             1328*  @end:
04081C             1329*  
04081C             1330*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
04081C             1331*  ; inputs: bc is x coordinate, de is y coordinate
04081C             1332*  ; prerequisites: vdu_sprite_select
04081C             1333*  vdu_sprite_move_abs:
04081C ED 43 34 08 1334*      ld (@xpos),bc
       04          
040821 ED 53 36 08 1335*      ld (@ypos),de
       04          
040826 21 31 08 04 1336*      ld hl,@cmd
04082A 01 07 00 00 1337*      ld bc,@end-@cmd
04082E 5B DF       1338*      rst.lil $18
040830 C9          1339*      ret
040831 17 1B 0D    1340*  @cmd:  db 23,27,13
040834 00 00       1341*  @xpos: dw 0x0000
040836 00 00       1342*  @ypos: dw 0x0000
040838 00          1343*  @end:  db 0x00 ; padding
040839             1344*  
040839             1345*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
040839             1346*  ; inputs: bc is x coordinate, de is y coordinate
040839             1347*  ; prerequisites: vdu_sprite_select
040839             1348*  vdu_sprite_move_rel:
040839 ED 43 51 08 1349*      ld (@dx),bc
       04          
04083E ED 53 53 08 1350*      ld (@dy),de
       04          
040843 21 4E 08 04 1351*      ld hl,@cmd
040847 01 07 00 00 1352*      ld bc,@end-@cmd
04084B 5B DF       1353*      rst.lil $18
04084D C9          1354*      ret
04084E 17 1B 0E    1355*  @cmd: db 23,27,14
040851 00 00       1356*  @dx:  dw 0x0000
040853 00 00       1357*  @dy:  dw 0x0000
040855 00          1358*  @end: db 0x00 ; padding
040856             1359*  
040856             1360*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
040856             1361*  ; USING 16.8 FIXED POINT COORDINATES
040856             1362*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
040856             1363*  ;   the fractional portiion of the inputs are truncated
040856             1364*  ;   leaving only the 16-bit integer portion
040856             1365*  ; prerequisites: vdu_sprite_select
040856             1366*  vdu_sprite_move_abs168:
040856             1367*  ; populate in the reverse of normal to keep the
040856             1368*  ; inputs from stomping on each other
040856 ED 53 75 08 1369*      ld (@ypos-1),de
       04          
04085B ED 43 73 08 1370*      ld (@xpos-1),bc
       04          
040860 3E 0D       1371*      ld a,13       ; restore the final byte of the command
040862 32 73 08 04 1372*      ld (@cmd+2),a ; string that got stomped on by bcu
040866 21 71 08 04 1373*      ld hl,@cmd
04086A 01 07 00 00 1374*      ld bc,@end-@cmd
04086E 5B DF       1375*      rst.lil $18
040870 C9          1376*      ret
040871 17 1B 0D    1377*  @cmd:  db 23,27,13
040874 00 00       1378*  @xpos: dw 0x0000
040876 00 00       1379*  @ypos: dw 0x0000
040878             1380*  @end:  ; no padding required b/c we shifted de right
040878             1381*  
040878             1382*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
040878             1383*  ; USING 16.8 FIXED POINT COORDINATES
040878             1384*  ; inputs: ub.c is dx, ud.e is dy
040878             1385*  ;   the fractional portiion of the inputs are truncated
040878             1386*  ;   leaving only the 16-bit integer portion
040878             1387*  ; prerequisites: vdu_sprite_select
040878             1388*  vdu_sprite_move_rel168:
040878             1389*  ; populate in the reverse of normal to keep the
040878             1390*  ; inputs from stomping on each other
040878 ED 53 97 08 1391*      ld (@dy-1),de
       04          
04087D ED 43 95 08 1392*      ld (@dx-1),bc
       04          
040882 3E 0E       1393*      ld a,14       ; restore the final byte of the command
040884 32 95 08 04 1394*      ld (@cmd+2),a ; string that got stomped on by bcu
040888 21 93 08 04 1395*      ld hl,@cmd
04088C 01 07 00 00 1396*      ld bc,@end-@cmd
040890 5B DF       1397*      rst.lil $18
040892 C9          1398*      ret
040893 17 1B 0E    1399*  @cmd:  db 23,27,14
040896 00 00       1400*  @dx: dw 0x0000
040898 00 00       1401*  @dy: dw 0x0000
04089A             1402*  @end:  ; no padding required b/c we shifted de right
04089A             1403*  
04089A             1404*  ; VDU 23, 27, 15: Update the sprites in the GPU
04089A             1405*  ; inputs: none
04089A             1406*  vdu_sprite_update:
04089A 21 A5 08 04 1407*      ld hl,@cmd
04089E 01 03 00 00 1408*      ld bc,@end-@cmd
0408A2 5B DF       1409*      rst.lil $18
0408A4 C9          1410*      ret
0408A5 17 1B 0F    1411*  @cmd: db 23,27,15
0408A8             1412*  @end:
0408A8             1413*  
0408A8             1414*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
0408A8             1415*  ; inputs: none
0408A8             1416*  vdu_sprite_bmp_reset:
0408A8 21 B3 08 04 1417*      ld hl,@cmd
0408AC 01 03 00 00 1418*      ld bc,@end-@cmd
0408B0 5B DF       1419*      rst.lil $18
0408B2 C9          1420*      ret
0408B3 17 1B 10    1421*  @cmd: db 23,27,16
0408B6             1422*  @end:
0408B6             1423*  
0408B6             1424*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
0408B6             1425*  ; inputs: none
0408B6             1426*  vdu_sprite_reset:
0408B6 21 C1 08 04 1427*      ld hl,@cmd
0408BA 01 03 00 00 1428*      ld bc,@end-@cmd
0408BE 5B DF       1429*      rst.lil $18
0408C0 C9          1430*      ret
0408C1 17 1B 11    1431*  @cmd: db 23,27,17
0408C4             1432*  @end:
0408C4             1433*  
0408C4             1434*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
0408C4             1435*  ; inputs: a is the GCOL paint mode
0408C4             1436*  ; prerequisites: vdu_sprite_select
0408C4             1437*  vdu_sprite_set_gcol:
0408C4 32 D6 08 04 1438*      ld (@mode),a
0408C8 21 D3 08 04 1439*      ld hl,@cmd
0408CC 01 04 00 00 1440*      ld bc,@end-@cmd
0408D0 5B DF       1441*      rst.lil $18
0408D2 C9          1442*      ret
0408D3 17 1B 12    1443*  @cmd:  db 23,27,18
0408D6 00          1444*  @mode: db 0x00
0408D7             1445*  @end:
0408D7             1446*  
0408D7             1447*  ; VDU 23, 27, &26, n;: Add bitmap bufferId
0408D7             1448*  ;     as a frame to current sprite using a 16-bit buffer ID
0408D7             1449*  ; inputs: hl=bufferId
0408D7             1450*  ; prerequisites: vdu_sprite_select
0408D7             1451*  vdu_sprite_add_buff:
0408D7 22 E9 08 04 1452*      ld (@bufferId),hl
0408DB 21 E6 08 04 1453*      ld hl,@cmd
0408DF 01 05 00 00 1454*      ld bc,@end-@cmd
0408E3 5B DF       1455*      rst.lil $18
0408E5 C9          1456*      ret
0408E6 17 1B 26    1457*  @cmd:      db 23,27,0x26
0408E9 00 00       1458*  @bufferId: dw 0x0000
0408EB 00          1459*  @end:      db 0x00 ; padding
0408EC             1460*  
0408EC             1461*  
0408EC             1462*  ; #### from sfx.asm ####
0408EC 00          1463*  sfx_last_channel: db 0x00 ; 8-bit value between 0 and 31
0408ED             1464*  
0408ED             1465*  vdu_clear_all_buffers:
0408ED             1466*  ; clear all buffers
0408ED 21 F8 08 04 1467*      ld hl,@beg
0408F1 01 06 00 00 1468*      ld bc,@end-@beg
0408F5 5B DF       1469*      rst.lil $18
0408F7 C9          1470*      ret
0408F8 17 00 A0    1471*  @beg: db 23,0,$A0
0408FB FF FF       1472*        dw -1 ; clear all buffers
0408FD 02          1473*        db 2  ; command 2: clear a buffer
0408FE             1474*  @end:
0408FE             0331       include "pingo/src/asm/vdu_pingo.asm"
0408FE             0001*  ; Create Control Structure
0408FE             0002*  ; VDU 23, 0, &A0, sid; &49, 0, w; h; : Create Control Structure
0408FE             0003*  ; This command initializes a control structure used to do 3D rendering. The structure is housed inside the designated buffer. The buffer referred to by the scene ID (sid) is created, if it does not already exist.
0408FE             0004*  ; The given width and height determine the size of the final rendered scene.
0408FE             0005*  ; inputs: bc = w; de = h;
0408FE             0006*  vdu_3d_crt_ctl_str:
0408FE ED 43 1A 09 0007*      ld (@w),bc
       04          
040903 ED 53 1C 09 0008*      ld (@h),de
       04          
040908 21 13 09 04 0009*      ld hl,@beg
04090C 01 0B 00 00 0010*      ld bc,@end-@beg
040910 5B DF       0011*      rst.lil $18
040912 C9          0012*      ret
040913 17 00 A0    0013*  @beg: db 23, 0, $A0
040916 64 00       0014*  @sid: dw sid
040918 49 00       0015*  @cmd: db $49, 0 ; command 0: create control structure
04091A 00 00       0016*  @w:   dw 0x0000
04091C 00 00       0017*  @h:   dw 0x0000
04091E 00          0018*  @end: db 0x00 ; padding
04091F             0019*  
04091F             0020*  ; Define Mesh Vertices
04091F             0021*  ; VDU 23, 0, &A0, sid; &49, 1, mid; n; x0; y0; z0; ... : Define Mesh Vertices
04091F             0022*  ; This command establishes the list of mesh coordinates to be used to define a surface structure. The mesh may be referenced by multiple objects.
04091F             0023*  ; The "n" parameter is the number of vertices, so the total number of coordinates specified equals n*3.
04091F             0024*  ; inputs: hl = mid; bc = n; de = pointer to list of coordinates
04091F             0025*  vdu_3d_def_msh_verts:
04091F C5          0026*      push bc ; save n
040920 22 45 09 04 0027*      ld (@mid),hl
040924 ED 43 2D 0E 0028*      ld (@n),bc
       04          
040929 21 3E 09 04 0029*      ld hl,@beg
04092D 01 0B 00 00 0030*      ld bc,@end-@beg
040931 5B DF       0031*      rst.lil $18
040933 E1          0032*      pop hl ; restore n
040934 E5          0033*      push hl ; save n
040935 29          0034*      add hl,hl ; n*2
040936 C1          0035*      pop bc ; restore n
040937 09          0036*      add hl,bc ; n*2+n = n*3 = total number of bytes in list of coordinates
040938 44          0037*      ld b,h
040939 4D          0038*      ld c,l ; bc = number of bytes
04093A EB          0039*      ex de,hl ; hl is pointer to list of coordinates
04093B 5B DF       0040*      rst.lil $18
04093D C9          0041*      ret
04093E 17 00 A0    0042*  @beg: db 23, 0, $A0
040941 64 00       0043*  @sid: dw sid
040943 49 01       0044*  @cmd: db $49, 1 ; command 1: define mesh vertices
040945 00 00       0045*  @mid: dw 0x0000
040947 00 00       0046*  @n:   dw 0x0000
040949 00          0047*  @end: db 0x00 ; padding
04094A             0048*  
04094A             0049*  ; Set Mesh Vertex Indexes
04094A             0050*  ; VDU 23, 0, &A0, sid; &49, 2, mid; n; i0; ... : Set Mesh Vertex Indexes
04094A             0051*  ; This command lists the indexes of the vertices that define a 3D mesh.
04094A             0052*  ; Individual vertices are often referenced multiple times within a mesh, because they are often part of multiple surface triangles.
04094A             0053*  ; Each index value ranges from 0 to the number of defined mesh vertices.
04094A             0054*  ; The "n" parameter is the number of indexes, and must match the "n" in subcommand 4 (Set Texture Coordinate Indexes).
04094A             0055*  ; inputs: hl = mid; bc = n; de = pointer to list of indexes
04094A             0056*  vdu_3d_set_msh_vert_idxs:
04094A C5          0057*      push bc ; save n
04094B 22 6A 09 04 0058*      ld (@mid),hl
04094F ED 43 2D 0E 0059*      ld (@n),bc
       04          
040954 21 63 09 04 0060*      ld hl,@beg
040958 01 0B 00 00 0061*      ld bc,@end-@beg
04095C 5B DF       0062*      rst.lil $18
04095E C1          0063*      pop bc ; restore n
04095F EB          0064*      ex de,hl ; hl is pointer to list of indexes
040960 5B DF       0065*      rst.lil $18
040962 C9          0066*      ret
040963 17 00 A0    0067*  @beg: db 23, 0, $A0
040966 64 00       0068*  @sid: dw sid
040968 49 02       0069*  @cmd: db $49, 2 ; command 2: set mesh vertex indexes
04096A 00 00       0070*  @mid: dw 0x0000
04096C 00 00       0071*  @n:   dw 0x0000
04096E 00          0072*  @end: db 0x00 ; padding
04096F             0073*  
04096F             0074*  ; Define Texture Coordinates
04096F             0075*  ; VDU 23, 0, &A0, sid; &49, 3, mid; n; u0; v0; ... : Define Texture Coordinates
04096F             0076*  ; This command establishes the list of U/V texture coordinates that define texturing for a mesh.
04096F             0077*  ; The "n" parameter is the number of coordinate pairs, so the total number of coordinates specified equals n*2.
04096F             0078*  ; inputs: hl = mid; bc = n; de = pointer to list of coordinates
04096F             0079*  vdu_3d_def_tex_coords:
04096F C5          0080*      push bc ; save n
040970 22 92 09 04 0081*      ld (@mid),hl
040974 ED 43 2D 0E 0082*      ld (@n),bc
       04          
040979 21 8B 09 04 0083*      ld hl,@beg
04097D 01 0B 00 00 0084*      ld bc,@end-@beg
040981 5B DF       0085*      rst.lil $18
040983 E1          0086*      pop hl ; restore n
040984 29          0087*      add hl,hl ; n*2
040985 44          0088*      ld b,h
040986 4D          0089*      ld c,l ; bc = number of bytes
040987 EB          0090*      ex de,hl ; hl is pointer to list of coordinates
040988 5B DF       0091*      rst.lil $18
04098A C9          0092*      ret
04098B 17 00 A0    0093*  @beg: db 23, 0, $A0
04098E 64 00       0094*  @sid: dw sid
040990 49 03       0095*  @cmd: db $49, 3 ; command 3: define texture coordinates
040992 00 00       0096*  @mid: dw 0x0000
040994 00 00       0097*  @n:   dw 0x0000
040996 00          0098*  @end: db 0x00 ; padding
040997             0099*  
040997             0100*  ; Set Texture Coordinate Indexes
040997             0101*  ; VDU 23, 0, &A0, sid; &49, 4, mid; n; i0; ... : Set Texture Coordinate Indexes
040997             0102*  ; This command lists the indexes of the coordinates that define a 3D texture for a mesh. Individual coordinates may be referenced multiple times within a texture, but that is not required.
040997             0103*  ; The number of indexes passed in this command must match the number of mesh indexes defining the mesh.
040997             0104*  ; Thus, each mesh vertex has texture coordinates associated with it.
040997             0105*  ; The "n" parameter is the number of indexes, and must match the "n" in subcommand 2 (Set Mesh Vertex Indexes).
040997             0106*  ; inputs: hl = mid; bc = n; de = pointer to list of indexes
040997             0107*  vdu_3d_set_tex_coord_idxs:
040997 C5          0108*      push bc ; save n
040998 22 B7 09 04 0109*      ld (@mid),hl
04099C ED 43 2D 0E 0110*      ld (@n),bc
       04          
0409A1 21 B0 09 04 0111*      ld hl,@beg
0409A5 01 0B 00 00 0112*      ld bc,@end-@beg
0409A9 5B DF       0113*      rst.lil $18
0409AB C1          0114*      pop bc ; restore n
0409AC EB          0115*      ex de,hl ; hl is pointer to list of indexes
0409AD 5B DF       0116*      rst.lil $18
0409AF C9          0117*      ret
0409B0 17 00 A0    0118*  @beg: db 23, 0, $A0
0409B3 64 00       0119*  @sid: dw sid
0409B5 49 04       0120*  @cmd: db $49, 4 ; command 4: set texture coordinate indexes
0409B7 00 00       0121*  @mid: dw 0x0000
0409B9 00 00       0122*  @n:   dw 0x0000
0409BB 00          0123*  @end: db 0x00 ; padding
0409BC             0124*  
0409BC             0125*  ; Define Object
0409BC             0126*  ; VDU 23, 0, &A0, sid; &49, 5, oid; mid; bmid; : Create Object
0409BC             0127*  ; This command defines a renderable object in terms of its already-defined mesh, plus a reference to an existing bitmap that provides its coloring, via the texture coordinates used by the mesh.
0409BC             0128*  ; The same mesh can be used multiple times, with the same or different bitmaps for coloring. The bitmap must be in the RGBA8888 format (4 bytes per pixel).
0409BC             0129*  ; inputs: hl = oid; de = mid; bc = bmid;
0409BC             0130*  vdu_3d_def_obj:
0409BC 22 DC 09 04 0131*      ld (@oid),hl
0409C0 ED 53 DE 09 0132*      ld (@mid),de
       04          
0409C5 ED 43 E0 09 0133*      ld (@bmid),bc
       04          
0409CA 21 D5 09 04 0134*      ld hl,@beg
0409CE 01 0D 00 00 0135*      ld bc,@end-@beg
0409D2 5B DF       0136*      rst.lil $18
0409D4 C9          0137*      ret
0409D5 17 00 A0    0138*  @beg: db 23, 0, $A0
0409D8 64 00       0139*  @sid: dw sid
0409DA 49 05       0140*  @cmd: db $49, 5 ; command 5: define object
0409DC 00 00       0141*  @oid: dw 0x0000
0409DE 00 00       0142*  @mid: dw 0x0000
0409E0 00 00       0143*  @bmid: dw 0x0000
0409E2 00          0144*  @end: db 0x00 ; padding
0409E3             0145*  
0409E3             0146*  ; Set Object X Scale Factor
0409E3             0147*  ; VDU 23, 0, &A0, sid; &49, 6, oid; scalex; : Set Object X Scale Factor
0409E3             0148*  ; This command sets the X scale factor for an object.
0409E3             0149*  ; inputs: hl = oid; bc = scalex;
0409E3             0150*  vdu_3d_set_obj_x_scl:
0409E3 22 FE 09 04 0151*      ld (@oid),hl
0409E7 ED 43 00 0A 0152*      ld (@scalex),bc
       04          
0409EC 21 F7 09 04 0153*      ld hl,@beg
0409F0 01 0B 00 00 0154*      ld bc,@end-@beg
0409F4 5B DF       0155*      rst.lil $18
0409F6 C9          0156*      ret
0409F7 17 00 A0    0157*  @beg: db 23, 0, $A0
0409FA 64 00       0158*  @sid: dw sid
0409FC 49 06       0159*  @cmd: db $49, 6 ; command 6: set object x scale factor
0409FE 00 00       0160*  @oid: dw 0x0000
040A00 00 00       0161*  @scalex: dw 0x0000
040A02 00          0162*  @end: db 0x00 ; padding
040A03             0163*  
040A03             0164*  ; Set Object Y Scale Factor
040A03             0165*  ; VDU 23, 0, &A0, sid; &49, 7, oid; scaley; : Set Object Y Scale Factor
040A03             0166*  ; This command sets the Y scale factor for an object.
040A03             0167*  ; inputs: hl = oid; bc = scaley;
040A03             0168*  vdu_3d_set_obj_y_scl:
040A03 22 1E 0A 04 0169*      ld (@oid),hl
040A07 ED 43 20 0A 0170*      ld (@scaley),bc
       04          
040A0C 21 17 0A 04 0171*      ld hl,@beg
040A10 01 0B 00 00 0172*      ld bc,@end-@beg
040A14 5B DF       0173*      rst.lil $18
040A16 C9          0174*      ret
040A17 17 00 A0    0175*  @beg: db 23, 0, $A0
040A1A 64 00       0176*  @sid: dw sid
040A1C 49 07       0177*  @cmd: db $49, 7 ; command 7: set object y scale factor
040A1E 00 00       0178*  @oid: dw 0x0000
040A20 00 00       0179*  @scaley: dw 0x0000
040A22 00          0180*  @end: db 0x00 ; padding
040A23             0181*  
040A23             0182*  ; Set Object Z Scale Factor
040A23             0183*  ; VDU 23, 0, &A0, sid; &49, 8, oid; scalez; : Set Object Z Scale Factor
040A23             0184*  ; This command sets the Z scale factor for an object.
040A23             0185*  ; inputs: hl = oid; bc = scalez;
040A23             0186*  vdu_3d_set_obj_z_scl:
040A23 22 3E 0A 04 0187*      ld (@oid),hl
040A27 ED 43 40 0A 0188*      ld (@scalez),bc
       04          
040A2C 21 37 0A 04 0189*      ld hl,@beg
040A30 01 0B 00 00 0190*      ld bc,@end-@beg
040A34 5B DF       0191*      rst.lil $18
040A36 C9          0192*      ret
040A37 17 00 A0    0193*  @beg: db 23, 0, $A0
040A3A 64 00       0194*  @sid: dw sid
040A3C 49 08       0195*  @cmd: db $49, 8 ; command 8: set object z scale factor
040A3E 00 00       0196*  @oid: dw 0x0000
040A40 00 00       0197*  @scalez: dw 0x0000
040A42 00          0198*  @end: db 0x00 ; padding
040A43             0199*  
040A43             0200*  ; Set Object XYZ Scale Factors
040A43             0201*  ; VDU 23, 0, &A0, sid; &49, 9, oid; scalex; scaley; scalez; : Set Object XYZ Scale Factors
040A43             0202*  ; This command sets the X, Y, and Z scale factors for an object.
040A43             0203*  ; inputs: hl = oid; ix = scalex; iy = scaley; bc = scalez;
040A43             0204*  vdu_3d_set_obj_xyz_scl:
040A43 22 68 0A 04 0205*      ld (@oid),hl
040A47 DD 22 6A 0A 0206*      ld (@scalex),ix
       04          
040A4C FD 22 6C 0A 0207*      ld (@scaley),iy
       04          
040A51 ED 43 6E 0A 0208*      ld (@scalez),bc
       04          
040A56 21 61 0A 04 0209*      ld hl,@beg
040A5A 01 0F 00 00 0210*      ld bc,@end-@beg
040A5E 5B DF       0211*      rst.lil $18
040A60 C9          0212*      ret
040A61 17 00 A0    0213*  @beg: db 23, 0, $A0
040A64 64 00       0214*  @sid: dw sid
040A66 49 09       0215*  @cmd: db $49, 9 ; command 9: set object xyz scale factors
040A68 00 00       0216*  @oid: dw 0x0000
040A6A 00 00       0217*  @scalex: dw 0x0000
040A6C 00 00       0218*  @scaley: dw 0x0000
040A6E 00 00       0219*  @scalez: dw 0x0000
040A70 00          0220*  @end: db 0x00 ; padding
040A71             0221*  
040A71             0222*  ; Set Object X Rotation Angle
040A71             0223*  ; VDU 23, 0, &A0, sid; &49, 10, oid; anglex; : Set Object X Rotation Angle
040A71             0224*  ; This command sets the X rotation angle for an object.
040A71             0225*  ; inputs: hl = oid; bc = anglex;
040A71             0226*  vdu_3d_set_obj_x_rot:
040A71 22 8C 0A 04 0227*      ld (@oid),hl
040A75 ED 43 8E 0A 0228*      ld (@anglex),bc
       04          
040A7A 21 85 0A 04 0229*      ld hl,@beg
040A7E 01 0B 00 00 0230*      ld bc,@end-@beg
040A82 5B DF       0231*      rst.lil $18
040A84 C9          0232*      ret
040A85 17 00 A0    0233*  @beg: db 23, 0, $A0
040A88 64 00       0234*  @sid: dw sid
040A8A 49 0A       0235*  @cmd: db $49, 10 ; command 10: set object x rotation angle
040A8C 00 00       0236*  @oid: dw 0x0000
040A8E 00 00       0237*  @anglex: dw 0x0000
040A90 00          0238*  @end: db 0x00 ; padding
040A91             0239*  
040A91             0240*  ; Set Object Y Rotation Angle
040A91             0241*  ; VDU 23, 0, &A0, sid; &49, 11, oid; angley; : Set Object Y Rotation Angle
040A91             0242*  ; This command sets the Y rotation angle for an object.
040A91             0243*  ; inputs: hl = oid; bc = angley;
040A91             0244*  vdu_3d_set_obj_y_rot:
040A91 22 AC 0A 04 0245*      ld (@oid),hl
040A95 ED 43 AE 0A 0246*      ld (@angley),bc
       04          
040A9A 21 A5 0A 04 0247*      ld hl,@beg
040A9E 01 0B 00 00 0248*      ld bc,@end-@beg
040AA2 5B DF       0249*      rst.lil $18
040AA4 C9          0250*      ret
040AA5 17 00 A0    0251*  @beg: db 23, 0, $A0
040AA8 64 00       0252*  @sid: dw sid
040AAA 49 0B       0253*  @cmd: db $49, 11 ; command 11: set object y rotation angle
040AAC 00 00       0254*  @oid: dw 0x0000
040AAE 00 00       0255*  @angley: dw 0x0000
040AB0 00          0256*  @end: db 0x00 ; padding
040AB1             0257*  
040AB1             0258*  ; Set Object Z Rotation Angle
040AB1             0259*  ; VDU 23, 0, &A0, sid; &49, 12, oid; anglez; : Set Object Z Rotation Angle
040AB1             0260*  ; This command sets the Z rotation angle for an object.
040AB1             0261*  ; inputs: hl = oid; bc = anglez;
040AB1             0262*  vdu_3d_set_obj_z_rot:
040AB1 22 CC 0A 04 0263*      ld (@oid),hl
040AB5 ED 43 CE 0A 0264*      ld (@anglez),bc
       04          
040ABA 21 C5 0A 04 0265*      ld hl,@beg
040ABE 01 0B 00 00 0266*      ld bc,@end-@beg
040AC2 5B DF       0267*      rst.lil $18
040AC4 C9          0268*      ret
040AC5 17 00 A0    0269*  @beg: db 23, 0, $A0
040AC8 64 00       0270*  @sid: dw sid
040ACA 49 0C       0271*  @cmd: db $49, 12 ; command 12: set object z rotation angle
040ACC 00 00       0272*  @oid: dw 0x0000
040ACE 00 00       0273*  @anglez: dw 0x0000
040AD0 00          0274*  @end: db 0x00 ; padding
040AD1             0275*  
040AD1             0276*  ; Set Object XYZ Rotation Angles
040AD1             0277*  ; VDU 23, 0, &A0, sid; &49, 13, oid; anglex; angley; anglez; : Set Object XYZ Rotation Angles
040AD1             0278*  ; This command sets the X, Y, and Z rotation angles for an object.
040AD1             0279*  ; inputs: hl = oid; ix = anglex; iy = angley; bc = anglez;
040AD1             0280*  vdu_3d_set_obj_xyz_rot:
040AD1 22 F6 0A 04 0281*      ld (@oid),hl
040AD5 DD 22 F8 0A 0282*      ld (@anglex),ix
       04          
040ADA FD 22 FA 0A 0283*      ld (@angley),iy
       04          
040ADF ED 43 FC 0A 0284*      ld (@anglez),bc
       04          
040AE4 21 EF 0A 04 0285*      ld hl,@beg
040AE8 01 0F 00 00 0286*      ld bc,@end-@beg
040AEC 5B DF       0287*      rst.lil $18
040AEE C9          0288*      ret
040AEF 17 00 A0    0289*  @beg: db 23, 0, $A0
040AF2 64 00       0290*  @sid: dw sid
040AF4 49 0D       0291*  @cmd: db $49, 13 ; command 13: set object xyz rotation angles
040AF6 00 00       0292*  @oid: dw 0x0000
040AF8 00 00       0293*  @anglex: dw 0x0000
040AFA 00 00       0294*  @angley: dw 0x0000
040AFC 00 00       0295*  @anglez: dw 0x0000
040AFE 00          0296*  @end: db 0x00 ; padding
040AFF             0297*  
040AFF             0298*  ; Set Object X Translation Distance
040AFF             0299*  ; VDU 23, 0, &A0, sid; &49, 14, oid; distx; : Set Object X Translation Distance
040AFF             0300*  ; This command sets the X translation distance for an object. Note that 3D translation of an object is independent of 2D translation of the the rendered bitmap.
040AFF             0301*  ; inputs: hl = oid; bc = distx;
040AFF             0302*  vdu_3d_set_obj_x_trans:
040AFF 22 1A 0B 04 0303*      ld (@oid),hl
040B03 ED 43 1C 0B 0304*      ld (@distx),bc
       04          
040B08 21 13 0B 04 0305*      ld hl,@beg
040B0C 01 0B 00 00 0306*      ld bc,@end-@beg
040B10 5B DF       0307*      rst.lil $18
040B12 C9          0308*      ret
040B13 17 00 A0    0309*  @beg: db 23, 0, $A0
040B16 64 00       0310*  @sid: dw sid
040B18 49 0E       0311*  @cmd: db $49, 14 ; command 14: set object x translation distance
040B1A 00 00       0312*  @oid: dw 0x0000
040B1C 00 00       0313*  @distx: dw 0x0000
040B1E 00          0314*  @end: db 0x00 ; padding
040B1F             0315*  
040B1F             0316*  ; Set Object Y Translation Distance
040B1F             0317*  ; VDU 23, 0, &A0, sid; &49, 15, oid; disty; : Set Object Y Translation Distance
040B1F             0318*  ; This command sets the Y translation distance for an object. Note that 3D translation of an object is independent of 2D translation of the the rendered bitmap.
040B1F             0319*  ; inputs: hl = oid; bc = disty;
040B1F             0320*  vdu_3d_set_obj_y_trans:
040B1F 22 3A 0B 04 0321*      ld (@oid),hl
040B23 ED 43 3C 0B 0322*      ld (@disty),bc
       04          
040B28 21 33 0B 04 0323*      ld hl,@beg
040B2C 01 0B 00 00 0324*      ld bc,@end-@beg
040B30 5B DF       0325*      rst.lil $18
040B32 C9          0326*      ret
040B33 17 00 A0    0327*  @beg: db 23, 0, $A0
040B36 64 00       0328*  @sid: dw sid
040B38 49 0F       0329*  @cmd: db $49, 15 ; command 15: set object y translation distance
040B3A 00 00       0330*  @oid: dw 0x0000
040B3C 00 00       0331*  @disty: dw 0x0000
040B3E 00          0332*  @end: db 0x00 ; padding
040B3F             0333*  
040B3F             0334*  ; Set Object Z Translation Distance
040B3F             0335*  ; VDU 23, 0, &A0, sid; &49, 16, oid; distz; : Set Object Z Translation Distance
040B3F             0336*  ; This command sets the Z translation distance for an object. Note that 3D translation of an object is independent of 2D translation of the the rendered bitmap.
040B3F             0337*  ; inputs: hl = oid; bc = distz;
040B3F             0338*  vdu_3d_set_obj_z_trans:
040B3F 22 5A 0B 04 0339*      ld (@oid),hl
040B43 ED 43 5C 0B 0340*      ld (@distz),bc
       04          
040B48 21 53 0B 04 0341*      ld hl,@beg
040B4C 01 0B 00 00 0342*      ld bc,@end-@beg
040B50 5B DF       0343*      rst.lil $18
040B52 C9          0344*      ret
040B53 17 00 A0    0345*  @beg: db 23, 0, $A0
040B56 64 00       0346*  @sid: dw sid
040B58 49 10       0347*  @cmd: db $49, 16 ; command 16: set object z translation distance
040B5A 00 00       0348*  @oid: dw 0x0000
040B5C 00 00       0349*  @distz: dw 0x0000
040B5E 00          0350*  @end: db 0x00 ; padding
040B5F             0351*  
040B5F             0352*  ; Set Object XYZ Translation Distances
040B5F             0353*  ; VDU 23, 0, &A0, sid; &49, 17, oid; distx; disty; distz; : Set Object XYZ Translation Distances
040B5F             0354*  ; This command sets the X, Y, and Z translation distances for an object. Note that 3D translation of an object is independent of 2D translation of the the rendered bitmap.
040B5F             0355*  ; inputs: hl = oid; ix = distx; iy = disty; bc = distz;
040B5F             0356*  vdu_3d_set_obj_xyz_trans:
040B5F 22 84 0B 04 0357*      ld (@oid),hl
040B63 DD 22 86 0B 0358*      ld (@distx),ix
       04          
040B68 FD 22 88 0B 0359*      ld (@disty),iy
       04          
040B6D ED 43 8A 0B 0360*      ld (@distz),bc
       04          
040B72 21 7D 0B 04 0361*      ld hl,@beg
040B76 01 0F 00 00 0362*      ld bc,@end-@beg
040B7A 5B DF       0363*      rst.lil $18
040B7C C9          0364*      ret
040B7D 17 00 A0    0365*  @beg: db 23, 0, $A0
040B80 64 00       0366*  @sid: dw sid
040B82 49 11       0367*  @cmd: db $49, 17 ; command 17: set object xyz translation distances
040B84 00 00       0368*  @oid: dw 0x0000
040B86 00 00       0369*  @distx: dw 0x0000
040B88 00 00       0370*  @disty: dw 0x0000
040B8A 00 00       0371*  @distz: dw 0x0000
040B8C 00          0372*  @end: db 0x00 ; padding
040B8D             0373*  
040B8D             0374*  ; Set Camera X Rotation Angle
040B8D             0375*  ; VDU 23, 0, &A0, sid; &49, 18, anglex; : Set Camera X Rotation Angle
040B8D             0376*  ; This command sets the X rotation angle for the camera.
040B8D             0377*  ; inputs: hl = anglex;
040B8D             0378*  vdu_3d_set_cam_x_rot:
040B8D 22 A3 0B 04 0379*      ld (@anglex),hl
040B91 21 9C 0B 04 0380*      ld hl,@beg
040B95 01 09 00 00 0381*      ld bc,@end-@beg
040B99 5B DF       0382*      rst.lil $18
040B9B C9          0383*      ret
040B9C 17 00 A0    0384*  @beg: db 23, 0, $A0
040B9F 64 00       0385*  @sid: dw sid
040BA1 49 12       0386*  @cmd: db $49, 18 ; command 18: set camera x rotation angle
040BA3 00 00       0387*  @anglex: dw 0x0000
040BA5 00          0388*  @end: db 0x00 ; padding
040BA6             0389*  
040BA6             0390*  ; Set Camera Y Rotation Angle
040BA6             0391*  ; VDU 23, 0, &A0, sid; &49, 19, angley; : Set Camera Y Rotation Angle
040BA6             0392*  ; This command sets the Y rotation angle for the camera.
040BA6             0393*  ; inputs: hl = angley;
040BA6             0394*  vdu_3d_set_cam_y_rot:
040BA6 22 BC 0B 04 0395*      ld (@angley),hl
040BAA 21 B5 0B 04 0396*      ld hl,@beg
040BAE 01 09 00 00 0397*      ld bc,@end-@beg
040BB2 5B DF       0398*      rst.lil $18
040BB4 C9          0399*      ret
040BB5 17 00 A0    0400*  @beg: db 23, 0, $A0
040BB8 64 00       0401*  @sid: dw sid
040BBA 49 13       0402*  @cmd: db $49, 19 ; command 19: set camera y rotation angle
040BBC 00 00       0403*  @angley: dw 0x0000
040BBE 00          0404*  @end: db 0x00 ; padding
040BBF             0405*  
040BBF             0406*  ; Set Camera Z Rotation Angle
040BBF             0407*  ; VDU 23, 0, &A0, sid; &49, 20, anglez; : Set Camera Z Rotation Angle
040BBF             0408*  ; This command sets the Z rotation angle for the camera.
040BBF             0409*  ; inputs: hl = anglez;
040BBF             0410*  vdu_3d_set_cam_z_rot:
040BBF 22 D5 0B 04 0411*      ld (@anglez),hl
040BC3 21 CE 0B 04 0412*      ld hl,@beg
040BC7 01 09 00 00 0413*      ld bc,@end-@beg
040BCB 5B DF       0414*      rst.lil $18
040BCD C9          0415*      ret
040BCE 17 00 A0    0416*  @beg: db 23, 0, $A0
040BD1 64 00       0417*  @sid: dw sid
040BD3 49 14       0418*  @cmd: db $49, 20 ; command 20: set camera z rotation angle
040BD5 00 00       0419*  @anglez: dw 0x0000
040BD7 00          0420*  @end: db 0x00 ; padding
040BD8             0421*  
040BD8             0422*  ; Set Camera XYZ Rotation Angles
040BD8             0423*  ; VDU 23, 0, &A0, sid; &49, 21, anglex; angley; anglez; : Set Camera XYZ Rotation Angles
040BD8             0424*  ; This command sets the X, Y, and Z rotation angles for the camera.
040BD8             0425*  ; inputs: ix = anglex; iy = angley; hl = anglez;
040BD8             0426*  vdu_3d_set_cam_xyz_rot:
040BD8 DD 22 F8 0B 0427*      ld (@anglex),ix
       04          
040BDD FD 22 FA 0B 0428*      ld (@angley),iy
       04          
040BE2 22 FC 0B 04 0429*      ld (@anglez),hl
040BE6 21 F1 0B 04 0430*      ld hl,@beg
040BEA 01 0D 00 00 0431*      ld bc,@end-@beg
040BEE 5B DF       0432*      rst.lil $18
040BF0 C9          0433*      ret
040BF1 17 00 A0    0434*  @beg: db 23, 0, $A0
040BF4 64 00       0435*  @sid: dw sid
040BF6 49 15       0436*  @cmd: db $49, 21 ; command 21: set camera xyz rotation angles
040BF8 00 00       0437*  @anglex: dw 0x0000
040BFA 00 00       0438*  @angley: dw 0x0000
040BFC 00 00       0439*  @anglez: dw 0x0000
040BFE 00          0440*  @end: db 0x00 ; padding
040BFF             0441*  
040BFF             0442*  ; Set Camera X Translation Distance
040BFF             0443*  ; VDU 23, 0, &A0, sid; &49, 22, distx; : Set Camera X Translation Distance
040BFF             0444*  ; This command sets the X translation distance for the camera. Note that 3D translation of the camera is independent of 2D translation of the the rendered bitmap.
040BFF             0445*  ; inputs: hl = distx;
040BFF             0446*  vdu_3d_set_cam_x_trans:
040BFF 22 15 0C 04 0447*      ld (@distx),hl
040C03 21 0E 0C 04 0448*      ld hl,@beg
040C07 01 09 00 00 0449*      ld bc,@end-@beg
040C0B 5B DF       0450*      rst.lil $18
040C0D C9          0451*      ret
040C0E 17 00 A0    0452*  @beg: db 23, 0, $A0
040C11 64 00       0453*  @sid: dw sid
040C13 49 16       0454*  @cmd: db $49, 22 ; command 22: set camera x translation distance
040C15 00 00       0455*  @distx: dw 0x0000
040C17 00          0456*  @end: db 0x00 ; padding
040C18             0457*  
040C18             0458*  ; Set Camera Y Translation Distance
040C18             0459*  ; VDU 23, 0, &A0, sid; &49, 23, disty; : Set Camera Y Translation Distance
040C18             0460*  ; This command sets the Y translation distance for the camera. Note that 3D translation of the camera is independent of 2D translation of the the rendered bitmap.
040C18             0461*  ; inputs: hl = disty;
040C18             0462*  vdu_3d_set_cam_y_trans:
040C18 22 2E 0C 04 0463*      ld (@disty),hl
040C1C 21 27 0C 04 0464*      ld hl,@beg
040C20 01 09 00 00 0465*      ld bc,@end-@beg
040C24 5B DF       0466*      rst.lil $18
040C26 C9          0467*      ret
040C27 17 00 A0    0468*  @beg: db 23, 0, $A0
040C2A 64 00       0469*  @sid: dw sid
040C2C 49 17       0470*  @cmd: db $49, 23 ; command 23: set camera y translation distance
040C2E 00 00       0471*  @disty: dw 0x0000
040C30 00          0472*  @end: db 0x00 ; padding
040C31             0473*  
040C31             0474*  ; Set Camera Z Translation Distance
040C31             0475*  ; VDU 23, 0, &A0, sid; &49, 24, distz; : Set Camera Z Translation Distance
040C31             0476*  ; This command sets the Z translation distance for the camera. Note that 3D translation of the camera is independent of 2D translation of the the rendered bitmap.
040C31             0477*  ; inputs: hl = distz;
040C31             0478*  vdu_3d_set_cam_z_trans:
040C31 22 47 0C 04 0479*      ld (@distz),hl
040C35 21 40 0C 04 0480*      ld hl,@beg
040C39 01 09 00 00 0481*      ld bc,@end-@beg
040C3D 5B DF       0482*      rst.lil $18
040C3F C9          0483*      ret
040C40 17 00 A0    0484*  @beg: db 23, 0, $A0
040C43 64 00       0485*  @sid: dw sid
040C45 49 18       0486*  @cmd: db $49, 24 ; command 24: set camera z translation distance
040C47 00 00       0487*  @distz: dw 0x0000
040C49 00          0488*  @end: db 0x00 ; padding
040C4A             0489*  
040C4A             0490*  ; Set Camera XYZ Translation Distances
040C4A             0491*  ; VDU 23, 0, &A0, sid; &49, 25, distx; disty; distz; : Set Camera XYZ Translation Distances
040C4A             0492*  ; This command sets the X, Y, and Z translation distances for the camera. Note that 3D translation of the camera is independent of 2D translation of the the rendered bitmap.
040C4A             0493*  ; inputs: ix = distx; iy = disty; hl = distz;
040C4A             0494*  vdu_3d_set_cam_xyz_trans:
040C4A DD 22 6A 0C 0495*      ld (@distx),ix
       04          
040C4F FD 22 6C 0C 0496*      ld (@disty),iy
       04          
040C54 22 6E 0C 04 0497*      ld (@distz),hl
040C58 21 63 0C 04 0498*      ld hl,@beg
040C5C 01 0D 00 00 0499*      ld bc,@end-@beg
040C60 5B DF       0500*      rst.lil $18
040C62 C9          0501*      ret
040C63 17 00 A0    0502*  @beg: db 23, 0, $A0
040C66 64 00       0503*  @sid: dw sid
040C68 49 19       0504*  @cmd: db $49, 25 ; command 25: set camera xyz translation distances
040C6A 00 00       0505*  @distx: dw 0x0000
040C6C 00 00       0506*  @disty: dw 0x0000
040C6E 00 00       0507*  @distz: dw 0x0000
040C70 00          0508*  @end: db 0x00 ; padding
040C71             0509*  
040C71             0510*  ; Set Scene X Scale Factor
040C71             0511*  ; VDU 23, 0, &A0, sid; &49, 26, scalex; : Set Scene X Scale Factor
040C71             0512*  ; This command sets the X scale factor for the scene.
040C71             0513*  ; inputs: hl = scalex;
040C71             0514*  vdu_3d_set_scn_x_scl:
040C71 22 87 0C 04 0515*      ld (@scalex),hl
040C75 21 80 0C 04 0516*      ld hl,@beg
040C79 01 09 00 00 0517*      ld bc,@end-@beg
040C7D 5B DF       0518*      rst.lil $18
040C7F C9          0519*      ret
040C80 17 00 A0    0520*  @beg: db 23, 0, $A0
040C83 64 00       0521*  @sid: dw sid
040C85 49 1A       0522*  @cmd: db $49, 26 ; command 26: set scene x scale factor
040C87 00 00       0523*  @scalex: dw 0x0000
040C89 00          0524*  @end: db 0x00 ; padding
040C8A             0525*  
040C8A             0526*  ; Set Scene Y Scale Factor
040C8A             0527*  ; VDU 23, 0, &A0, sid; &49, 27, scaley; : Set Scene Y Scale Factor
040C8A             0528*  ; This command sets the Y scale factor for the scene.
040C8A             0529*  ; inputs: hl = scaley;
040C8A             0530*  vdu_3d_set_scn_y_scl:
040C8A 22 A0 0C 04 0531*      ld (@scaley),hl
040C8E 21 99 0C 04 0532*      ld hl,@beg
040C92 01 09 00 00 0533*      ld bc,@end-@beg
040C96 5B DF       0534*      rst.lil $18
040C98 C9          0535*      ret
040C99 17 00 A0    0536*  @beg: db 23, 0, $A0
040C9C 64 00       0537*  @sid: dw sid
040C9E 49 1B       0538*  @cmd: db $49, 27 ; command 27: set scene y scale factor
040CA0 00 00       0539*  @scaley: dw 0x0000
040CA2 00          0540*  @end: db 0x00 ; padding
040CA3             0541*  
040CA3             0542*  ; Set Scene Z Scale Factor
040CA3             0543*  ; VDU 23, 0, &A0, sid; &49, 28, scalez; : Set Scene Z Scale Factor
040CA3             0544*  ; This command sets the Z scale factor for the scene.
040CA3             0545*  ; inputs: hl = scalez;
040CA3             0546*  vdu_3d_set_scn_z_scl:
040CA3 22 B9 0C 04 0547*      ld (@scalez),hl
040CA7 21 B2 0C 04 0548*      ld hl,@beg
040CAB 01 09 00 00 0549*      ld bc,@end-@beg
040CAF 5B DF       0550*      rst.lil $18
040CB1 C9          0551*      ret
040CB2 17 00 A0    0552*  @beg: db 23, 0, $A0
040CB5 64 00       0553*  @sid: dw sid
040CB7 49 1C       0554*  @cmd: db $49, 28 ; command 28: set scene z scale factor
040CB9 00 00       0555*  @scalez: dw 0x0000
040CBB 00          0556*  @end: db 0x00 ; padding
040CBC             0557*  
040CBC             0558*  ; Set Scene XYZ Scale Factors
040CBC             0559*  ; VDU 23, 0, &A0, sid; &49, 29, scalex; scaley; scalez; : Set Scene XYZ Scale Factors
040CBC             0560*  ; This command sets the X, Y, and Z scale factors for the scene.
040CBC             0561*  ; inputs: ix = scalex; iy = scaley; hl = scalez;
040CBC             0562*  vdu_3d_set_scn_xyz_scl:
040CBC DD 22 DC 0C 0563*      ld (@scalex),ix
       04          
040CC1 FD 22 DE 0C 0564*      ld (@scaley),iy
       04          
040CC6 22 E0 0C 04 0565*      ld (@scalez),hl
040CCA 21 D5 0C 04 0566*      ld hl,@beg
040CCE 01 0D 00 00 0567*      ld bc,@end-@beg
040CD2 5B DF       0568*      rst.lil $18
040CD4 C9          0569*      ret
040CD5 17 00 A0    0570*  @beg: db 23, 0, $A0
040CD8 64 00       0571*  @sid: dw sid
040CDA 49 1D       0572*  @cmd: db $49, 29 ; command 29: set scene xyz scale factors
040CDC 00 00       0573*  @scalex: dw 0x0000
040CDE 00 00       0574*  @scaley: dw 0x0000
040CE0 00 00       0575*  @scalez: dw 0x0000
040CE2 00          0576*  @end: db 0x00 ; padding
040CE3             0577*  ; Set Scene X Rotation Angle
040CE3             0578*  ; VDU 23, 0, &A0, sid; &49, 30, anglex; : Set Scene X Rotation Angle
040CE3             0579*  ; This command sets the X rotation angle for the scene.
040CE3             0580*  ; inputs: hl = anglex;
040CE3             0581*  vdu_3d_set_scn_x_rot:
040CE3 22 F9 0C 04 0582*      ld (@anglex),hl
040CE7 21 F2 0C 04 0583*      ld hl,@beg
040CEB 01 09 00 00 0584*      ld bc,@end-@beg
040CEF 5B DF       0585*      rst.lil $18
040CF1 C9          0586*      ret
040CF2 17 00 A0    0587*  @beg: db 23, 0, $A0
040CF5 64 00       0588*  @sid: dw sid
040CF7 49 1E       0589*  @cmd: db $49, 30 ; command 30: set scene x rotation angle
040CF9 00 00       0590*  @anglex: dw 0x0000
040CFB 00          0591*  @end: db 0x00 ; padding
040CFC             0592*  
040CFC             0593*  ; Set Scene Y Rotation Angle
040CFC             0594*  ; VDU 23, 0, &A0, sid; &49, 31, angley; : Set Scene Y Rotation Angle
040CFC             0595*  ; This command sets the Y rotation angle for the scene.
040CFC             0596*  ; inputs: hl = angley;
040CFC             0597*  vdu_3d_set_scn_y_rot:
040CFC 22 12 0D 04 0598*      ld (@angley),hl
040D00 21 0B 0D 04 0599*      ld hl,@beg
040D04 01 09 00 00 0600*      ld bc,@end-@beg
040D08 5B DF       0601*      rst.lil $18
040D0A C9          0602*      ret
040D0B 17 00 A0    0603*  @beg: db 23, 0, $A0
040D0E 64 00       0604*  @sid: dw sid
040D10 49 1F       0605*  @cmd: db $49, 31 ; command 31: set scene y rotation angle
040D12 00 00       0606*  @angley: dw 0x0000
040D14 00          0607*  @end: db 0x00 ; padding
040D15             0608*  
040D15             0609*  ; Set Scene Z Rotation Angle
040D15             0610*  ; VDU 23, 0, &A0, sid; &49, 32, anglez; : Set Scene Z Rotation Angle
040D15             0611*  ; This command sets the Z rotation angle for the scene.
040D15             0612*  ; inputs: hl = anglez;
040D15             0613*  vdu_3d_set_scn_z_rot:
040D15 22 2B 0D 04 0614*      ld (@anglez),hl
040D19 21 24 0D 04 0615*      ld hl,@beg
040D1D 01 09 00 00 0616*      ld bc,@end-@beg
040D21 5B DF       0617*      rst.lil $18
040D23 C9          0618*      ret
040D24 17 00 A0    0619*  @beg: db 23, 0, $A0
040D27 64 00       0620*  @sid: dw sid
040D29 49 20       0621*  @cmd: db $49, 32 ; command 32: set scene z rotation angle
040D2B 00 00       0622*  @anglez: dw 0x0000
040D2D 00          0623*  @end: db 0x00 ; padding
040D2E             0624*  
040D2E             0625*  ; Set Scene XYZ Rotation Angles
040D2E             0626*  ; VDU 23, 0, &A0, sid; &49, 33, anglex; angley; anglez; : Set Scene XYZ Rotation Angles
040D2E             0627*  ; This command sets the X, Y, and Z rotation angles for the scene.
040D2E             0628*  ; inputs: ix = anglex; iy = angley; hl = anglez;
040D2E             0629*  vdu_3d_set_scn_xyz_rot:
040D2E DD 22 4E 0D 0630*      ld (@anglex),ix
       04          
040D33 FD 22 50 0D 0631*      ld (@angley),iy
       04          
040D38 22 52 0D 04 0632*      ld (@anglez),hl
040D3C 21 47 0D 04 0633*      ld hl,@beg
040D40 01 0D 00 00 0634*      ld bc,@end-@beg
040D44 5B DF       0635*      rst.lil $18
040D46 C9          0636*      ret
040D47 17 00 A0    0637*  @beg: db 23, 0, $A0
040D4A 64 00       0638*  @sid: dw sid
040D4C 49 21       0639*  @cmd: db $49, 33 ; command 33: set scene xyz rotation angles
040D4E 00 00       0640*  @anglex: dw 0x0000
040D50 00 00       0641*  @angley: dw 0x0000
040D52 00 00       0642*  @anglez: dw 0x0000
040D54 00          0643*  @end: db 0x00 ; padding
040D55             0644*  ; Set Scene X Translation Distance
040D55             0645*  ; VDU 23, 0, &A0, sid; &49, 34, distx; : Set Scene X Translation Distance
040D55             0646*  ; This command sets the X translation distance for the scene. Note that 3D translation of the scene is independent of 2D translation of the the rendered bitmap.
040D55             0647*  ; inputs: hl = distx;
040D55             0648*  vdu_3d_set_scn_x_trans:
040D55 22 6B 0D 04 0649*      ld (@distx),hl
040D59 21 64 0D 04 0650*      ld hl,@beg
040D5D 01 09 00 00 0651*      ld bc,@end-@beg
040D61 5B DF       0652*      rst.lil $18
040D63 C9          0653*      ret
040D64 17 00 A0    0654*  @beg: db 23, 0, $A0
040D67 64 00       0655*  @sid: dw sid
040D69 49 22       0656*  @cmd: db $49, 34 ; command 34: set scene x translation distance
040D6B 00 00       0657*  @distx: dw 0x0000
040D6D 00          0658*  @end: db 0x00 ; padding
040D6E             0659*  
040D6E             0660*  ; Set Scene Y Translation Distance
040D6E             0661*  ; VDU 23, 0, &A0, sid; &49, 35, disty; : Set Scene Y Translation Distance
040D6E             0662*  ; This command sets the Y translation distance for the scene. Note that 3D translation of the scene is independent of 2D translation of the the rendered bitmap.
040D6E             0663*  ; inputs: hl = disty;
040D6E             0664*  vdu_3d_set_scn_y_trans:
040D6E 22 84 0D 04 0665*      ld (@disty),hl
040D72 21 7D 0D 04 0666*      ld hl,@beg
040D76 01 09 00 00 0667*      ld bc,@end-@beg
040D7A 5B DF       0668*      rst.lil $18
040D7C C9          0669*      ret
040D7D 17 00 A0    0670*  @beg: db 23, 0, $A0
040D80 64 00       0671*  @sid: dw sid
040D82 49 23       0672*  @cmd: db $49, 35 ; command 35: set scene y translation distance
040D84 00 00       0673*  @disty: dw 0x0000
040D86 00          0674*  @end: db 0x00 ; padding
040D87             0675*  
040D87             0676*  ; Set Scene Z Translation Distance
040D87             0677*  ; VDU 23, 0, &A0, sid; &49, 36, distz; : Set Scene Z Translation Distance
040D87             0678*  ; This command sets the Z translation distance for the scene. Note that 3D translation of the scene is independent of 2D translation of the the rendered bitmap.
040D87             0679*  ; inputs: hl = distz;
040D87             0680*  vdu_3d_set_scn_z_trans:
040D87 22 9D 0D 04 0681*      ld (@distz),hl
040D8B 21 96 0D 04 0682*      ld hl,@beg
040D8F 01 09 00 00 0683*      ld bc,@end-@beg
040D93 5B DF       0684*      rst.lil $18
040D95 C9          0685*      ret
040D96 17 00 A0    0686*  @beg: db 23, 0, $A0
040D99 64 00       0687*  @sid: dw sid
040D9B 49 24       0688*  @cmd: db $49, 36 ; command 36: set scene z translation distance
040D9D 00 00       0689*  @distz: dw 0x0000
040D9F 00          0690*  @end: db 0x00 ; padding
040DA0             0691*  
040DA0             0692*  ; Set Scene XYZ Translation Distances
040DA0             0693*  ; VDU 23, 0, &A0, sid; &49, 37, distx; disty; distz; : Set Scene XYZ Translation Distances
040DA0             0694*  ; This command sets the X, Y, and Z translation distances for the scene. Note that 3D translation of the scene is independent of 2D translation of the the rendered bitmap.
040DA0             0695*  ; inputs: ix = distx; iy = disty; hl = distz;
040DA0             0696*  vdu_3d_set_scn_xyz_trans:
040DA0 DD 22 C0 0D 0697*      ld (@distx),ix
       04          
040DA5 FD 22 C2 0D 0698*      ld (@disty),iy
       04          
040DAA 22 C4 0D 04 0699*      ld (@distz),hl
040DAE 21 B9 0D 04 0700*      ld hl,@beg
040DB2 01 0D 00 00 0701*      ld bc,@end-@beg
040DB6 5B DF       0702*      rst.lil $18
040DB8 C9          0703*      ret
040DB9 17 00 A0    0704*  @beg: db 23, 0, $A0
040DBC 64 00       0705*  @sid: dw sid
040DBE 49 25       0706*  @cmd: db $49, 37 ; command 37: set scene xyz translation distances
040DC0 00 00       0707*  @distx: dw 0x0000
040DC2 00 00       0708*  @disty: dw 0x0000
040DC4 00 00       0709*  @distz: dw 0x0000
040DC6 00          0710*  @end: db 0x00 ; padding
040DC7             0711*  
040DC7             0712*  ; Render To Bitmap
040DC7             0713*  ; VDU 23, 0, &A0, sid; &49, 38, bmid; : Render To Bitmap
040DC7             0714*  ; This command uses information provided by the above commands to render the 3D scene onto the specified bitmap.
040DC7             0715*  ; This command must be used in order to perform the render operation; it does not happen automatically when other commands change some of the render parameters.
040DC7             0716*  ; inputs: bc = bmid;
040DC7             0717*  vdu_3d_render_to_bitmap:
040DC7 ED 43 DE 0D 0718*      ld (@bmid),bc
       04          
040DCC 21 D7 0D 04 0719*      ld hl,@beg
040DD0 01 09 00 00 0720*      ld bc,@end-@beg
040DD4 5B DF       0721*      rst.lil $18
040DD6 C9          0722*      ret
040DD7 17 00 A0    0723*  @beg: db 23, 0, $A0
040DDA 64 00       0724*  @sid: dw sid
040DDC 49 26       0725*  @cmd: db $49, 38 ; command 38: render to bitmap
040DDE 00 00       0726*  @bmid: dw 0x0000
040DE0 00          0727*  @end: db 0x00 ; padding
040DE1             0728*  
040DE1             0729*  ; Delete Control Structure
040DE1             0730*  ; VDU 23, 0, &A0, sid; &49, 39 : Delete Control Structure
040DE1             0731*  ; This command deinitializes an existing control structure, assuming that it exists in the designated buffer. The buffer is subsequently deleted, as part of processing for this command.
040DE1             0732*  ; inputs: none
040DE1             0733*  vdu_3d_del_ctl_str:
040DE1 21 EC 0D 04 0734*      ld hl,@beg
040DE5 01 07 00 00 0735*      ld bc,@end-@beg
040DE9 5B DF       0736*      rst.lil $18
040DEB C9          0737*      ret
040DEC 17 00 A0    0738*  @beg: db 23, 0, $A0
040DEF 64 00       0739*  @sid: dw sid
040DF1 49 27       0740*  @cmd: db $49, 39 ; command 39: delete control structure
040DF3             0741*  @end:
040DF3             0332       include "pingo/src/asm/functions.asm"
040DF3             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040DF3             0002*  ; Print a zero-terminated string
040DF3             0003*  ; HL: Pointer to string
040DF3             0004*  printString:
040DF3 C5          0005*  	PUSH	BC
040DF4 01 00 00 00 0006*  	LD		BC,0
040DF8 3E 00       0007*  	LD 	 	A,0
040DFA 5B DF       0008*  	RST.LIL 18h
040DFC C1          0009*  	POP		BC
040DFD C9          0010*  	RET
040DFE             0011*  ; print a VDU sequence
040DFE             0012*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040DFE             0013*  sendVDUsequence:
040DFE C5          0014*  	PUSH	BC
040DFF 01 00 00 00 0015*  	LD		BC, 0
040E03 4E          0016*  	LD		C, (HL)
040E04 5B DF       0017*  	RST.LIL	18h
040E06 C1          0018*  	POP		BC
040E07 C9          0019*  	RET
040E08             0020*  ; Print Newline sequence to VDP
040E08             0021*  printNewLine:
040E08 3E 0D       0022*  	LD	A, '\r'
040E0A 5B D7       0023*  	RST.LIL 10h
040E0C 3E 0A       0024*  	LD	A, '\n'
040E0E 5B D7       0025*  	RST.LIL 10h
040E10 C9          0026*  	RET
040E11             0027*  ; Print a 24-bit HEX number
040E11             0028*  ; HLU: Number to print
040E11             0029*  printHex24:
040E11 E5          0030*  	PUSH	HL
040E12 21 02 00 00 0031*  	LD		HL, 2
040E16 39          0032*  	ADD		HL, SP
040E17 7E          0033*  	LD		A, (HL)
040E18 E1          0034*  	POP		HL
040E19 CD 23 0E 04 0035*  	CALL	printHex8
040E1D             0036*  ; Print a 16-bit HEX number
040E1D             0037*  ; HL: Number to print
040E1D             0038*  printHex16:
040E1D 7C          0039*  	LD		A,H
040E1E CD 23 0E 04 0040*  	CALL	printHex8
040E22 7D          0041*  	LD		A,L
040E23             0042*  ; Print an 8-bit HEX number
040E23             0043*  ; A: Number to print
040E23             0044*  printHex8:
040E23 4F          0045*  	LD		C,A
040E24 1F          0046*  	RRA
040E25 1F          0047*  	RRA
040E26 1F          0048*  	RRA
040E27 1F          0049*  	RRA
040E28 CD 2D 0E 04 0050*  	CALL	@F
040E2C 79          0051*  	LD		A,C
040E2D             0052*  @@:
040E2D E6 0F       0053*  	AND		0Fh
040E2F C6 90       0054*  	ADD		A,90h
040E31 27          0055*  	DAA
040E32 CE 40       0056*  	ADC		A,40h
040E34 27          0057*  	DAA
040E35 5B D7       0058*  	RST.LIL	10h
040E37 C9          0059*  	RET
040E38             0060*  
040E38             0061*  ; Print a 0x HEX prefix
040E38             0062*  DisplayHexPrefix:
040E38 3E 30       0063*  	LD	A, '0'
040E3A 5B D7       0064*  	RST.LIL 10h
040E3C 3E 78       0065*  	LD	A, 'x'
040E3E 5B D7       0066*  	RST.LIL 10h
040E40 C9          0067*  	RET
040E41             0068*  
040E41             0069*  
040E41             0070*  ; Prints the right justified decimal value in HL without leading zeroes
040E41             0071*  ; HL : Value to print
040E41             0072*  printDec:
040E41 11 65 0E 04 0073*  	LD	 DE, _printDecBuffer
040E45 CD 6E 0E 04 0074*  	CALL Num2String
040E49             0075*  ; BEGIN MY CODE
040E49             0076*  ; replace leading zeroes with spaces
040E49 21 65 0E 04 0077*      LD	 HL, _printDecBuffer
040E4D 06 07       0078*      ld   B, 7 ; if HL was 0, we want to keep the final zero
040E4F             0079*  @loop:
040E4F 7E          0080*      LD	 A, (HL)
040E50 FE 30       0081*      CP	 '0'
040E52 C2 60 0E 04 0082*      JP	 NZ, @done
040E56 3E 20       0083*      LD   A, ' '
040E58 77          0084*      LD	 (HL), A
040E59 23          0085*      INC	 HL
040E5A CD A0 03 04 0086*      CALL vdu_cursor_forward
040E5E 10 EF       0087*      DJNZ @loop
040E60             0088*  @done:
040E60             0089*  ; END MY CODE
040E60             0090*  	; LD	 HL, _printDecBuffer
040E60 CD F3 0D 04 0091*  	CALL printString
040E64 C9          0092*  	RET
040E65 00 00 00 00 0093*  _printDecBuffer: blkb 9,0 ; nine bytes full of zeroes
       00 00 00 00 
       00          
040E6E             0094*  
040E6E             0095*  ; This routine converts the value from HL into it's ASCII representation,
040E6E             0096*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040E6E             0097*  ; so it will allways be 8 characters length
040E6E             0098*  ; HL : Value to convert to string
040E6E             0099*  ; DE : pointer to buffer, at least 8 byte + 0
040E6E             0100*  Num2String:
040E6E 01 80 69 67 0101*  	LD	 BC,-10000000
040E72 CD A5 0E 04 0102*  	CALL OneDigit
040E76 01 C0 BD F0 0103*  	LD	 BC,-1000000
040E7A CD A5 0E 04 0104*  	CALL OneDigit
040E7E 01 60 79 FE 0105*  	LD	 BC,-100000
040E82 CD A5 0E 04 0106*  	CALL OneDigit
040E86 01 F0 D8 FF 0107*  	LD   BC,-10000
040E8A CD A5 0E 04 0108*  	CALL OneDigit
040E8E 01 18 FC FF 0109*  	LD   BC,-1000
040E92 CD A5 0E 04 0110*  	CALL OneDigit
040E96 01 9C FF FF 0111*  	LD   BC,-100
040E9A CD A5 0E 04 0112*  	CALL OneDigit
040E9E 0E F6       0113*  	LD   C,-10
040EA0 CD A5 0E 04 0114*  	CALL OneDigit
040EA4 48          0115*  	LD   C,B
040EA5             0116*  OneDigit:
040EA5 3E 2F       0117*  	LD   A,'0'-1
040EA7             0118*  DivideMe:
040EA7 3C          0119*  	INC  A
040EA8 09          0120*  	ADD  HL,BC
040EA9 38 FC       0121*  	JR   C,DivideMe
040EAB ED 42       0122*  	SBC  HL,BC
040EAD 12          0123*  	LD   (DE),A
040EAE 13          0124*  	INC  DE
040EAF C9          0125*  	RET
040EB0             0126*  
040EB0             0127*  
040EB0             0128*  ; #### new functions added by Brandon R. Gates ####
040EB0             0129*  
040EB0             0130*  ; print the binary representation of the 8-bit value in a
040EB0             0131*  ; destroys a, hl, bc
040EB0             0132*  printBin8:
040EB0 06 08       0133*      ld b,8      ; loop counter for 8 bits
040EB2 21 CD 0E 04 0134*      ld hl,@cmd  ; set hl to the low byte of the output string
040EB6             0135*                  ; (which will be the high bit of the value in a)
040EB6             0136*  @loop:
040EB6 07          0137*      rlca ; put the next highest bit into carry
040EB7 38 04       0138*      jr c,@one
040EB9 36 30       0139*      ld (hl),'0'
040EBB 18 02       0140*      jr @next_bit
040EBD             0141*  @one:
040EBD 36 31       0142*      ld (hl),'1'
040EBF             0143*  @next_bit:
040EBF 23          0144*      inc hl
040EC0 10 F4       0145*      djnz @loop
040EC2             0146*  ; print it
040EC2 21 CD 0E 04 0147*  	ld hl,@cmd
040EC6 01 08 00 00 0148*  	ld bc,@end-@cmd
040ECA 5B DF       0149*  	rst.lil $18
040ECC C9          0150*  	ret
040ECD             0151*  @cmd: ds 8 ; eight bytes for eight bits
040ED5             0152*  @end:
040ED5             0153*  
040ED5             0154*  ; print the binary representation of the 8-bit value in a
040ED5             0155*  ; in reverse order (lsb first)
040ED5             0156*  ; destroys a, hl, bc
040ED5             0157*  printBin8Rev:
040ED5 06 08       0158*      ld b,8      ; loop counter for 8 bits
040ED7 21 F2 0E 04 0159*      ld hl,@cmd  ; set hl to the low byte of the output string
040EDB             0160*                  ; (which will be the high bit of the value in a)
040EDB             0161*  @loop:
040EDB 0F          0162*      rrca ; put the next lowest bit into carry
040EDC 38 04       0163*      jr c,@one
040EDE 36 30       0164*      ld (hl),'0'
040EE0 18 02       0165*      jr @next_bit
040EE2             0166*  @one:
040EE2 36 31       0167*      ld (hl),'1'
040EE4             0168*  @next_bit:
040EE4 23          0169*      inc hl
040EE5 10 F4       0170*      djnz @loop
040EE7             0171*  ; print it
040EE7 21 F2 0E 04 0172*  	ld hl,@cmd
040EEB 01 08 00 00 0173*  	ld bc,@end-@cmd
040EEF 5B DF       0174*  	rst.lil $18
040EF1 C9          0175*  	ret
040EF2             0176*  @cmd: ds 8 ; eight bytes for eight bits
040EFA             0177*  @end:
040EFA             0178*  
040EFA             0179*  ; print registers to screen in hexidecimal format
040EFA             0180*  ; inputs: none
040EFA             0181*  ; outputs: values of every register printed to screen
040EFA             0182*  ;    values of each register in global scratch memory
040EFA             0183*  ; destroys: nothing
040EFA             0184*  stepRegistersHex:
040EFA             0185*  ; store everything in scratch
040EFA 22 FD 10 04 0186*      ld (uhl),hl
040EFE ED 43 00 11 0187*      ld (ubc),bc
       04          
040F03 ED 53 03 11 0188*      ld (ude),de
       04          
040F08 DD 22 06 11 0189*      ld (uix),ix
       04          
040F0D FD 22 09 11 0190*      ld (uiy),iy
       04          
040F12 F5          0191*      push af ; fml
040F13 E1          0192*      pop hl  ; thanks, zilog
040F14 22 FA 10 04 0193*      ld (uaf),hl
040F18 F5          0194*      push af ; dammit
040F19             0195*  
040F19             0196*  ; home the cursor
040F19 CD E7 04 04 0197*      call vdu_home_cursor
040F1D             0198*  
040F1D             0199*  ; print each register
040F1D 21 86 10 04 0200*      ld hl,str_afu
040F21 CD F3 0D 04 0201*      call printString
040F25 2A FA 10 04 0202*      ld hl,(uaf)
040F29 CD 11 0E 04 0203*      call printHex24
040F2D CD 08 0E 04 0204*      call printNewLine
040F31             0205*  
040F31 21 8A 10 04 0206*      ld hl,str_hlu
040F35 CD F3 0D 04 0207*      call printString
040F39 2A FD 10 04 0208*      ld hl,(uhl)
040F3D CD 11 0E 04 0209*      call printHex24
040F41 CD 08 0E 04 0210*      call printNewLine
040F45             0211*  
040F45 21 8E 10 04 0212*      ld hl,str_bcu
040F49 CD F3 0D 04 0213*      call printString
040F4D 2A 00 11 04 0214*      ld hl,(ubc)
040F51 CD 11 0E 04 0215*      call printHex24
040F55 CD 08 0E 04 0216*      call printNewLine
040F59             0217*  
040F59 21 92 10 04 0218*      ld hl,str_deu
040F5D CD F3 0D 04 0219*      call printString
040F61 2A 03 11 04 0220*      ld hl,(ude)
040F65 CD 11 0E 04 0221*      call printHex24
040F69 CD 08 0E 04 0222*      call printNewLine
040F6D             0223*  
040F6D 21 96 10 04 0224*      ld hl,str_ixu
040F71 CD F3 0D 04 0225*      call printString
040F75 2A 06 11 04 0226*      ld hl,(uix)
040F79 CD 11 0E 04 0227*      call printHex24
040F7D CD 08 0E 04 0228*      call printNewLine
040F81             0229*  
040F81 21 9A 10 04 0230*      ld hl,str_iyu
040F85 CD F3 0D 04 0231*      call printString
040F89 2A 09 11 04 0232*      ld hl,(uiy)
040F8D CD 11 0E 04 0233*      call printHex24
040F91 CD 08 0E 04 0234*      call printNewLine
040F95             0235*  
040F95             0236*      ; call vsync
040F95             0237*  
040F95 CD 08 0E 04 0238*      call printNewLine
040F99             0239*  
040F99             0240*  ; check for right shift key and quit if pressed
040F99             0241*  	MOSCALL mos_getkbmap
040F99 3E 1E       0001*M 			LD	A, function
040F9B 5B CF       0002*M 			RST.LIL	08h
040F9D             0242*  @stayhere:
040F9D             0243*  ; 7 RightShift
040F9D DD CB 00 76 0244*      bit 6,(ix+0)
040FA1 20 02       0245*      jr nz,@RightShift
040FA3 18 F8       0246*      jr @stayhere
040FA5             0247*  @RightShift:
040FA5 DD CB 0E 86 0248*      res 0,(ix+14) ; debounce the key (hopefully)
040FA9 3E 80       0249*      ld a,%10000000
040FAB CD 58 13 04 0250*      call multiPurposeDelay
040FAF             0251*  
040FAF             0252*  ; restore everything
040FAF 2A FD 10 04 0253*      ld hl, (uhl)
040FB3 ED 4B 00 11 0254*      ld bc, (ubc)
       04          
040FB8 ED 5B 03 11 0255*      ld de, (ude)
       04          
040FBD DD 2A 06 11 0256*      ld ix, (uix)
       04          
040FC2 FD 2A 09 11 0257*      ld iy, (uiy)
       04          
040FC7 F1          0258*      pop af
040FC8             0259*  ; all done
040FC8 C9          0260*      ret
040FC9             0261*  
040FC9             0262*  ; print registers to screen in hexidecimal format
040FC9             0263*  ; inputs: none
040FC9             0264*  ; outputs: values of every register printed to screen
040FC9             0265*  ;    values of each register in global scratch memory
040FC9             0266*  ; destroys: nothing
040FC9             0267*  dumpRegistersHex:
040FC9             0268*  ; store everything in scratch
040FC9 22 FD 10 04 0269*      ld (uhl),hl
040FCD ED 43 00 11 0270*      ld (ubc),bc
       04          
040FD2 ED 53 03 11 0271*      ld (ude),de
       04          
040FD7 DD 22 06 11 0272*      ld (uix),ix
       04          
040FDC FD 22 09 11 0273*      ld (uiy),iy
       04          
040FE1 F5          0274*      push af ; fml
040FE2 E1          0275*      pop hl  ; thanks, zilog
040FE3 22 FA 10 04 0276*      ld (uaf),hl
040FE7 F5          0277*      push af ; dammit
040FE8             0278*  
040FE8             0279*  ; home the cursor
040FE8 CD E7 04 04 0280*      call vdu_home_cursor
040FEC             0281*  
040FEC             0282*  ; print each register
040FEC 21 86 10 04 0283*      ld hl,str_afu
040FF0 CD F3 0D 04 0284*      call printString
040FF4 2A FA 10 04 0285*      ld hl,(uaf)
040FF8 CD 11 0E 04 0286*      call printHex24
040FFC CD 08 0E 04 0287*      call printNewLine
041000             0288*  
041000 21 8A 10 04 0289*      ld hl,str_hlu
041004 CD F3 0D 04 0290*      call printString
041008 2A FD 10 04 0291*      ld hl,(uhl)
04100C CD 11 0E 04 0292*      call printHex24
041010 CD 08 0E 04 0293*      call printNewLine
041014             0294*  
041014 21 8E 10 04 0295*      ld hl,str_bcu
041018 CD F3 0D 04 0296*      call printString
04101C 2A 00 11 04 0297*      ld hl,(ubc)
041020 CD 11 0E 04 0298*      call printHex24
041024 CD 08 0E 04 0299*      call printNewLine
041028             0300*  
041028 21 92 10 04 0301*      ld hl,str_deu
04102C CD F3 0D 04 0302*      call printString
041030 2A 03 11 04 0303*      ld hl,(ude)
041034 CD 11 0E 04 0304*      call printHex24
041038 CD 08 0E 04 0305*      call printNewLine
04103C             0306*  
04103C 21 96 10 04 0307*      ld hl,str_ixu
041040 CD F3 0D 04 0308*      call printString
041044 2A 06 11 04 0309*      ld hl,(uix)
041048 CD 11 0E 04 0310*      call printHex24
04104C CD 08 0E 04 0311*      call printNewLine
041050             0312*  
041050 21 9A 10 04 0313*      ld hl,str_iyu
041054 CD F3 0D 04 0314*      call printString
041058 2A 09 11 04 0315*      ld hl,(uiy)
04105C CD 11 0E 04 0316*      call printHex24
041060 CD 08 0E 04 0317*      call printNewLine
041064             0318*  
041064 CD 09 06 04 0319*      call vdu_vblank
041068             0320*  
041068 CD 08 0E 04 0321*      call printNewLine
04106C             0322*  ; restore everything
04106C 2A FD 10 04 0323*      ld hl, (uhl)
041070 ED 4B 00 11 0324*      ld bc, (ubc)
       04          
041075 ED 5B 03 11 0325*      ld de, (ude)
       04          
04107A DD 2A 06 11 0326*      ld ix, (uix)
       04          
04107F FD 2A 09 11 0327*      ld iy, (uiy)
       04          
041084 F1          0328*      pop af
041085             0329*  ; all done
041085 C9          0330*      ret
041086             0331*  
041086 61 66 3D 00 0332*  str_afu: db "af=",0
04108A 68 6C 3D 00 0333*  str_hlu: db "hl=",0
04108E 62 63 3D 00 0334*  str_bcu: db "bc=",0
041092 64 65 3D 00 0335*  str_deu: db "de=",0
041096 69 78 3D 00 0336*  str_ixu: db "ix=",0
04109A 69 79 3D 00 0337*  str_iyu: db "iy=",0
04109E             0338*  
04109E             0339*  ; print udeuhl to screen in hexidecimal format
04109E             0340*  ; inputs: none
04109E             0341*  ; outputs: concatenated hexidecimal udeuhl
04109E             0342*  ; destroys: nothing
04109E             0343*  dumpUDEUHLHex:
04109E             0344*  ; store everything in scratch
04109E 22 FD 10 04 0345*      ld (uhl),hl
0410A2 ED 43 00 11 0346*      ld (ubc),bc
       04          
0410A7 ED 53 03 11 0347*      ld (ude),de
       04          
0410AC DD 22 06 11 0348*      ld (uix),ix
       04          
0410B1 FD 22 09 11 0349*      ld (uiy),iy
       04          
0410B6 F5          0350*      push af
0410B7             0351*  
0410B7             0352*  ; print each register
0410B7             0353*  
0410B7 21 F1 10 04 0354*      ld hl,str_udeuhl
0410BB CD F3 0D 04 0355*      call printString
0410BF 2A 03 11 04 0356*      ld hl,(ude)
0410C3 CD 11 0E 04 0357*      call printHex24
0410C7 3E 2E       0358*  	ld a,'.'	; print a dot to separate the values
0410C9 5B D7       0359*  	rst.lil 10h
0410CB 2A FD 10 04 0360*      ld hl,(uhl)
0410CF CD 11 0E 04 0361*      call printHex24
0410D3 CD 08 0E 04 0362*      call printNewLine
0410D7             0363*  
0410D7             0364*  ; restore everything
0410D7 2A FD 10 04 0365*      ld hl, (uhl)
0410DB ED 4B 00 11 0366*      ld bc, (ubc)
       04          
0410E0 ED 5B 03 11 0367*      ld de, (ude)
       04          
0410E5 DD 2A 06 11 0368*      ld ix, (uix)
       04          
0410EA FD 2A 09 11 0369*      ld iy, (uiy)
       04          
0410EF F1          0370*      pop af
0410F0             0371*  ; all done
0410F0 C9          0372*      ret
0410F1             0373*  
0410F1 75 64 65 2E 0374*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0410FA             0375*  
0410FA             0376*  ; global scratch memory for registers
0410FA 00 00 00    0377*  uaf: dl 0
0410FD 00 00 00    0378*  uhl: dl 0
041100 00 00 00    0379*  ubc: dl 0
041103 00 00 00    0380*  ude: dl 0
041106 00 00 00    0381*  uix: dl 0
041109 00 00 00    0382*  uiy: dl 0
04110C 00 00 00    0383*  usp: dl 0
04110F 00 00 00    0384*  upc: dl 0
041112             0385*  
041112             0386*  ; inputs: whatever is in the flags register
041112             0387*  ; outputs: binary representation of flags
041112             0388*  ;          with a header so we know which is what
041112             0389*  ; destroys: nothing
041112             0390*  ; preserves: everything
041112             0391*  dumpFlags:
041112             0392*  ; first we curse zilog for not giving direct access to flags
041112 F5          0393*      push af ; this is so we can send it back unharmed
041113 F5          0394*      push af ; this is so we can pop it to hl
041114             0395*  ; store everything in scratch
041114 22 FD 10 04 0396*      ld (uhl),hl
041118 ED 43 00 11 0397*      ld (ubc),bc
       04          
04111D ED 53 03 11 0398*      ld (ude),de
       04          
041122 DD 22 06 11 0399*      ld (uix),ix
       04          
041127 FD 22 09 11 0400*      ld (uiy),iy
       04          
04112C             0401*  ; next we print the header
04112C 21 58 11 04 0402*      ld hl,@header
041130 CD F3 0D 04 0403*      call printString
041134 E1          0404*      pop hl ; flags are now in l
041135 7D          0405*      ld a,l ; flags are now in a
041136 CD B0 0E 04 0406*      call printBin8
04113A CD 08 0E 04 0407*  	call printNewLine
04113E             0408*  ; restore everything
04113E 2A FD 10 04 0409*      ld hl, (uhl)
041142 ED 4B 00 11 0410*      ld bc, (ubc)
       04          
041147 ED 5B 03 11 0411*      ld de, (ude)
       04          
04114C DD 2A 06 11 0412*      ld ix, (uix)
       04          
041151 FD 2A 09 11 0413*      ld iy, (uiy)
       04          
041156 F1          0414*      pop af ; send her home the way she came
041157 C9          0415*      ret
041158             0416*  ; Bit 7 (S): Sign flag
041158             0417*  ; Bit 6 (Z): Zero flag
041158             0418*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
041158             0419*  ; Bit 4 (H): Half Carry flag
041158             0420*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
041158             0421*  ; Bit 2 (PV): Parity/Overflow flag
041158             0422*  ; Bit 1 (N): Subtract flag
041158             0423*  ; Bit 0 (C): Carry flag
041158 53 5A 78 48 0424*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
041163             0425*  
041163             0426*  ; set all the bits in the flag register
041163             0427*  ; more of an academic exercise than anything useful
041163             0428*  ; inputs; none
041163             0429*  ; outputs; a=0,f=255
041163             0430*  ; destroys: flags, hl
041163             0431*  ; preserves: a, because why not
041163             0432*  setAllFlags:
041163 21 FF 00 00 0433*      ld hl,255
041167 67          0434*      ld h,a ; four cycles to preserve a is cheap
041168 E5          0435*      push hl
041169 F1          0436*      pop af
04116A C9          0437*      ret
04116B             0438*  
04116B             0439*  ; reset all the bits in the flag register
04116B             0440*  ; unlike its inverse counterpart, this may actually be useful
04116B             0441*  ; inputs; none
04116B             0442*  ; outputs; a=0,f=0
04116B             0443*  ; destroys: flags, hl
04116B             0444*  ; preserves: a, because why not
04116B             0445*  resetAllFlags:
04116B 21 00 00 00 0446*      ld hl,0
04116F 67          0447*      ld h,a ; four cycles to preserve a is cheap
041170 E5          0448*      push hl
041171 F1          0449*      pop af
041172 C9          0450*      ret
041173             0451*  
041173             0452*  ; wait until user presses a key
041173             0453*  ; inputs: none
041173             0454*  ; outputs: none
041173             0455*  ; destroys: af,hl,ix
041173             0456*  waitKeypress:
041173             0457*      ; ld hl,str_press_shift
041173             0458*      ; call printString
041173             0459*      MOSCALL mos_sysvars
041173 3E 08       0001*M 			LD	A, function
041175 5B CF       0002*M 			RST.LIL	08h
041177 AF          0460*      xor a ; zero out any prior keypresses
041178 DD 77 05    0461*      ld (ix+sysvar_keyascii),a
04117B             0462*  @loop:
04117B DD 7E 05    0463*      ld a,(ix+sysvar_keyascii)
04117E A7          0464*      and a
04117F C0          0465*      ret nz
041180 18 F9       0466*      jr @loop
041182             0467*  
041182             0468*  ; wait until user presses return key
041182             0469*  ; inputs: none
041182             0470*  ; outputs: none
041182             0471*  ; destroys: af,ix
041182             0472*  waitReturn:
041182             0473*  ; check for return key and quit if pressed
041182             0474*      MOSCALL mos_sysvars
041182 3E 08       0001*M 			LD	A, function
041184 5B CF       0002*M 			RST.LIL	08h
041186 AF          0475*      xor a ; zero out any prior keypresses
041187 DD 77 05    0476*      ld (ix+sysvar_keyascii),a
04118A             0477*  @stayhere:
04118A DD 7E 05    0478*      ld a,(ix+sysvar_keyascii)
04118D FE 0D       0479*      cp 13
04118F 20 F9       0480*      jr nz,@stayhere
041191 3E 80       0481*      ld a,%10000000
041193 CD 58 13 04 0482*      call multiPurposeDelay
041197 C9          0483*      ret
041198             0484*  
041198             0485*  ; print bytes from an address to the screen in hexidecimal format
041198             0486*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041198             0487*  ; outputs: values of each byte printed to screen separated by spaces
041198             0488*  ; destroys: nothing
041198             0489*  dumpMemoryHex:
041198             0490*  ; save all registers to the stack
041198 F5          0491*      push af
041199 C5          0492*      push bc
04119A D5          0493*      push de
04119B E5          0494*      push hl
04119C DD E5       0495*      push ix
04119E FD E5       0496*      push iy
0411A0             0497*  
0411A0             0498*  ; set b to be our loop counter
0411A0 47          0499*      ld b,a
0411A1             0500*  @loop:
0411A1             0501*  ; print the byte
0411A1 7E          0502*      ld a,(hl)
0411A2 CD 23 0E 04 0503*      call printHex8
0411A6             0504*  ; print a space
0411A6 3E 20       0505*      ld a,' '
0411A8 5B D7       0506*      rst.lil 10h
0411AA 23          0507*      inc hl
0411AB 10 F4       0508*      djnz @loop
0411AD CD 08 0E 04 0509*      call printNewLine
0411B1             0510*  
0411B1             0511*  ; restore everything
0411B1 FD E1       0512*      pop iy
0411B3 DD E1       0513*      pop ix
0411B5 E1          0514*      pop hl
0411B6 D1          0515*      pop de
0411B7 C1          0516*      pop bc
0411B8 F1          0517*      pop af
0411B9             0518*  ; all done
0411B9 C9          0519*      ret
0411BA             0520*  
0411BA             0521*  
0411BA             0522*  ; print bytes from an address to the screen in binary format
0411BA             0523*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0411BA             0524*  ; outputs: values of each byte printed to screen separated by spaces
0411BA             0525*  ; destroys: nothing
0411BA             0526*  dumpMemoryBin:
0411BA             0527*  ; save all registers to the stack
0411BA F5          0528*      push af
0411BB C5          0529*      push bc
0411BC D5          0530*      push de
0411BD E5          0531*      push hl
0411BE DD E5       0532*      push ix
0411C0 FD E5       0533*      push iy
0411C2             0534*  
0411C2             0535*  ; set b to be our loop counter
0411C2 47          0536*      ld b,a
0411C3             0537*  @loop:
0411C3             0538*  ; print the byte
0411C3 7E          0539*      ld a,(hl)
0411C4 E5          0540*      push hl
0411C5 C5          0541*      push bc
0411C6 CD B0 0E 04 0542*      call printBin8
0411CA C1          0543*      pop bc
0411CB             0544*  ; print a space
0411CB 3E 20       0545*      ld a,' '
0411CD 5B D7       0546*      rst.lil 10h
0411CF E1          0547*      pop hl
0411D0 23          0548*      inc hl
0411D1 10 F0       0549*      djnz @loop
0411D3 CD 08 0E 04 0550*      call printNewLine
0411D7             0551*  
0411D7             0552*  ; restore everything
0411D7 FD E1       0553*      pop iy
0411D9 DD E1       0554*      pop ix
0411DB E1          0555*      pop hl
0411DC D1          0556*      pop de
0411DD C1          0557*      pop bc
0411DE F1          0558*      pop af
0411DF             0559*  ; all done
0411DF C9          0560*      ret
0411E0             0561*  
0411E0             0562*  ; print bytes from an address to the screen in binary format
0411E0             0563*  ; with the bits of each byte in reverse order (lsb first)
0411E0             0564*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0411E0             0565*  ; outputs: values of each byte printed to screen separated by spaces
0411E0             0566*  ; destroys: nothing
0411E0             0567*  dumpMemoryBinRev:
0411E0             0568*  ; save all registers to the stack
0411E0 F5          0569*      push af
0411E1 C5          0570*      push bc
0411E2 D5          0571*      push de
0411E3 E5          0572*      push hl
0411E4 DD E5       0573*      push ix
0411E6 FD E5       0574*      push iy
0411E8             0575*  
0411E8             0576*  ; set b to be our loop counter
0411E8 47          0577*      ld b,a
0411E9             0578*  @loop:
0411E9             0579*  ; print the byte
0411E9 7E          0580*      ld a,(hl)
0411EA E5          0581*      push hl
0411EB C5          0582*      push bc
0411EC CD D5 0E 04 0583*      call printBin8Rev
0411F0 C1          0584*      pop bc
0411F1             0585*  ; print a space
0411F1 3E 20       0586*      ld a,' '
0411F3 5B D7       0587*      rst.lil 10h
0411F5 E1          0588*      pop hl
0411F6 23          0589*      inc hl
0411F7 10 F0       0590*      djnz @loop
0411F9 CD 08 0E 04 0591*      call printNewLine
0411FD             0592*  
0411FD             0593*  ; restore everything
0411FD FD E1       0594*      pop iy
0411FF DD E1       0595*      pop ix
041201 E1          0596*      pop hl
041202 D1          0597*      pop de
041203 C1          0598*      pop bc
041204 F1          0599*      pop af
041205             0600*  ; all done
041205 C9          0601*      ret
041206             0333   	include "pingo/src/asm/timer.asm"
041206             0001*  ; Table 32. Timer Control Registers
041206             0002*  ; this constant is the base address of the timer control registers
041206             0003*  ; each timer takes three bytes:
041206             0004*  ;   0: control register
041206             0005*  ;   1: low byte of timer reset value
041206             0006*  ;   2: high byte of timer reset value
041206             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
041206             0008*  ; which correctly force the high and upper bytes of the address bus to zero
041206             0009*  TMR_CTL:     equ 80h
041206             0010*  
041206             0011*  ; Timer Control Register Bit Definitions
041206             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
041206             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
041206             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
041206             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
041206             0016*                              ; the TMRx_CTL register is read.
041206             0017*  
041206             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
041206             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
041206             0020*  
041206             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
041206             0022*                              ;  0,and counting stops when the end-of-count value is reached.
041206             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
041206             0024*                              ; written to the counter when the end-of-count value is reached.
041206             0025*  
041206             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
041206             0027*  CLK_DIV_256:  equ %00001100 ;
041206             0028*  CLK_DIV_64:   equ %00001000 ;
041206             0029*  CLK_DIV_16:   equ %00000100 ;
041206             0030*  CLK_DIV_4:    equ %00000000 ;
041206             0031*  
041206             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
041206             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
041206             0034*                              ; When a 1 is written to this bit,the values in the reload registers
041206             0035*                              ;  are loaded into the downcounter when the timer restarts. The
041206             0036*                              ; programmer must ensure that this bit is set to 1 each time
041206             0037*                              ; SINGLE-PASS mode is used.
041206             0038*  
041206             0039*  ; disable/enable the programmable reload timer
041206             0040*  PRT_EN_0:     equ %00000000 ;
041206             0041*  PRT_EN_1:     equ %00000001 ;
041206             0042*  
041206             0043*  ; Table 37. Timer Input Source Select Register
041206             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
041206             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
041206             0046*  ;   00: System clock / CLK_DIV
041206             0047*  ;   01: RTC / CLK_DIV
041206             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
041206             0049*  ;   10: GPIO port B pin 1.
041206             0050*  ;   11: GPIO port B pin 1.
041206             0051*  TMR_ISS:   equ 92h ; register address
041206             0052*  
041206             0053*  ; Table 51. Real-Time Clock Control Register
041206             0054*  RTC_CTRL: equ EDh ; register address
041206             0055*  
041206             0056*  ; alarm interrupt disable/enable
041206             0057*  RTC_ALARM_0:    equ %00000000
041206             0058*  RTC_ALARM_1:    equ %10000000
041206             0059*  
041206             0060*  ; interrupt on alarm disable/enable
041206             0061*  RTC_INT_ENT_0:  equ %00000000
041206             0062*  RTC_INT_ENT_1:  equ %01000000
041206             0063*  
041206             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
041206             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
041206             0066*  
041206             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
041206             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
041206             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
041206             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
041206             0071*  
041206             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
041206             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
041206             0074*  
041206             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
041206             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
041206             0077*  
041206             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
041206             0079*                                  ; RTC counter is enabled.
041206             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
041206             0081*                                  ; RTC counter is disabled.
041206             0082*  
041206             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
041206             0084*  
041206             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
041206             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
041206 00 00 00    0087*  prt_reload: dl 0x000000
041209             0088*  
041209             0089*  ; set PRT timer
041209             0090*  prt_set:
041209 21 00 00 00 0091*      ld hl,0
04120D 22 57 12 04 0092*      ld (prt_irq_counter),hl
041211 2A 06 12 04 0093*      ld hl,(prt_reload)
041215 ED 29 84    0094*      out0 ($84),l
041218 ED 21 85    0095*  	out0 ($85),h
04121B             0096*  ; disable timer
04121B 3E 06       0097*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
04121D ED 39 83    0098*  	out0 ($83),a
041220             0099*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
041220 3E 57       0100*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
041222 ED 39 83    0101*  	out0 ($83),a
041225 C9          0102*      ret
041226             0103*  
041226             0104*  ; ===============================================
041226             0105*  ; PRT Timer Interrupt Handling
041226             0106*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
041226             0107*  ; -----------------------------------------------
041226             0108*  prt_irq_init:
041226             0109*      ; set up interrupt vector table 2
041226 21 00 00 00 0110*  	ld hl,0
04122A 3A 0C 01 00 0111*  	ld a,($10c)
04122E 6F          0112*  	ld l,a
04122F 3A 0D 01 00 0113*  	ld a,($10d)
041233 67          0114*  	ld h,a
041234             0115*  
041234             0116*  	; skip over CALL ($c3)
041234 23          0117*  	inc hl
041235             0118*  	; load address of jump into vector table 2 (in ram)
041235 ED 27       0119*  	ld hl,(hl)
041237             0120*  
041237             0121*  	; write CALL prt_irq_handler to vector table 2
041237 3E C3       0122*  	ld a,$c3
041239 77          0123*  	ld (hl),a
04123A 23          0124*  	inc hl
04123B 11 42 12 04 0125*  	ld de,prt_irq_handler
04123F ED 1F       0126*  	ld (hl),de
041241             0127*  
041241 C9          0128*      ret
041242             0129*  
041242             0130*  prt_irq_handler:
041242 F3          0131*  	di
041243 F5          0132*  	push af
041244 E5          0133*      push hl
041245 ED 38 83    0134*  	in0 a,($83)
041248 2A 57 12 04 0135*  	ld hl,(prt_irq_counter)
04124C 23          0136*  	inc hl
04124D 22 57 12 04 0137*  	ld (prt_irq_counter),hl
041251 E1          0138*      pop hl
041252 F1          0139*  	pop af
041253 FB          0140*  	ei
041254 5B ED 4D    0141*  	reti.l
041257             0142*  
041257             0143*  prt_irq_counter:
041257 00 00 00    0144*  	.dl 0
04125A             0145*  prt_irq_counter_saved:
04125A 00 00 00    0146*      .dl 0
04125D             0147*  
04125D             0148*  prt_loop_reset:
04125D E5          0149*      push hl
04125E 21 00 00 00 0150*  	ld hl,0
041262 22 57 12 04 0151*  	ld (prt_irq_counter),hl
041266 22 C8 12 04 0152*      ld (prt_loop_counter),hl
04126A 22 CB 12 04 0153*      ld (prt_loops),hl
04126E CD 09 12 04 0154*      call prt_set
041272 E1          0155*      pop hl
041273 C9          0156*      ret
041274             0157*  
041274             0158*  prt_loop_start:
041274 E5          0159*      push hl
041275 21 00 00 00 0160*  	ld hl,0
041279 22 57 12 04 0161*  	ld (prt_irq_counter),hl
04127D E1          0162*      pop hl
04127E C9          0163*      ret
04127F             0164*  
04127F             0165*  prt_loop_stop:
04127F E5          0166*      push hl
041280 D5          0167*      push de
041281 2A 57 12 04 0168*      ld hl,(prt_irq_counter)
041285 ED 5B C8 12 0169*      ld de,(prt_loop_counter)
       04          
04128A 19          0170*      add hl,de
04128B 22 C8 12 04 0171*      ld (prt_loop_counter),hl
04128F 21 00 00 00 0172*      ld hl,0
041293 22 57 12 04 0173*      ld (prt_irq_counter),hl
041297 2A CB 12 04 0174*      ld hl,(prt_loops)
04129B 23          0175*      inc hl
04129C 22 CB 12 04 0176*      ld (prt_loops),hl
0412A0 D1          0177*      pop de
0412A1 E1          0178*      pop hl
0412A2 C9          0179*      ret
0412A3             0180*  
0412A3             0181*  ; inputs: bc = y,x text coordinates to print
0412A3             0182*  prt_loop_print:
0412A3 F5          0183*      push af
0412A4 E5          0184*      push hl
0412A5 C5          0185*      push bc
0412A6 D5          0186*      push de
0412A7 DD E5       0187*      push ix
0412A9 FD E5       0188*      push iy
0412AB CD EC 04 04 0189*      call vdu_move_cursor
0412AF             0190*  
0412AF 2A C8 12 04 0191*      ld hl,(prt_loop_counter)
0412B3 CD 41 0E 04 0192*      call printDec
0412B7             0193*  
0412B7 2A CB 12 04 0194*      ld hl,(prt_loops)
0412BB CD 41 0E 04 0195*      call printDec
0412BF             0196*  
0412BF FD E1       0197*      pop iy
0412C1 DD E1       0198*      pop ix
0412C3 D1          0199*      pop de
0412C4 C1          0200*      pop bc
0412C5 E1          0201*      pop hl
0412C6 F1          0202*      pop af
0412C7 C9          0203*      ret
0412C8             0204*  
0412C8             0205*  prt_loop_counter:
0412C8 00 00 00    0206*      .dl 0
0412CB             0207*  prt_loops:
0412CB 00 00 00    0208*      .dl 0
0412CE             0209*  
0412CE             0210*  ; ===============================================
0412CE             0211*  ; Timer functions
0412CE             0212*  ; -----------------------------------------------
0412CE             0213*  ; set a countdown timer
0412CE             0214*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0412CE             0215*  ; returns: hl = current time
0412CE             0216*  tmr_set:
0412CE FD 2F 03    0217*      ld (iy+3),hl            ; set time remaining
0412D1             0218*      MOSCALL mos_sysvars     ; ix points to syvars table
0412D1 3E 08       0001*M 			LD	A, function
0412D3 5B CF       0002*M 			RST.LIL	08h
0412D5 DD 27 00    0219*      ld hl,(ix+sysvar_time)  ; get current time
0412D8 FD 2F 00    0220*      ld (iy+0),hl            ; set start time
0412DB C9          0221*      ret
0412DC             0222*  
0412DC             0223*  ; gets time remaining on a countdown timer
0412DC             0224*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0412DC             0225*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0412DC             0226*  ;          sign flags: pos = time not expired,zero or neg = time expired
0412DC             0227*  tmr_get:
0412DC             0228*      MOSCALL mos_sysvars     ; ix points to syvars table
0412DC 3E 08       0001*M 			LD	A, function
0412DE 5B CF       0002*M 			RST.LIL	08h
0412E0 DD 17 00    0229*      ld de,(ix+sysvar_time)  ; get current time
0412E3 FD 27 00    0230*      ld hl,(iy+0)            ; get start time
0412E6 AF          0231*      xor a                   ; clear carry
0412E7 ED 52       0232*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0412E9 FD 17 03    0233*      ld de,(iy+3)            ; get timer set value
0412EC AF          0234*      xor a                   ; clear carry
0412ED ED 5A       0235*      adc hl,de               ; hl = time remaining
0412EF             0236*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0412EF C9          0237*      ret
0412F0             0238*  
0412F0             0239*  tmr_test: ds 6 ; example of a buffer to hold timer data
0412F6             0240*  
0412F6 00 00 00    0241*  timestamp_now: dl 0
0412F9 00 00 00    0242*  timestamp_old: dl 0
0412FC 00 00 00    0243*  timestamp_chg: dl 0
0412FF             0244*  
0412FF             0245*  ; update the global timestamp from the system clock
0412FF             0246*  ; inputs: none
0412FF             0247*  ; returns: hl = time elapsed in 1/120ths of a second
0412FF             0248*  ;          de = current time
0412FF             0249*  ;          ix = pointer to syvars table
0412FF             0250*  ; destroys: af,hl,de,ix
0412FF             0251*  timestamp_tick:
0412FF ED 5B F6 12 0252*      ld de,(timestamp_now)   ; get previous time
       04          
041304 ED 53 F9 12 0253*      ld (timestamp_old),de   ; save previous time
       04          
041309             0254*      MOSCALL mos_sysvars     ; ix points to syvars table
041309 3E 08       0001*M 			LD	A, function
04130B 5B CF       0002*M 			RST.LIL	08h
04130D DD 27 00    0255*      ld hl,(ix+sysvar_time)  ; get current time
041310 22 F6 12 04 0256*      ld (timestamp_now),hl   ; save current time
041314 AF          0257*      xor a                   ; clear carry
041315 ED 52       0258*      sbc hl,de               ; hl = time elapsed
041317 22 FC 12 04 0259*      ld (timestamp_chg),hl   ; save elapsed time
04131B C9          0260*      ret
04131C             0261*  
04131C             0262*  ; set a countdown timer
04131C             0263*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04131C             0264*  ; requires: timestamp_tick to be called at least once before this function
04131C             0265*  ; returns: hl = current time
04131C             0266*  ; destroys: hl
04131C             0267*  timestamp_tmr_set:
04131C FD 2F 03    0268*      ld (iy+3),hl            ; set time remaining
04131F 2A F6 12 04 0269*      ld hl,(timestamp_now)   ; get current timestamp
041323 FD 2F 00    0270*      ld (iy+0),hl            ; set start time
041326 C9          0271*      ret
041327             0272*  
041327             0273*  ; gets time remaining on a countdown timer following the global timestamp
041327             0274*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041327             0275*  ; requires: timestamp_tick to be called at least once before this function
041327             0276*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
041327             0277*  ;          sign flags: pos = time not expired,zero or neg = time expired
041327             0278*  ; destroys: af,hl,de
041327             0279*  timestamp_tmr_get:
041327 ED 5B F6 12 0280*      ld de,(timestamp_now)   ; get current timestamp
       04          
04132C FD 27 00    0281*      ld hl,(iy+0)            ; get start time
04132F AF          0282*      xor a                   ; clear carry
041330 ED 52       0283*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
041332 FD 17 03    0284*      ld de,(iy+3)            ; get timer set value
041335 AF          0285*      xor a                   ; clear carry
041336 ED 5A       0286*      adc hl,de               ; hl = time remaining
041338             0287*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
041338 C9          0288*      ret
041339             0289*  
041339             0290*  ; set a stopwatch
041339             0291*  ; returns: hl = start time
041339             0292*  ; destroys: hl,ix
041339             0293*  stopwatch_set:
041339             0294*      MOSCALL mos_sysvars     ; ix points to syvars table
041339 3E 08       0001*M 			LD	A, function
04133B 5B CF       0002*M 			RST.LIL	08h
04133D DD 27 00    0295*      ld hl,(ix+sysvar_time)  ; get current time
041340 22 55 13 04 0296*      ld (stopwatch_started),hl            ; set start time
041344 C9          0297*      ret
041345             0298*  
041345             0299*  ; gets time elapsed on a stopwatch
041345             0300*  ; returns: hl = time elapsed in 1/120ths of a second
041345             0301*  ; destroys: af,hl,de,ix
041345             0302*  stopwatch_get:
041345             0303*      MOSCALL mos_sysvars     ; ix points to syvars table
041345 3E 08       0001*M 			LD	A, function
041347 5B CF       0002*M 			RST.LIL	08h
041349 DD 27 00    0304*      ld hl,(ix+sysvar_time)  ; get current time
04134C ED 5B 55 13 0305*      ld de,(stopwatch_started)            ; get start time
       04          
041351 AF          0306*      xor a                   ; clear carry
041352 ED 52       0307*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
041354 C9          0308*      ret
041355             0309*  
041355             0310*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
041358             0311*  
041358             0312*  ; ------------------
041358             0313*  ; delay routine
041358             0314*  ; Author: Richard Turrnidge
041358             0315*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.asm
041358             0316*  ; routine waits a fixed time,then returns
041358             0317*  ; arrive with A =  the delay byte. One bit to be set only.
041358             0318*  ; eg. ld A,00000100b
041358             0319*  
041358             0320*  multiPurposeDelay:
041358 F5          0321*      push af
041359 C5          0322*      push bc
04135A DD E5       0323*      push ix
04135C 47          0324*      ld b,a
04135D 3E 08       0325*      ld a,$08
04135F 5B CF       0326*      RST.LIL	08h                 ; get IX pointer to sysvars
041361             0327*  
041361             0328*  waitLoop:
041361             0329*  
041361 DD 7E 00    0330*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
041364             0331*  
041364             0332*                                  ;   we check if bit set is same as last time we checked.
041364             0333*                                  ;   bit 0 - don't use
041364             0334*                                  ;   bit 1 - changes 64 times per second
041364             0335*                                  ;   bit 2 - changes 32 times per second
041364             0336*                                  ;   bit 3 - changes 16 times per second
041364             0337*  
041364             0338*                                  ;   bit 4 - changes 8 times per second
041364             0339*                                  ;   bit 5 - changes 4 times per second
041364             0340*                                  ;   bit 6 - changes 2 times per second
041364             0341*                                  ;   bit 7 - changes 1 times per second
041364 A0          0342*      and b
041365 4F          0343*      ld c,a
041366 3A 77 13 04 0344*      ld a,(oldTimeStamp)
04136A B9          0345*      cp c                        ; is A same as last value?
04136B 28 F4       0346*      jr z,waitLoop              ; loop here if it is
04136D 79          0347*      ld a,c
04136E 32 77 13 04 0348*      ld (oldTimeStamp),a        ; set new value
041372             0349*  
041372 DD E1       0350*      pop ix
041374 C1          0351*      pop bc
041375 F1          0352*      pop af
041376 C9          0353*      ret
041377             0354*  
041377 00          0355*  oldTimeStamp:   .db 00h
041378             0334   
041378 57 65 6C 63 0335   str_hello_world: db "Welcome to the Pingo 3D Demo!\r\n",0
       6F 6D 65 20 
       74 6F 20 74 
       68 65 20 50 
       69 6E 67 6F 
       20 33 44 20 
       44 65 6D 6F 
       21 0D 0A 00 
041398 43 72 65 61 0336   str_create_object: db "Creating 3D object.\r\n",0
       74 69 6E 67 
       20 33 44 20 
       6F 62 6A 65 
       63 74 2E 0D 
       0A 00       
0413AE 53 63 61 6C 0337   str_scale_object: db "Scaling object.\r\n",0
       69 6E 67 20 
       6F 62 6A 65 
       63 74 2E 0D 
       0A 00       
0413C0 43 72 65 61 0338   str_create_target_bitmap: db "Creating target bitmap.\r\n",0
       74 69 6E 67 
       20 74 61 72 
       67 65 74 20 
       62 69 74 6D 
       61 70 2E 0D 
       0A 00       
0413DA 53 65 74 74 0339   str_set_texture_pixel: db "Setting texture pixel.\r\n",0
       69 6E 67 20 
       74 65 78 74 
       75 72 65 20 
       70 69 78 65 
       6C 2E 0D 0A 
       00          
0413F3 43 72 65 61 0340   str_create_texture_bitmap: db "Creating texture bitmap.\r\n",0
       74 69 6E 67 
       20 74 65 78 
       74 75 72 65 
       20 62 69 74 
       6D 61 70 2E 
       0D 0A 00    
04140E 53 65 6E 64 0341   str_zeroes: db "Sending some magic zeroes.\r\n",0
       69 6E 67 20 
       73 6F 6D 65 
       20 6D 61 67 
       69 63 20 7A 
       65 72 6F 65 
       73 2E 0D 0A 
       00          
04142B 53 65 74 74 0342   str_set_tex_coord_idxs: db "Setting texture coordinate indices.\r\n",0
       69 6E 67 20 
       74 65 78 74 
       75 72 65 20 
       63 6F 6F 72 
       64 69 6E 61 
       74 65 20 69 
       6E 64 69 63 
       65 73 2E 0D 
       0A 00       
041451 53 65 6E 64 0343   str_set_texture_coordinates: db "Sending texture coordinates.\r\n",0
       69 6E 67 20 
       74 65 78 74 
       75 72 65 20 
       63 6F 6F 72 
       64 69 6E 61 
       74 65 73 2E 
       0D 0A 00    
041470 53 65 6E 64 0344   str_set_mesh_vertex_indexes: db "Sending vertex indexes.\r\n",0
       69 6E 67 20 
       76 65 72 74 
       65 78 20 69 
       6E 64 65 78 
       65 73 2E 0D 
       0A 00       
04148A 53 65 6E 64 0345   str_send_vertices: db "Sending vertices.\r\n",0
       69 6E 67 20 
       76 65 72 74 
       69 63 65 73 
       2E 0D 0A 00 
04149E 53 65 74 74 0346   str_set_camera_x_rotation: db "Setting camera X rotation.\r\n",0
       69 6E 67 20 
       63 61 6D 65 
       72 61 20 58 
       20 72 6F 74 
       61 74 69 6F 
       6E 2E 0D 0A 
       00          
0414BB 53 65 74 74 0347   str_set_camera_distance: db "Setting camera distance.\r\n",0
       69 6E 67 20 
       63 61 6D 65 
       72 61 20 64 
       69 73 74 61 
       6E 63 65 2E 
       0D 0A 00    
0414D6 43 72 65 61 0348   str_create_control: db "Creating control structure.\r\n",0
       74 69 6E 67 
       20 63 6F 6E 
       74 72 6F 6C 
       20 73 74 72 
       75 63 74 75 
       72 65 2E 0D 
       0A 00       
0414F4 49 6E 69 74 0349   str_init_cmplt: db "Initialization complete.\r\n",0
       69 61 6C 69 
       7A 61 74 69 
       6F 6E 20 63 
       6F 6D 70 6C 
       65 74 65 2E 
       0D 0A 00    
