PC     Output      Line
040000             0001       include "pingo/src/asm/mos_api.asm"
040000             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.asm
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
040000             0005*  ;			Added MOS error codes for return in HL
040000             0006*  ; Created:	03/08/2022
040000             0007*  ; Last Updated:	10/08/2023
040000             0008*  ;
040000             0009*  ; Modinfo:
040000             0010*  ; 05/08/2022:	Added mos_feof
040000             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0015*  ; 13/10/2022:	Added mos_oscli
040000             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0025*  ; 19/05/2023:	Added sysvar_scrMode
040000             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0027*  ; 03/08/2023:	Added mos_setkbvector
040000             0028*  ; 10/08/2023:	Added mos_getkbmap
040000             0029*  
040000             0030*  ; VDP control (VDU 23, 0, n)
040000             0031*  ;
040000             0032*  vdp_gp:				EQU 80h
040000             0033*  vdp_keycode:		EQU 81h
040000             0034*  vdp_cursor:			EQU	82h
040000             0035*  vdp_scrchar:		EQU	83h
040000             0036*  vdp_scrpixel:		EQU	84h
040000             0037*  vdp_audio:			EQU	85h
040000             0038*  vdp_mode:			EQU	86h
040000             0039*  vdp_rtc:			EQU	87h
040000             0040*  vdp_keystate:		EQU	88h
040000             0041*  vdp_logicalcoords:	EQU	C0h
040000             0042*  vdp_terminalmode:	EQU	FFh
040000             0043*  
040000             0044*  ; MOS high level functions
040000             0045*  ;
040000             0046*  mos_getkey:			EQU	00h
040000             0047*  mos_load:			EQU	01h
040000             0048*  mos_save:			EQU	02h
040000             0049*  mos_cd:				EQU	03h
040000             0050*  mos_dir:			EQU	04h
040000             0051*  mos_del:			EQU	05h
040000             0052*  mos_ren:			EQU	06h
040000             0053*  mos_mkdir:			EQU	07h
040000             0054*  mos_sysvars:		EQU	08h
040000             0055*  mos_editline:		EQU	09h
040000             0056*  mos_fopen:			EQU	0Ah
040000             0057*  mos_fclose:			EQU	0Bh
040000             0058*  mos_fgetc:			EQU	0Ch
040000             0059*  mos_fputc:			EQU	0Dh
040000             0060*  mos_feof:			EQU	0Eh
040000             0061*  mos_getError:		EQU	0Fh
040000             0062*  mos_oscli:			EQU	10h
040000             0063*  mos_copy:			EQU	11h
040000             0064*  mos_getrtc:			EQU	12h
040000             0065*  mos_setrtc:			EQU	13h
040000             0066*  mos_setintvector:	EQU	14h
040000             0067*  mos_uopen:			EQU	15h
040000             0068*  mos_uclose:			EQU	16h
040000             0069*  mos_ugetc:			EQU	17h
040000             0070*  mos_uputc:			EQU	18h
040000             0071*  mos_getfil:			EQU	19h
040000             0072*  mos_fread:			EQU	1Ah
040000             0073*  mos_fwrite:			EQU	1Bh
040000             0074*  mos_flseek:			EQU	1Ch
040000             0075*  mos_setkbvector:	EQU	1Dh
040000             0076*  mos_getkbmap:		EQU	1Eh
040000             0077*  
040000             0078*  ; MOS program exit codes
040000             0079*  ;
040000             0080*  EXIT_OK:				EQU  0;	"OK",
040000             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040000             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040000             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040000             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040000             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040000             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040000             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040000             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040000             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040000             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040000             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040000             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040000             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040000             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040000             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040000             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040000             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040000             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040000             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040000             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040000             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040000             0102*  ; FatFS file access functions
040000             0103*  ;
040000             0104*  ffs_fopen:			EQU	80h
040000             0105*  ffs_fclose:			EQU	81h
040000             0106*  ffs_fread:			EQU	82h
040000             0107*  ffs_fwrite:			EQU	83h
040000             0108*  ffs_flseek:			EQU	84h
040000             0109*  ffs_ftruncate:		EQU	85h
040000             0110*  ffs_fsync:			EQU	86h
040000             0111*  ffs_fforward:		EQU	87h
040000             0112*  ffs_fexpand:		EQU	88h
040000             0113*  ffs_fgets:			EQU	89h
040000             0114*  ffs_fputc:			EQU	8Ah
040000             0115*  ffs_fputs:			EQU	8Bh
040000             0116*  ffs_fprintf:		EQU	8Ch
040000             0117*  ffs_ftell:			EQU	8Dh
040000             0118*  ffs_feof:			EQU	8Eh
040000             0119*  ffs_fsize:			EQU	8Fh
040000             0120*  ffs_ferror:			EQU	90h
040000             0121*  
040000             0122*  ; FatFS directory access functions
040000             0123*  ;
040000             0124*  ffs_dopen:			EQU	91h
040000             0125*  ffs_dclose:			EQU	92h
040000             0126*  ffs_dread:			EQU	93h
040000             0127*  ffs_dfindfirst:		EQU	94h
040000             0128*  ffs_dfindnext:		EQU	95h
040000             0129*  
040000             0130*  ; FatFS file and directory management functions
040000             0131*  ;
040000             0132*  ffs_stat:			EQU	96h
040000             0133*  ffs_unlink:			EQU	97h
040000             0134*  ffs_rename:			EQU	98h
040000             0135*  ffs_chmod:			EQU	99h
040000             0136*  ffs_utime:			EQU	9Ah
040000             0137*  ffs_mkdir:			EQU	9Bh
040000             0138*  ffs_chdir:			EQU	9Ch
040000             0139*  ffs_chdrive:		EQU	9Dh
040000             0140*  ffs_getcwd:			EQU	9Eh
040000             0141*  
040000             0142*  ; FatFS volume management and system configuration functions
040000             0143*  ;
040000             0144*  ffs_mount:			EQU	9Fh
040000             0145*  ffs_mkfs:			EQU	A0h
040000             0146*  ffs_fdisk:			EQU	A1h
040000             0147*  ffs_getfree:		EQU	A2h
040000             0148*  ffs_getlabel:		EQU	A3h
040000             0149*  ffs_setlabel:		EQU	A4h
040000             0150*  ffs_setcp:			EQU	A5h
040000             0151*  
040000             0152*  ; File access modes
040000             0153*  ;
040000             0154*  fa_read:			EQU	01h
040000             0155*  fa_write:			EQU	02h
040000             0156*  fa_open_existing:	EQU	00h
040000             0157*  fa_create_new:		EQU	04h
040000             0158*  fa_create_always:	EQU	08h
040000             0159*  fa_open_always:		EQU	10h
040000             0160*  fa_open_append:		EQU	30h
040000             0161*  
040000             0162*  ; System variable indexes for api_sysvars
040000             0163*  ; Index into _sysvars in globals.asm
040000             0164*  ;
040000             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040000             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040000             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040000             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040000             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040000             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040000             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040000             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040000             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040000             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040000             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040000             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040000             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040000             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040000             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040000             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040000             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
040000             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0191*  
040000             0192*  ; Flags for the VPD protocol
040000             0193*  ;
040000             0194*  vdp_pflag_cursor:		EQU	00000001b
040000             0195*  vdp_pflag_scrchar:		EQU	00000010b
040000             0196*  vdp_pflag_point:		EQU	00000100b
040000             0197*  vdp_pflag_audio:		EQU	00001000b
040000             0198*  vdp_pflag_mode:			EQU	00010000b
040000             0199*  vdp_pflag_rtc:			EQU	00100000b
040000             0200*  
040000             0201*  ;
040000             0202*  ; FatFS structures
040000             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0204*  ;
040000             0205*  ; Object ID and allocation information (FFOBJID)
040000             0206*  ;
040000             0207*  ; Indexes into FFOBJID structure
040000             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040000             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040000             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
040000             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040000             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040000             0214*  ;
040000             0215*  ; File object structure (FIL)
040000             0216*  ;
040000             0217*  ; Indexes into FIL structure
040000             0218*  fil_obj:		EQU 0	; 15: Object identifier
040000             0219*  fil_flag:		EQU	15 	;  1: File status flags
040000             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
040000             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040000             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040000             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040000             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040000             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040000             0226*  ;
040000             0227*  ; Directory object structure (DIR)
040000             0228*  ; Indexes into DIR structure
040000             0229*  dir_obj:		EQU  0	; 15: Object identifier
040000             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
040000             0231*  dir_clust:		EQU	19	;  4: Current cluster
040000             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040000             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040000             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040000             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0236*  ;
040000             0237*  ; File information structure (FILINFO)
040000             0238*  ;
040000             0239*  ; Indexes into FILINFO structure
040000             0240*  filinfo_fsize:		EQU 0	;   4: File size
040000             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
040000             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
040000             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
040000             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
040000             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
040000             0246*  ;
040000             0247*  ; Macro for calling the API
040000             0248*  ; Parameters:
040000             0249*  ; - function: One of the function numbers listed above
040000             0250*  ;
040000             0251*  	MACRO	MOSCALL	function
040000             0252*  			LD	A, function
040000             0253*  			RST.LIL	08h
040000             0254*  	ENDMACRO
040000             0002   
040000             0003       .assume adl=1
040000             0004       .org 0x040000
040000             0005   
040000 C3 45 00 04 0006       jp start
040004             0007   
040004 FF FF FF FF 0008       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0009       .db "MOS"
040043 00          0010       .db 00h
040044 01          0011       .db 01h
040045             0012   
040045             0013   start:
040045 F5          0014       push af
040046 C5          0015       push bc
040047 D5          0016       push de
040048 DD E5       0017       push ix
04004A FD E5       0018       push iy
04004C             0019   
04004C CD 5C 00 04 0020       call main
040050             0021   
040050             0022   exit:
040050             0023       ; ld hl,str_program_end
040050             0024       ; call printString
040050             0025   
040050 FD E1       0026       pop iy
040052 DD E1       0027       pop ix
040054 D1          0028       pop de
040055 C1          0029       pop bc
040056 F1          0030       pop af
040057 21 00 00 00 0031       ld hl,0
04005B             0032   
04005B C9          0033       ret
04005C             0034   
04005C             0035   main:
04005C 3E 08       0036       ld a,8
04005E CD 2D 03 04 0037       call vdu_set_screen_mode
040062             0038   
040062 AF          0039       xor a
040063 CD 5C 04 04 0040       call vdu_set_scaling
040067             0041       ; ld hl,str_hello_world
040067             0042       ; call printString
040067             0043   
040067             0044   ;   210 sid%=100: mid%=1: oid%=1: bmid1%=101: bmid2%=102
040067             0045   sid: equ 100
040067             0046   mid: equ 1
040067             0047   oid: equ 1
040067             0048   bmid1: equ 101
040067             0049   bmid2: equ 102
040067             0050   
040067             0051   ;   230 scene_width%=320: scene_height%=240
040067             0052   scene_width: equ 320
040067             0053   scene_height: equ 240
040067             0054   
040067             0055   ;   250 f=32767.0/256.0
040067             0056   ;   260 distx=0*f: disty=0*f: distz=-25*f
040067             0057   cam_f: equ 128 ; 32767/256
040067             0058   cam_distx: equ 0*cam_f
040067             0059   cam_disty: equ 0*cam_f
040067             0060   cam_distz: equ -4*cam_f
040067             0061   
040067             0062   ;   280 pi2=PI*2.0: f=32767.0/pi2
040067             0063   ;   290 anglex=0.0*f
040067             0064   cam_anglex: equ 0
040067             0065   
040067             0066   ;   220 PRINT "Creating control structure"
040067             0067       ; ld hl,str_create_control
040067             0068       ; call printString
040067             0069   ccs:
040067 21 75 00 04 0070       ld hl,@beg
04006B 01 0B 00 00 0071       ld bc,@end-@beg
04006F 5B DF       0072       rst.lil $18
040071 C3 80 00 04 0073       jp @end
040075             0074   @beg:
040075             0075   ;   240 VDU 23,0, &A0, sid%; &49, 0, scene_width%; scene_height%; : REM Create Control Structure
040075 17 00 A0    0076       db 23,0,$A0
040078 64 00       0077       dw sid
04007A 49 00       0078       db $49,0
04007C 40 01       0079       dw scene_width
04007E F0 00       0080       dw scene_height
040080             0081   @end:
040080             0082   
040080             0083   ; set camera distance
040080             0084       ; ld hl,str_set_camera_distance
040080             0085       ; call printString
040080             0086   scd:
040080 21 8E 00 04 0087       ld hl,@beg
040084 01 0D 00 00 0088       ld bc,@end-@beg
040088 5B DF       0089       rst.lil $18
04008A C3 9B 00 04 0090       jp @end
04008E             0091   @beg:
04008E             0092   ;   270 VDU 23,0, &A0, sid%; &49, 25, distx; disty; distz; : REM Set Camera XYZ Translation Distances
04008E 17 00 A0    0093       db 23,0,$A0
040091 64 00       0094       dw sid
040093 49 19       0095       db $49,25
040095 00 00       0096       dw cam_distx
040097 00 00       0097       dw cam_disty
040099 00 FE       0098       dw cam_distz
04009B             0099   @end:
04009B             0100   
04009B             0101   ; set camera x rotation
04009B             0102       ; ld hl,str_set_camera_x_rotation
04009B             0103       ; call printString
04009B             0104   scxr:
04009B 21 A9 00 04 0105       ld hl,@beg
04009F 01 09 00 00 0106       ld bc,@end-@beg
0400A3 5B DF       0107       rst.lil $18
0400A5 C3 B2 00 04 0108       jp @end
0400A9             0109   @beg:
0400A9             0110   ;   300 VDU 23,0, &A0, sid%; &49, 18, anglex; : REM Set Camera X Rotation Angle
0400A9 17 00 A0    0111       db 23,0,$A0
0400AC 64 00       0112       dw sid
0400AE 49 12       0113       db $49,18
0400B0 00 00       0114       dw cam_anglex
0400B2             0115   @end:
0400B2             0116   
0400B2             0117   ;   620 PRINT "Create target bitmap"
0400B2             0118       ; ld hl,str_create_target_bitmap
0400B2             0119       ; call printString
0400B2             0120   ctb2:
0400B2 21 C0 00 04 0121       ld hl,@beg
0400B6 01 10 00 00 0122       ld bc,@end-@beg
0400BA 5B DF       0123       rst.lil $18
0400BC C3 D0 00 04 0124       jp @end
0400C0             0125   @beg:
0400C0             0126   ;   630 VDU 23, 27, 0, bmid2% : REM Select output bitmap
0400C0 17 1B 00    0127       db 23,27,0
0400C3 66 00       0128       dw bmid2
0400C5             0129   ;   640 VDU 23, 27, 2, scene_width%; scene_height%; &0000; &00C0; : REM Create solid color bitmap
0400C5 17 1B 02    0130       db 23,27,2
0400C8 40 01       0131       dw scene_width
0400CA F0 00       0132       dw scene_height
0400CC 00 00       0133       dw $0000
0400CE C0 00       0134       dw $00C0
0400D0             0135   @end:
0400D0             0136   
0400D0             0137       ; ld hl,str_init_cmplt
0400D0             0138       ; call printString
0400D0             0139   
0400D0             0140   model_vertices: equ 4
0400D0             0141   model_indexes: equ 4
0400D0             0142   model_uvs: equ 10
0400D0             0143   obj_scale: equ 256
0400D0             0144   
0400D0             0145   ;   310 PRINT "Sending vertices using factor ";factor
0400D0             0146       ; ld hl,str_send_vertices
0400D0             0147       ; call printString
0400D0             0148   sv:
0400D0 21 DE 00 04 0149       ld hl,@beg
0400D4 01 23 00 00 0150       ld bc,@end-@beg
0400D8 5B DF       0151       rst.lil $18
0400DA C3 01 01 04 0152       jp @end
0400DE             0153   @beg:
0400DE             0154   ;   320 VDU 23,0, &A0, sid%; &49, 1, mid%; model_vertices%; : REM Define Mesh Vertices
0400DE 17 00 A0    0155       db 23,0,$A0
0400E1 64 00       0156       dw sid
0400E3 49 01       0157       db $49,1
0400E5 01 00 04 00 0158       dw mid, model_vertices
0400E9 00 00 00 00 0159   	dw 0, 0, 0
       00 00       
0400EF 00 00 01 80 0160   	dw 0, -32767, 0
       00 00       
0400F5 00 00 00 00 0161   	dw 0, 0, -32767
       01 80       
0400FB FF 7F 00 00 0162   	dw 32767, 0, 0
       00 00       
040101             0163   @end:
040101             0164   
040101             0165   ;   390 PRINT "Reading and sending vertex indexes"
040101             0166       ; ld hl,str_set_mesh_vertex_indexes
040101             0167       ; call printString
040101             0168   smvi:
040101 21 0F 01 04 0169       ld hl,@beg
040105 01 23 00 00 0170       ld bc,@end-@beg
040109 5B DF       0171       rst.lil $18
04010B C3 32 01 04 0172       jp @end
04010F             0173   @beg:
04010F             0174   ;   400 VDU 23,0, &A0, sid%; &49, 2, mid%; model_indexes%; : REM Set Mesh Vertex Indexes
04010F 17 00 A0    0175       db 23,0,$A0
040112 64 00       0176       dw sid
040114 49 02       0177       db $49,2
040116 01 00 04 00 0178       dw mid, model_indexes
04011A 00 00 02 00 0179   	dw 0, 2, 1
       01 00       
040120 00 00 03 00 0180   	dw 0, 3, 2
       02 00       
040126 01 00 03 00 0181   	dw 1, 3, 0
       00 00       
04012C 03 00 01 00 0182   	dw 3, 1, 2
       02 00       
040132             0183   @end:
040132             0184   
040132             0185   ;   470 PRINT "Sending texture coordinate indexes"
040132             0186       ; ld hl,str_set_texture_coordinates
040132             0187       ; call printString
040132             0188   stc:
040132 21 40 01 04 0189       ld hl,@beg
040136 01 33 00 00 0190       ld bc,@end-@beg
04013A 5B DF       0191       rst.lil $18
04013C C3 73 01 04 0192       jp @end
040140             0193   @beg:
040140             0194   ;   480 VDU 23,0, &A0, sid%; &49, 3, mid%; 1; 32767; 32767; : REM Define Texture Coordinates
040140 17 00 A0    0195       db 23,0,$A0
040143 64 00       0196       dw sid
040145 49 03       0197       db $49,3
040147 01 00 0A 00 0198       dw mid, model_uvs
04014B 00 00 9C 7F 0199   	dw 0, 32668
04014F 9C 7F 00 00 0200   	dw 32668, 0
040153 9C 7F 9C 7F 0201   	dw 32668, 32668
040157 37 FF 9C 7F 0202   	dw 65335, 32668
04015B 9C 7F 37 FF 0203   	dw 32668, 65335
04015F 9C 7F 9C 7F 0204   	dw 32668, 32668
040163 9C 7F 00 00 0205   	dw 32668, 0
040167 37 FF 9C 7F 0206   	dw 65335, 32668
04016B 9C 7F 9C 7F 0207   	dw 32668, 32668
04016F 00 00 9C 7F 0208   	dw 0, 32668
040173             0209   @end:
040173             0210   
040173             0211       ; ld hl,str_set_tex_coord_idxs
040173             0212       ; call printString
040173             0213   stci:
040173 21 81 01 04 0214       ld hl,@beg
040177 01 23 00 00 0215       ld bc,@end-@beg
04017B 5B DF       0216       rst.lil $18
04017D C3 A4 01 04 0217       jp @end
040181             0218   @beg:
040181             0219   ;   490 VDU 23,0, &A0, sid%; &49, 4, mid%; model_indexes%; : REM Set Texture Coordinate Indexes
040181 17 00 A0    0220       db 23,0,$A0
040184 64 00       0221       dw sid
040186 49 04       0222       db $49,4
040188 01 00 04 00 0223       dw mid, model_indexes
04018C 00 00 01 00 0224   	dw 0, 1, 2
       02 00       
040192 03 00 04 00 0225   	dw 3, 4, 5
       05 00       
040198 06 00 07 00 0226   	dw 6, 7, 8
       08 00       
04019E 04 00 09 00 0227   	dw 4, 9, 5
       05 00       
0401A4             0228   @end:
0401A4             0229   
0401A4             0230   ;   530 PRINT "Creating texture bitmap"
0401A4             0231       ; ld hl,str_create_texture_bitmap
0401A4             0232       ; call printString
0401A4             0233   ctb:
0401A4 21 B2 01 04 0234       ld hl,@beg
0401A8 01 05 00 00 0235       ld bc,@end-@beg
0401AC 5B DF       0236       rst.lil $18
0401AE C3 B7 01 04 0237       jp @end
0401B2             0238   @beg:
0401B2             0239   ;   540 VDU 23, 27, 0, bmid1%: REM Create a bitmap for a texture
0401B2 17 1B 00    0240       db 23,27,0
0401B5 65 00       0241       dw bmid1
0401B7             0242   @end:
0401B7             0243   
0401B7             0244   ;   550 PRINT "Setting texture pixel"
0401B7             0245       ; ld hl,str_set_texture_pixel
0401B7             0246       ; call printString
0401B7             0247   stp:
0401B7 21 C5 01 04 0248       ld hl,@beg
0401BB 01 17 00 00 0249       ld bc,@end-@beg
0401BF 5B DF       0250       rst.lil $18
0401C1 C3 DC 01 04 0251       jp @end
0401C5             0252   @beg:
0401C5             0253   ;   560 VDU 23, 27, 1, 1; 1; &55, &AA, &FF, &C0 : REM Set a pixel in the bitmap
0401C5 17 1B 01    0254       db 23,27,1
0401C8 02 00       0255   @texture_width: dw 2
0401CA 02 00       0256   @texture_height: dw 2
0401CC FF 00 00 FF 0257   	db 255,0,0,255,0,0,255,255,255,255,0,255,0,255,0,255
       00 00 FF FF 
       FF FF 00 FF 
       00 FF 00 FF 
0401DC             0258   @end:
0401DC             0259   
0401DC             0260   ;   570 PRINT "Create 3D object"
0401DC             0261       ; ld hl,str_create_object
0401DC             0262       ; call printString
0401DC             0263   co:
0401DC 21 EA 01 04 0264       ld hl,@beg
0401E0 01 0D 00 00 0265       ld bc,@end-@beg
0401E4 5B DF       0266       rst.lil $18
0401E6 C3 F7 01 04 0267       jp @end
0401EA             0268   @beg:
0401EA             0269   ;   580 VDU 23,0, &A0, sid%; &49, 5, oid%; mid%; bmid1%+64000; : REM Create Object
0401EA 17 00 A0    0270       db 23,0,$A0
0401ED 64 00       0271       dw sid
0401EF 49 05       0272       db $49,5
0401F1 01 00       0273       dw oid
0401F3 01 00       0274       dw mid
0401F5 65 FA       0275       dw bmid1+64000
0401F7             0276   @end:
0401F7             0277   
0401F7             0278   ;   590 PRINT "Scale object"
0401F7             0279       ; ld hl,str_scale_object
0401F7             0280       ; call printString
0401F7             0281   so:
0401F7             0282   ;   600 scale=1.0*256.0
0401F7 21 05 02 04 0283       ld hl,@beg
0401FB 01 0F 00 00 0284       ld bc,@end-@beg
0401FF 5B DF       0285       rst.lil $18
040201 C3 14 02 04 0286       jp @end
040205             0287   @beg:
040205             0288   ;   610 VDU 23, 0, &A0, sid%; &49, 9, oid%; scale; scale; scale; : REM Set Object XYZ Scale Factors
040205 17 00 A0    0289       db 23,0,$A0
040208 64 00       0290       dw sid
04020A 49 09       0291       db $49,9
04020C 01 00       0292       dw oid
04020E 00 01       0293       dw obj_scale
040210 00 01       0294       dw obj_scale
040212 00 01       0295       dw obj_scale
040214             0296   @end:
040214             0297   
040214             0298       ; ld hl,str_render_to_bitmap
040214             0299       ; call printString
040214             0300   ; draw the cube
040214             0301   rendbmp:
040214 21 22 02 04 0302       ld hl,@beg
040218 01 09 00 00 0303       ld bc,@end-@beg
04021C 5B DF       0304       rst.lil $18
04021E C3 2B 02 04 0305       jp @end
040222             0306   @beg:
040222             0307   ; 6800 VDU 23, 0, &A0, sid%; &49, 38, bmid2%+64000; : REM Render To Bitmap
040222 17 00 A0    0308       db 23, 0, $A0 ; Render To Bitmap
040225 64 00       0309       dw sid
040227 49 26       0310       db $49, 38
040229 66 FA       0311       dw bmid2+64000
04022B             0312   @end:
04022B             0313   
04022B             0314       ; ld hl,str_display_output_bitmap
04022B             0315       ; call printString
04022B             0316   
04022B             0317   dispbmp:
04022B             0318   ; 6810 VDU 23, 27, 3, 0; 0; : REM Display output bitmap
04022B 21 39 02 04 0319       ld hl,@beg
04022F 01 07 00 00 0320       ld bc,@end-@beg
040233 5B DF       0321       rst.lil $18
040235 C3 40 02 04 0322       jp @end
040239             0323   @beg:
040239 17 1B 03    0324       db 23, 27, 3 ; Display output bitmap
04023C 10 00 10 00 0325       dw 16, 16
040240             0326   @end:
040240             0327   
040240 C9          0328       ret
040241             0329   
040241             0330       include "pingo/src/asm/vdu.asm"
040241             0001*  ; The following is a high-level list of the VDU sequences that are supported:
040241             0002*  ; VDU 0: Null (no operation)
040241             0003*  ; VDU 1: Send next character to “printer” (if “printer” is enabled) §§
040241             0004*  ; VDU 2: Enable “printer” §§
040241             0005*  ; VDU 3: Disable “printer” §§
040241             0006*  ; VDU 4: Write text at text cursor
040241             0007*  ; VDU 5: Write text at graphics cursor
040241             0008*  ; VDU 6: Enable screen (opposite of VDU 21) §§
040241             0009*  ; VDU 7: Make a short beep (BEL)
040241             0010*  ; VDU 8: Move cursor back one character
040241             0011*  ; VDU 9: Move cursor forward one character
040241             0012*  ; VDU 10: Move cursor down one line
040241             0013*  ; VDU 11: Move cursor up one line
040241             0014*  ; VDU 12: Clear text area (CLS)
040241             0015*  ; VDU 13: Carriage return
040241             0016*  ; VDU 14: Page mode On *
040241             0017*  ; VDU 15: Page mode Off *
040241             0018*  ; VDU 16: Clear graphics area (CLG)
040241             0019*  ; VDU 17, colour: Define text colour (COLOUR)
040241             0020*  ; VDU 18, mode, colour: Define graphics colour (GCOL mode, colour)
040241             0021*  ; VDU 19, l, p, r, g, b: Define logical colour (COLOUR l, p / COLOUR l, r, g, b)
040241             0022*  ; VDU 20: Reset palette and text/graphics colours and drawing modes §§
040241             0023*  ; VDU 21: Disable screen (turns of VDU command processing, except for VDU 1 and VDU 6) §§
040241             0024*  ; VDU 22, n: Select screen mode (MODE n)
040241             0025*  ; VDU 23, n: Re-program display character / System Commands
040241             0026*  ; VDU 24, left; bottom; right; top;: Set graphics viewport **
040241             0027*  ; VDU 25, mode, x; y;: PLOT command
040241             0028*  ; VDU 26: Reset graphics and text viewports **
040241             0029*  ; VDU 27, char: Output character to screen §
040241             0030*  ; VDU 28, left, bottom, right, top: Set text viewport **
040241             0031*  ; VDU 29, x; y;: Set graphics origin
040241             0032*  ; VDU 30: Home cursor
040241             0033*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
040241             0034*  ; VDU 127: Backspace
040241             0035*  
040241             0036*  ; VDU 0: Null (no operation)
040241             0037*  ;     On encountering a VDU 0 command, the VDP will do nothing.
040241             0038*  ;     This may be useful for padding out a VDU command sequence,
040241             0039*  ;     or for inserting a placeholder for a command that will be added later.
040241             0040*  ; inputs: none
040241             0041*  ; outputs: an empty byte somewhere in VDU
040241             0042*  ; destroys: a
040241             0043*  vdu_null:
040241 AF          0044*      xor a
040242 5B D7       0045*  	rst.lil $10
040244 C9          0046*  	ret
040245             0047*  
040245             0048*  ; VDU 1: Send next character to “printer” (if “printer” is enabled) §§
040245             0049*  ;     Ensures that the next character received by the VDP is sent through to
040245             0050*  ;     the “printer”, and not to the screen. This is useful for sending control
040245             0051*  ;     codes to the “printer”, or for sending data to the “printer” that is not
040245             0052*  ;     intended to be displayed on the screen. It allows characters that would
040245             0053*  ;     not otherwise normally be sent through to the “printer” to be sent.
040245             0054*  ;     If the “printer” has not been enabled then this command will just discard
040245             0055*  ;     the next byte sent to the VDP.
040245             0056*  ; inputs: a is the ascii code of the character to send
040245             0057*  ; prerequisites: "printer" must first be activated with VDU 2 (see below)
040245             0058*  ; outputs: a character on the serial terminal connected to the USB port
040245             0059*  ;           and the same character on the screen at the current text cursor location
040245             0060*  ; QUESTION: does it also advance the text cursor?
040245             0061*  ; destroys: hl, bc
040245             0062*  vdu_char_to_printer:
040245 32 55 02 04 0063*  	ld (@arg),a
040249 21 54 02 04 0064*  	ld hl,@cmd
04024D 01 02 00 00 0065*  	ld bc,@end-@cmd
040251 5B DF       0066*  	rst.lil $18
040253 C9          0067*  	ret
040254 01          0068*  @cmd: db 1
040255 00          0069*  @arg: db 0
040256             0070*  @end:
040256             0071*  
040256             0072*  ; VDU 2: Enable “printer” §§
040256             0073*  ;     Enables the “printer”.
040256             0074*  ;     In the context of the Agon platform, the “printer” is a serial
040256             0075*  ;     terminal that is connected to the VDP’s USB port. Typically
040256             0076*  ;     this port is used for power, but it can also be used to send and
040256             0077*  ;     receive data to and from the VDP.
040256             0078*  ;     When the “printer” is enabled, the VDP will send characters it receives
040256             0079*  ;     to the “printer” as well as to the screen. It will additionally send
040256             0080*  ;     through control codes 8-13. To send other control codes to the “printer”,
040256             0081*  ;     use the VDU 1 command.
040256             0082*  ;     The VDP will not send through other control codes to the printer,
040256             0083*  ;     and will will not send through data it receives as part of other commands.
040256             0084*  vdu_enable_printer:
040256 3E 02       0085*      ld a,2
040258 5B D7       0086*  	rst.lil $10
04025A C9          0087*  	ret
04025B             0088*  
04025B             0089*  ; VDU 3: Disable “printer” §§
04025B             0090*  ; inputs: none
04025B             0091*  ; outputs: a USB port bereft of communication with the VDP
04025B             0092*  ; destroys: a
04025B             0093*  vdu_disable_printer:
04025B 3E 03       0094*      ld a,3
04025D 5B D7       0095*  	rst.lil $10
04025F C9          0096*  	ret
040260             0097*  
040260             0098*  ; VDU 4: Write text at text cursor
040260             0099*  ;     This causes text to be written at the current text cursor position.
040260             0100*  ;     This is the default mode for text display.
040260             0101*  ;     Text is written using the current text foreground and background colours.
040260             0102*  ; inputs: a is the character to write to the screen
040260             0103*  ; prerequisites: the text cursor at the intended position on screen
040260             0104*  ; outputs: prints the character and moves text cursor right one position
040260             0105*  ; destroys: a, hl, bc
040260             0106*  vdu_char_to_text_cursor:
040260 32 70 02 04 0107*  	ld (@arg),a
040264 21 6F 02 04 0108*  	ld hl,@cmd
040268 01 02 00 00 0109*  	ld bc,@end-@cmd
04026C 5B DF       0110*  	rst.lil $18
04026E C9          0111*  	ret
04026F 04          0112*  @cmd: db 4
040270 00          0113*  @arg: db 0
040271             0114*  @end:
040271             0115*  
040271             0116*  ; VDU 5: Write text at graphics cursor
040271             0117*  ;     This causes text to be written at the current graphics cursor position.
040271             0118*  ;     Using this, characters may be positioned at any graphics coordinate within
040271             0119*  ;     the graphics viewport. This is useful for positioning text over graphics,
040271             0120*  ;     or for positioning text at a specific location on the screen.
040271             0121*  ;     Characters are plotted using the current graphics foreground colour,
040271             0122*  ;     using the current graphics foreground plotting mode (see VDU 18).
040271             0123*  ;     The character background is transparent, and will not overwrite any
040271             0124*  ;     graphics that are already present at the character’s location.
040271             0125*  ;     The exception to this is VDU 27, the “delete” character, which backspaces
040271             0126*  ;     and deletes as per its usual behaviour, but will erase using the current
040271             0127*  ;     graphics background colour.
040271             0128*  ; inputs: a is the character to write to the screen
040271             0129*  ; prerequisites: the graphics cursor at the intended position on screen
040271             0130*  ; outputs: see the name of the function
040271             0131*  ; destroys: a, hl, bc
040271             0132*  vdu_char_to_gfx_cursor:
040271 32 81 02 04 0133*  	ld (@arg),a
040275 21 80 02 04 0134*  	ld hl,@cmd
040279 01 02 00 00 0135*  	ld bc,@end-@cmd
04027D 5B DF       0136*  	rst.lil $18
04027F C9          0137*  	ret
040280 05          0138*  @cmd: db 5
040281 00          0139*  @arg: db 0
040282             0140*  @end:
040282             0141*  
040282             0142*  ; VDU 6: Enable screen (opposite of VDU 21) §§
040282             0143*  ;     This enables the screen, and re-enables VDU command processing,
040282             0144*  ;     reversing the effect of VDU 21.
040282             0145*  ; inputs: none
040282             0146*  ; outputs: a functioning screen and VDU
040282             0147*  ; destroys: a
040282             0148*  vdu_enable_screen:
040282 3E 06       0149*      ld a,6
040284 5B D7       0150*  	rst.lil $10
040286 C9          0151*  	ret
040287             0152*  
040287             0153*  ; PASSES
040287             0154*  ; VDU 7: Make a short beep (BEL)
040287             0155*  ;     Plays a short beep sound on audio channel 0. If the audio channel
040287             0156*  ;     is already in use, or has been disabled, then this command will have no effect.
040287             0157*  ; inputs: none
040287             0158*  ; outputs: an unpleasant but thankfully short-lived audio tone
040287             0159*  ; destroys: a
040287             0160*  vdu_beep:
040287 3E 07       0161*      ld a,7
040289 5B D7       0162*  	rst.lil $10
04028B C9          0163*  	ret
04028C             0164*  
04028C             0165*  ; VDU 8: Move cursor back one character
04028C             0166*  ;     Moves the text cursor one character in the negative “X” direction.
04028C             0167*  ;     By default, when at the start of a line it will move to the end of
04028C             0168*  ;     the previous line (as defined by the current text viewport).
04028C             0169*  ;     If the cursor is also at the top of the screen then the viewport will scroll down.
04028C             0170*  ;     The cursor remains constrained to the current text viewport.
04028C             0171*  ;     When in VDU 5 mode and the graphics cursor is active, the viewport will not scroll.
04028C             0172*  ;     The cursor is just moved left by one character width.
04028C             0173*  ;     Further behaviour of the cursor can be controlled using the VDU 23,16 command.
04028C             0174*  ;     It should be noted that as of Console8 VDP 2.5.0, the cursor system does not
04028C             0175*  ;     support adjusting the direction of the cursor’s X axis, so this command
04028C             0176*  ;     will move the cursor to the left. This is likely to change in the future.
04028C             0177*  vdu_cursor_back:
04028C 3E 08       0178*      ld a,8
04028E 5B D7       0179*  	rst.lil $10
040290 C9          0180*  	ret
040291             0181*  
040291             0182*  ; VDU 9: Move cursor forward one character
040291             0183*  vdu_cursor_forward:
040291 3E 09       0184*      ld a,9
040293 5B D7       0185*  	rst.lil $10
040295 C9          0186*  	ret
040296             0187*  
040296             0188*  ; VDU 10: Move cursor down one line
040296             0189*  vdu_cursor_down:
040296 3E 0A       0190*      ld a,10
040298 5B D7       0191*  	rst.lil $10
04029A C9          0192*  	ret
04029B             0193*  
04029B             0194*  ; VDU 11: Move cursor up one line
04029B             0195*  vdu_cursor_up:
04029B 3E 0B       0196*      ld a,11
04029D 5B D7       0197*  	rst.lil $10
04029F C9          0198*  	ret
0402A0             0199*  
0402A0             0200*  ; VDU 12: Clear text area (CLS)
0402A0             0201*  vdu_cls:
0402A0 3E 0C       0202*      ld a,12
0402A2 5B D7       0203*  	rst.lil $10
0402A4 C9          0204*  	ret
0402A5             0205*  
0402A5             0206*  ; VDU 13: Carriage return
0402A5             0207*  vdu_cr:
0402A5 3E 0D       0208*      ld a,13
0402A7 5B D7       0209*  	rst.lil $10
0402A9 C9          0210*  	ret
0402AA             0211*  
0402AA             0212*  ; VDU 14: Page mode On *
0402AA             0213*  vdu_page_on:
0402AA 3E 0E       0214*      ld a,14
0402AC 5B D7       0215*  	rst.lil $10
0402AE C9          0216*  	ret
0402AF             0217*  
0402AF             0218*  ; VDU 15: Page mode Off *
0402AF             0219*  vdu_page_off:
0402AF 3E 0F       0220*      ld a,15
0402B1 5B D7       0221*  	rst.lil $10
0402B3 C9          0222*  	ret
0402B4             0223*  
0402B4             0224*  ; VDU 16: Clear graphics area (CLG)
0402B4             0225*  vdu_clg:
0402B4 3E 10       0226*      ld a,16
0402B6 5B D7       0227*  	rst.lil $10
0402B8 C9          0228*  	ret
0402B9             0229*  
0402B9             0230*  ; VDU 17, colour: Define text colour (COLOUR)
0402B9             0231*  vdu_colour_text:
0402B9 32 C9 02 04 0232*  	ld (@arg),a
0402BD 21 C8 02 04 0233*  	ld hl,@cmd
0402C1 01 02 00 00 0234*  	ld bc,@end-@cmd
0402C5 5B DF       0235*  	rst.lil $18
0402C7 C9          0236*  	ret
0402C8 11          0237*  @cmd: db 17
0402C9 00          0238*  @arg: db 0
0402CA             0239*  @end:
0402CA             0240*  
0402CA             0241*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0402CA             0242*  ; inputs: a is the plotting mode, c is the colour
0402CA             0243*  ; outputs: a VDU set to put pixels on the screen with the selected mode/colour
0402CA             0244*  vdu_gcol_fg:
0402CA             0245*  ; This command will set both the current graphics colour,
0402CA             0246*  ; and the current graphics plotting mode.
0402CA             0247*  ; As with VDU 17 the colour number will set the foreground colour
0402CA             0248*  ; if it is in the range 0-127, or the background colour if it is
0402CA             0249*  ; in the range 128-255, and will be interpreted in the same manner.
0402CA             0250*  ; Support for different plotting modes on Agon is currently very limited.
0402CA             0251*  ; The only fully supported mode is mode 0, which is the default mode.
0402CA             0252*  ; This mode will plot the given colour at the given graphics coordinate,
0402CA             0253*  ; and will overwrite any existing graphics at that coordinate. There is
0402CA             0254*  ; very limited support for mode 4, which will invert the colour of any
0402CA             0255*  ; existing graphics at the given coordinate, but this is not fully supported
0402CA             0256*  ; and may not work as expected.
0402CA             0257*  ; Support for other plotting modes, matching those provided by Acorn’s
0402CA             0258*  ; original VDU system, may be added in the future.
0402CA             0259*  ; This command is identical to the BASIC GCOL keyword.
0402CA 32 DF 02 04 0260*  	ld (@mode),a
0402CE 79          0261*      ld a,c
0402CF 32 E0 02 04 0262*      ld (@col),a
0402D3 21 DE 02 04 0263*  	ld hl,@cmd
0402D7 01 03 00 00 0264*  	ld bc,@end-@cmd
0402DB 5B DF       0265*  	rst.lil $18
0402DD C9          0266*  	ret
0402DE 12          0267*  @cmd: db 18
0402DF 00          0268*  @mode: db 0
0402E0 00          0269*  @col: db 0
0402E1             0270*  @end:
0402E1             0271*  
0402E1             0272*  vdu_gcol_bg:
0402E1 32 F8 02 04 0273*  	ld (@mode),a
0402E5 79          0274*      ld a,c
0402E6 C6 80       0275*      add a,128
0402E8 32 F9 02 04 0276*      ld (@col),a
0402EC 21 F7 02 04 0277*  	ld hl,@cmd
0402F0 01 03 00 00 0278*  	ld bc,@end-@cmd
0402F4 5B DF       0279*  	rst.lil $18
0402F6 C9          0280*  	ret
0402F7 12          0281*  @cmd:  db 18
0402F8 00          0282*  @mode: db 0
0402F9 00          0283*  @col:  db 0
0402FA             0284*  @end:
0402FA             0285*  
0402FA             0286*  ; VDU 19, l, p, r, g, b: Define logical colour (COLOUR l, p / COLOUR l, r, g, b)
0402FA             0287*  ;     This command sets the colour palette, by mapping a logical colour
0402FA             0288*  ;     to a physical colour. This is useful for defining custom colours,
0402FA             0289*  ;     or for redefining the default colours.
0402FA             0290*  ;     If the physical colour number is given as 255 then the colour will
0402FA             0291*  ;     be defined using the red, green, and blue values given. If the physical
0402FA             0292*  ;     colour number is given as any other value then the colour will be defined
0402FA             0293*  ;     using the colour palette entry given by that number, up to colour number 63.
0402FA             0294*  ;     If the physical colour is not 255 then the red, green, and blue values
0402FA             0295*  ;     must still be provided, but will be ignored.
0402FA             0296*  ;     The values for red, green and blue must be given in the range 0-255.
0402FA             0297*  ;     You should note that the physical Agon hardware only supports 64 colours,
0402FA             0298*  ;     so the actual colour displayed may not be exactly the same as the colour
0402FA             0299*  ;     requested. The nearest colour will be chosen.
0402FA             0300*  ;     This command is equivalent to the BASIC COLOUR keyword.
0402FA             0301*  ; inputs: a=physcial colour, b=logical colour, chl=r,g,b
0402FA             0302*  vdu_def_log_colour:
0402FA 32 1F 03 04 0303*  	ld (@physical),a
0402FE 47          0304*      ld b,a
0402FF 32 1E 03 04 0305*      ld (@logical),a
040303 79          0306*      ld a,c
040304 32 20 03 04 0307*      ld (@red),a
040308 7C          0308*      ld a,h
040309 32 21 03 04 0309*      ld (@green),a
04030D 7D          0310*      ld a,l
04030E 32 22 03 04 0311*      ld (@blue),a
040312 21 1D 03 04 0312*  	ld hl,@cmd
040316 01 06 00 00 0313*  	ld bc,@end-@cmd
04031A 5B DF       0314*  	rst.lil $18
04031C C9          0315*  	ret
04031D 13          0316*  @cmd: db 19
04031E 00          0317*  @logical: db 0
04031F 00          0318*  @physical: db 0
040320 00          0319*  @red: db 0
040321 00          0320*  @green: db 0
040322 00          0321*  @blue: db 0
040323             0322*  @end:
040323             0323*  
040323             0324*  ; VDU 20: Reset palette and text/graphics colours and drawing modes §§
040323             0325*  vdu_reset_gfx:
040323 3E 14       0326*      ld a,20
040325 5B D7       0327*  	rst.lil $10
040327 C9          0328*  	ret
040328             0329*  
040328             0330*  ; VDU 21: Disable screen (turns off VDU command processing,
040328             0331*  ; except for VDU 1 and VDU 6) §§
040328             0332*  vdu_disable_screen:
040328 3E 15       0333*      ld a,21
04032A 5B D7       0334*  	rst.lil $10
04032C C9          0335*  	ret
04032D             0336*  
04032D             0337*  ; VDU 22, n: Select screen mode (MODE n)
04032D             0338*  ; Inputs: a, screen mode (8-bit unsigned integer), in the following list:
04032D             0339*  ; https://agonconsole8.github.io/agon-docs/VDP---Screen-Modes.html
04032D             0340*  ; Screen modes
04032D             0341*  ; Modes over 128 are double-buffered
04032D             0342*  ; From Version 1.04 or greater
04032D             0343*  ; Mode 	Horz 	Vert 	Cols 	Refresh
04032D             0344*  ; 0 	640 	480 	16 	    60hz
04032D             0345*  ; * 1 	640 	480 	4 	    60hz
04032D             0346*  ; 2 	640 	480 	2 	    60hz
04032D             0347*  ; 3 	640 	240 	64 	    60hz
04032D             0348*  ; 4 	640 	240 	16 	    60hz
04032D             0349*  ; 5 	640 	240 	4 	    60hz
04032D             0350*  ; 6 	640 	240 	2 	    60hz
04032D             0351*  ; ** 7 	n/a 	n/a 	16 	    60hz
04032D             0352*  ; 8 	320 	240 	64 	    60hz
04032D             0353*  ; 9 	320 	240 	16 	    60hz
04032D             0354*  ; 10 	320 	240 	4 	    60hz
04032D             0355*  ; 11 	320 	240 	2 	    60hz
04032D             0356*  ; 12 	320 	200 	64 	    70hz
04032D             0357*  ; 13 	320 	200 	16 	    70hz
04032D             0358*  ; 14 	320 	200 	4 	    70hz
04032D             0359*  ; 15 	320 	200 	2 	    70hz
04032D             0360*  ; 16 	800 	600 	4 	    60hz
04032D             0361*  ; 17 	800 	600 	2 	    60hz
04032D             0362*  ; 18 	1024 	768 	2 	    60hz
04032D             0363*  ; 129 	640 	480 	4 	    60hz
04032D             0364*  ; 130 	640 	480 	2 	    60hz
04032D             0365*  ; 132 	640 	240 	16 	    60hz
04032D             0366*  ; 133 	640 	240 	4 	    60hz
04032D             0367*  ; 134 	640 	240 	2 	    60hz
04032D             0368*  ; 136 	320 	240 	64 	    60hz
04032D             0369*  ; 137 	320 	240 	16 	    60hz
04032D             0370*  ; 138 	320 	240 	4 	    60hz
04032D             0371*  ; 139 	320 	240 	2 	    60hz
04032D             0372*  ; 140 	320 	200 	64 	    70hz
04032D             0373*  ; 141 	320 	200 	16 	    70hz
04032D             0374*  ; 142 	320 	200 	4 	    70hz
04032D             0375*  ; 143 	320 	200 	2 	    70hz
04032D             0376*  ; * Mode 1 is the “default” mode, and is the mode that the system will use on startup.
04032D             0377*  ; It is also the mode that the system will fall back to use if it was not possible to
04032D             0378*  ; change to the requested mode.
04032D             0379*  ; ** Mode 7 is the “Teletext” mode, and essentially works in a very similar manner to
04032D             0380*  ; the BBC Micro’s Teletext mode, which was also mode 7.
04032D             0381*  vdu_set_screen_mode:
04032D 32 3D 03 04 0382*  	ld (@arg),a
040331 21 3C 03 04 0383*  	ld hl,@cmd
040335 01 02 00 00 0384*  	ld bc,@end-@cmd
040339 5B DF       0385*  	rst.lil $18
04033B C9          0386*  	ret
04033C 16          0387*  @cmd: db 22 ; set screen mode
04033D 00          0388*  @arg: db 0  ; screen mode parameter
04033E             0389*  @end:
04033E             0390*  
04033E             0391*  ; VDU 23, n: Re-program display character / System Commands
04033E             0392*  ; inputs: a, ascii code; hl, pointer to bitmask data
04033E             0393*  vdu_define_character:
04033E 32 5A 03 04 0394*  	ld (@ascii),a
040342 11 5B 03 04 0395*  	ld de,@data
040346 06 08       0396*  	ld b,8 ; loop counter for 8 bytes of data
040348             0397*  @loop:
040348 7E          0398*  	ld a,(hl)
040349 12          0399*  	ld (de),a
04034A 23          0400*  	inc hl
04034B 13          0401*  	inc de
04034C 10 FA       0402*  	djnz @loop
04034E 21 59 03 04 0403*  	ld hl,@cmd
040352 01 0A 00 00 0404*  	ld bc,@end-@cmd
040356 5B DF       0405*  	rst.lil $18
040358 C9          0406*  	ret
040359 17          0407*  @cmd:   db 23
04035A 00          0408*  @ascii: db 0
04035B             0409*  @data:  ds 8
040363             0410*  @end:
040363             0411*  
040363             0412*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
040363             0413*  ; NOTE: the order of the y-coordinate parameters are inverted
040363             0414*  ; 	because we have turned off logical screen scaling
040363             0415*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
040363             0416*  ; outputs; nothing
040363             0417*  ; destroys: a might make it out alive
040363             0418*  vdu_set_gfx_viewport:
040363 ED 43 83 03 0419*      ld (@x0),bc
       04          
040368 FD 22 85 03 0420*      ld (@y1),iy
       04          
04036D DD 22 87 03 0421*  	ld (@x1),ix
       04          
040372 ED 53 89 03 0422*  	ld (@y0),de
       04          
040377 21 82 03 04 0423*  	ld hl,@cmd
04037B 01 09 00 00 0424*  	ld bc,@end-@cmd
04037F 5B DF       0425*  	rst.lil $18
040381 C9          0426*  	ret
040382 18          0427*  @cmd:   db 24 ; set graphics viewport command
040383 00 00       0428*  @x0: 	dw 0x0000 ; set by bc
040385 00 00       0429*  @y1: 	dw 0x0000 ; set by iy
040387 00 00       0430*  @x1: 	dw 0x0000 ; set by ix
040389 00 00       0431*  @y0: 	dw 0x0000 ; set by de
04038B 00          0432*  @end:   db 0x00	  ; padding
04038C             0433*  
04038C             0434*  ; VDU 25, mode, x; y;: PLOT command
04038C             0435*  ; Implemented in vdu_plot.asm
04038C             0436*  
04038C             0437*  ; VDU 26: Reset graphics and text viewports **
04038C             0438*  vdu_reset_txt_gfx_view:
04038C 3E 1A       0439*      ld a,26
04038E 5B D7       0440*  	rst.lil $10
040390 C9          0441*  	ret
040391             0442*  
040391             0443*  ; PASSES
040391             0444*  ; VDU 27, char: Output character to screen §
040391             0445*  ; inputs: a is the ascii code of the character to draw
040391             0446*  vdu_draw_char:
040391 32 A1 03 04 0447*  	ld (@arg),a
040395 21 A0 03 04 0448*  	ld hl,@cmd
040399 01 02 00 00 0449*  	ld bc,@end-@cmd
04039D 5B DF       0450*  	rst.lil $18
04039F C9          0451*  	ret
0403A0 1B          0452*  @cmd: db 27
0403A1 00          0453*  @arg: db 0  ; ascii code of character to draw
0403A2             0454*  @end:
0403A2             0455*  
0403A2             0456*  ; VDU 28, left, bottom, right, top: Set text viewport **
0403A2             0457*  ; MIND THE LITTLE-ENDIANESS
0403A2             0458*  ; inputs: c=left,b=bottom,e=right,d=top
0403A2             0459*  ; outputs; nothing
0403A2             0460*  ; destroys: a might make it out alive
0403A2             0461*  vdu_set_txt_viewport:
0403A2 ED 43 B8 03 0462*      ld (@lb),bc
       04          
0403A7 ED 53 BA 03 0463*  	ld (@rt),de
       04          
0403AC 21 B7 03 04 0464*  	ld hl,@cmd
0403B0 01 05 00 00 0465*  	ld bc,@end-@cmd
0403B4 5B DF       0466*  	rst.lil $18
0403B6 C9          0467*  	ret
0403B7 1C          0468*  @cmd:   db 28 ; set text viewport command
0403B8 00 00       0469*  @lb: 	dw 0x0000 ; set by bc
0403BA 00 00       0470*  @rt: 	dw 0x0000 ; set by de
0403BC 00          0471*  @end:   db 0x00	  ; padding
0403BD             0472*  
0403BD             0473*  ; PASSES
0403BD             0474*  ; VDU 29, x; y;: Set graphics origin
0403BD             0475*  ; inputs: bc,de x,y coordinates
0403BD             0476*  vdu_set_gfx_origin:
0403BD ED 43 D3 03 0477*      ld (@x0),bc
       04          
0403C2 ED 53 D5 03 0478*      ld (@y0),de
       04          
0403C7 21 D2 03 04 0479*  	ld hl,@cmd
0403CB 01 05 00 00 0480*  	ld bc,@end-@cmd
0403CF 5B DF       0481*  	rst.lil $18
0403D1 C9          0482*  	ret
0403D2 1D          0483*  @cmd:	db 29
0403D3 00 00       0484*  @x0: 	dw 0
0403D5 00 00       0485*  @y0: 	dw 0
0403D7 00          0486*  @end: 	db 0 ; padding
0403D8             0487*  
0403D8             0488*  ; PASSES
0403D8             0489*  ; VDU 30: Home cursor
0403D8             0490*  vdu_home_cursor:
0403D8 3E 1E       0491*      ld a,30
0403DA 5B D7       0492*  	rst.lil $10
0403DC C9          0493*  	ret
0403DD             0494*  
0403DD             0495*  ; PASSES
0403DD             0496*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0403DD             0497*  ; inputs: c=x, b=y 8-bit unsigned integers
0403DD             0498*  vdu_move_cursor:
0403DD ED 43 EE 03 0499*      ld (@x0),bc
       04          
0403E2 21 ED 03 04 0500*  	ld hl,@cmd
0403E6 01 03 00 00 0501*  	ld bc,@end-@cmd
0403EA 5B DF       0502*  	rst.lil $18
0403EC C9          0503*  	ret
0403ED 1F          0504*  @cmd: 	db 31
0403EE 00          0505*  @x0:	db 0
0403EF 00          0506*  @y0: 	db 0
0403F0 00          0507*  @end: 	db 0 ; padding
0403F1             0508*  
0403F1             0509*  
0403F1             0510*  ; VDU 127: Backspace
0403F1             0511*  vdu_bksp:
0403F1 3E 7F       0512*      ld a,127
0403F3 5B D7       0513*  	rst.lil $10
0403F5 C9          0514*  	ret
0403F6             0515*  
0403F6             0516*  ; activate a bitmap in preparation to draw it
0403F6             0517*  ; inputs: a holding the bitmap index
0403F6             0518*  vdu_bmp_select:
0403F6 32 08 04 04 0519*  	ld (@bmp),a
0403FA 21 05 04 04 0520*  	ld hl,@cmd
0403FE 01 04 00 00 0521*  	ld bc,@end-@cmd
040402 5B DF       0522*  	rst.lil $18
040404 C9          0523*  	ret
040405 17 1B 00    0524*  @cmd: db 23,27,0
040408 00          0525*  @bmp: db 0
040409             0526*  @end:
040409             0527*  
040409             0528*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
040409             0529*  ; inputs: hl=bufferId
040409             0530*  vdu_buff_select:
040409 22 1B 04 04 0531*  	ld (@bufferId),hl
04040D 21 18 04 04 0532*  	ld hl,@cmd
040411 01 05 00 00 0533*  	ld bc,@end-@cmd
040415 5B DF       0534*  	rst.lil $18
040417 C9          0535*  	ret
040418 17 1B 20    0536*  @cmd: db 23,27,0x20
04041B 00 00       0537*  @bufferId: dw 0x0000
04041D 00          0538*  @end: db 0x00 ; padding
04041E             0539*  
04041E             0540*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
04041E             0541*  ; inputs: a=format; bc=width; de=height
04041E             0542*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
04041E             0543*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
04041E             0544*  ; 0 	RGBA8888 (4-bytes per pixel)
04041E             0545*  ; 1 	RGBA2222 (1-bytes per pixel)
04041E             0546*  ; 2 	Mono/Mask (1-bit per pixel)
04041E             0547*  ; 3 	Reserved for internal use by VDP (“native” format)
04041E             0548*  vdu_bmp_create:
04041E ED 43 3A 04 0549*      ld (@width),bc
       04          
040423 ED 53 3C 04 0550*      ld (@height),de
       04          
040428 32 3E 04 04 0551*      ld (@fmt),a
04042C 21 37 04 04 0552*  	ld hl,@cmd
040430 01 08 00 00 0553*  	ld bc,@end-@cmd
040434 5B DF       0554*  	rst.lil $18
040436 C9          0555*  	ret
040437 17 1B 21    0556*  @cmd:       db 23,27,0x21
04043A 00 00       0557*  @width:     dw 0x0000
04043C 00 00       0558*  @height:    dw 0x0000
04043E 00          0559*  @fmt:       db 0x00
04043F             0560*  @end:
04043F             0561*  
04043F             0562*  ; Draw a bitmap on the screen
04043F             0563*  ; inputs: bc, x-coordinate; de, y-coordinate
04043F             0564*  ; prerequisite: bitmap index set by e.g. vdu_bmp_select
04043F             0565*  vdu_bmp_draw:
04043F ED 43 57 04 0566*      ld (@x0),bc
       04          
040444 ED 53 59 04 0567*      ld (@y0),de
       04          
040449 21 54 04 04 0568*  	ld hl,@cmd
04044D 01 07 00 00 0569*  	ld bc,@end-@cmd
040451 5B DF       0570*  	rst.lil $18
040453 C9          0571*  	ret
040454 17 1B 03    0572*  @cmd: db 23,27,3
040457 00 00       0573*  @x0:  dw 0x0000
040459 00 00       0574*  @y0:  dw 0x0000
04045B 00          0575*  @end: db 0x00 ; padding
04045C             0576*  
04045C             0577*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
04045C             0578*  ; inputs: a is scaling mode, 1=on, 0=off
04045C             0579*  ; note: default setting on boot is scaling ON
04045C             0580*  vdu_set_scaling:
04045C 32 6E 04 04 0581*  	ld (@arg),a
040460 21 6B 04 04 0582*  	ld hl,@cmd
040464 01 04 00 00 0583*  	ld bc,@end-@cmd
040468 5B DF       0584*  	rst.lil $18
04046A C9          0585*  	ret
04046B 17 00 C0    0586*  @cmd: db 23,0,0xC0
04046E 00          0587*  @arg: db 0  ; scaling on/off
04046F             0588*  @end:
04046F             0589*  
04046F             0590*  ; VDU 23, 0, &C3: Swap the screen buffer and/or wait for VSYNC **
04046F             0591*  ; 	Swap the screen buffer (double-buffered modes only) or wait for VSYNC
04046F             0592*  ; 	(all modes).
04046F             0593*  
04046F             0594*  ; 	This command will swap the screen buffer, if the current screen mode
04046F             0595*  ; 	is double-buffered, doing so at the next VSYNC. If the current screen
04046F             0596*  ; 	mode is not double-buffered then this command will wait for the next
04046F             0597*  ; 	VSYNC signal before returning. This can be used to synchronise the
04046F             0598*  ; 	screen with the vertical refresh rate of the monitor.
04046F             0599*  
04046F             0600*  ; 	Waiting for VSYNC can be useful for ensuring smooth graphical animation,
04046F             0601*  ; 	as it will prevent tearing of the screen.
04046F             0602*  ; inputs: none
04046F             0603*  ; outputs: none
04046F             0604*  ; destroys: hl, bc
04046F             0605*  vdu_flip:
04046F 21 7A 04 04 0606*  	ld hl,@cmd
040473 01 03 00 00 0607*  	ld bc,@end-@cmd
040477 5B DF       0608*  	rst.lil $18
040479 C9          0609*  	ret
04047A 17 00 C3    0610*  @cmd: db 23,0,0xC3
04047D             0611*  @end:
04047D             0612*  
04047D             0613*  ; Command 64: Compress a buffer
04047D             0614*  ; VDU 23, 0, &A0, targetBufferId; 64, sourceBufferId;
04047D             0615*  ; This command will compress the contents of a buffer, replacing the target buffer with the compressed data. Unless the target buffer is the same as the source, the source buffer will be left unchanged.
04047D             0616*  
04047D             0617*  
04047D             0618*  ; Command 65: Decompress a buffer
04047D             0619*  ; VDU 23, 0, &A0, targetBufferId; 65, sourceBufferId;
04047D             0620*  ; This command will decompress the contents of a buffer, replacing the target buffer with the decompressed data. Unless the target buffer is the same as the source, the source buffer will be left unchanged.
04047D             0621*  ; inputs: hl=sourceBufferId/targetBufferId
04047D             0622*  vdu_decompress_buffer:
04047D 22 99 04 04 0623*  	ld (@targetBufferId),hl
040481 22 9C 04 04 0624*  	ld (@sourceBufferId),hl
040485 3E 41       0625*  	ld a,65
040487 32 9B 04 04 0626*  	ld (@cmd1),a ; restore the part of command that got stomped on
04048B 21 96 04 04 0627*  	ld hl,@cmd
04048F 01 08 00 00 0628*  	ld bc,@end-@cmd
040493 5B DF       0629*  	rst.lil $18
040495 C9          0630*  	ret
040496 17 00 A0    0631*  @cmd: 	db 23,0,0xA0
040499 00 00       0632*  @targetBufferId: dw 0x0000
04049B 41          0633*  @cmd1:	db 65
04049C 00 00       0634*  @sourceBufferId: dw 0x0000
04049E 00          0635*  @end: 	db 0x00 ; padding
04049F             0636*  
04049F             0637*  ; Command 65: Decompress a buffer
04049F             0638*  ; VDU 23, 0, &A0, targetBufferId; 65, sourceBufferId;
04049F             0639*  ; This command will decompress the contents of a buffer, replacing the target buffer with the decompressed data. Unless the target buffer is the same as the source, the source buffer will be left unchanged.
04049F             0640*  ; inputs: hl=sourceBufferId/targetBufferId
04049F             0641*  ; 0x7FFF for the source buffer is just an easy-to remember aribtrary value
04049F             0642*  vdu_decompress_buffer_different:
04049F 22 BF 04 04 0643*  	ld (@targetBufferId),hl
0404A3 21 FF 7F 00 0644*      ld hl,0x7FFF
0404A7 22 C2 04 04 0645*  	ld (@sourceBufferId),hl
0404AB 3E 41       0646*  	ld a,65
0404AD 32 C1 04 04 0647*  	ld (@cmd1),a ; restore the part of command that got stomped on
0404B1 21 BC 04 04 0648*  	ld hl,@cmd
0404B5 01 08 00 00 0649*  	ld bc,@end-@cmd
0404B9 5B DF       0650*  	rst.lil $18
0404BB C9          0651*  	ret
0404BC 17 00 A0    0652*  @cmd: 	db 23,0,0xA0
0404BF 00 00       0653*  @targetBufferId: dw 0x0000
0404C1 41          0654*  @cmd1:	db 65
0404C2 00 00       0655*  @sourceBufferId: dw 0x0000
0404C4 00          0656*  @end: 	db 0x00 ; padding
0404C5             0657*  
0404C5             0658*  ; #### from vdp.asm ####
0404C5             0659*  
0404C5             0660*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
0404C5             0661*  ; VDU 23, 7: Scrolling
0404C5             0662*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
0404C5             0663*  ; inputs: a, extent; l, direction; h; speed
0404C5             0664*  vdu_scroll_down:
0404C5 32 DA 04 04 0665*  	ld (@extent),a
0404C9 22 DB 04 04 0666*  	ld (@dir),hl ; implicitly populates @speed
0404CD 21 D8 04 04 0667*  	ld hl,@cmd
0404D1 01 05 00 00 0668*  	ld bc,@end-@cmd
0404D5 5B DF       0669*  	rst.lil $18     ;; Sending command to VDP
0404D7 C9          0670*  	ret
0404D8 17 07       0671*  @cmd:       db 23,7
0404DA 00          0672*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
0404DB 00          0673*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
0404DC 00          0674*  @speed:     db 0x00 ; pixels
0404DD 00          0675*  @end:		db 0x00 ; padding
0404DE             0676*  
0404DE             0677*  cursor_on:
0404DE 21 E9 04 04 0678*  	ld hl,@cmd
0404E2 01 03 00 00 0679*  	ld bc,@end-@cmd
0404E6 5B DF       0680*  	rst.lil $18
0404E8 C9          0681*  	ret
0404E9             0682*  @cmd:
0404E9 17 01 01    0683*  	db 23,1,1
0404EC             0684*  @end:
0404EC             0685*  
0404EC             0686*  cursor_off:
0404EC 21 F7 04 04 0687*  	ld hl,@cmd
0404F0 01 03 00 00 0688*  	ld bc,@end-@cmd
0404F4 5B DF       0689*  	rst.lil $18
0404F6 C9          0690*  	ret
0404F7             0691*  @cmd:
0404F7 17 01 00    0692*  	db 23,1,0
0404FA             0693*  @end:
0404FA             0694*  
0404FA DD E5       0695*  vdu_vblank:		PUSH 	IX			; Wait for VBLANK interrupt
0404FC             0696*  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
0404FC 3E 08       0001*M 			LD	A, function
0404FE 5B CF       0002*M 			RST.LIL	08h
040500 DD 7E 00    0697*  			LD	A, (IX + sysvar_time + 0)
040503 DD BE 00    0698*  @wait:			CP 	A, (IX + sysvar_time + 0)
040506 28 FB       0699*  			JR	Z, @wait
040508 DD E1       0700*  			POP	IX
04050A C9          0701*  			RET
04050B             0702*  
04050B             0703*  ; #### from vdu_bmp.asm ####
04050B             0704*  ; =========================================================================
04050B             0705*  ; Bitmaps
04050B             0706*  ; -------------------------------------------------------------------------
04050B             0707*  ; VDU 23, 27, 0, n: Select bitmap n
04050B             0708*  ; VDU 23, 27, &20, bufferId;: Select bitmap using a 16-bit buffer ID *
04050B             0709*  ; VDU 23, 27, 1, w; h; b1, b2 ... bn: Load colour bitmap data into current bitmap
04050B             0710*  
04050B             0711*  ; VDU 23, 27, 1, n, 0, 0;: Capture screen data into bitmap n *
04050B             0712*  ; VDU 23, 27, &21, bitmapId; 0; : same, but to 16-bit buffer ID *
04050B             0713*  ; Any PLOT, or VDU 25, style command will push the graphics cursor position -
04050B             0714*  ; typically "move" style plot commands are used to define the rectangle.
04050B             0715*  ; To be clear, this command should be performed after two "move" style PLOT commands.
04050B             0716*  ; inputs: hl; target bufferId
04050B             0717*  ; all the following are in 16.8 fixed point format
04050B             0718*  ;   ub.c; top-left x coordinate
04050B             0719*  ;   ud.e; top-left y coordinate
04050B             0720*  ;   ui.x; width
04050B             0721*  ;   ui.y; height
04050B             0722*  vdu_buff_screen_capture168:
04050B ED 53 42 05 0723*          ld (@y0-1),de
       04          
040510 ED 43 40 05 0724*          ld (@x0-1),bc
       04          
040515 3E 44       0725*          ld a,0x44 ; plot_pt+mv_abs
040517 32 40 05 04 0726*          ld (@x0-1),a
04051B             0727*  
04051B DD 22 47 05 0728*          ld (@x1),ix
       04          
040520 FD 22 49 05 0729*          ld (@y1),iy
       04          
040525 3E 17       0730*          ld a,23
040527 32 4B 05 04 0731*          ld (@y1+2),a
04052B             0732*  
04052B 22 4E 05 04 0733*          ld (@bufId),hl
04052F AF          0734*          xor a
040530 32 50 05 04 0735*          ld (@bufId+2),a
040534             0736*  
040534 21 3F 05 04 0737*          ld hl,@begin
040538 01 13 00 00 0738*          ld bc,@end-@begin
04053C 5B DF       0739*          rst.lil $18
04053E C9          0740*          ret
04053F             0741*  @begin:
04053F             0742*  ; absolute move gfx cursor to top-left screen coordinate
04053F             0743*  ; VDU 25, mode, x; y;: PLOT command
04053F 19 44       0744*          db 25,0x44 ; plot_pt+mv_abs
040541 40 00       0745*  @x0: 	dw 64
040543 40 00       0746*  @y0: 	dw 64
040545             0747*  ; relative move gfx cursor to bottom-right screen coordinate
040545             0748*  ; VDU 25, mode, x; y;: PLOT command
040545 19 40       0749*          db 25,0x40 ; plot_pt+mv_rel
040547 0F 00       0750*  @x1: 	dw 15
040549 0F 00       0751*  @y1: 	dw 15
04054B             0752*  ; now the main event
04054B             0753*  ; VDU 23, 27, &21, bitmapId; 0;
04054B 17 1B 21    0754*          db 23,27,0x21
04054E 00 20 00 00 0755*  @bufId: dw 0x2000,0x0000
040552             0756*  @end: ; no padding required
040552             0757*  
040552             0758*  vdu_buff_screen_capture_full:
040552 21 5D 05 04 0759*          ld hl,@begin
040556 01 13 00 00 0760*          ld bc,@end-@begin
04055A 5B DF       0761*          rst.lil $18
04055C C9          0762*          ret
04055D             0763*  @begin:
04055D             0764*  ; absolute move gfx cursor to top-left screen coordinate
04055D             0765*  ; VDU 25, mode, x; y;: PLOT command
04055D 19 44       0766*          db 25,0x44 ; plot_pt+mv_abs
04055F 00 00       0767*  @x0: 	dw 0
040561 00 00       0768*  @y0: 	dw 0
040563             0769*  ; relative move gfx cursor to bottom-right screen coordinate
040563             0770*  ; VDU 25, mode, x; y;: PLOT command
040563 19 40       0771*          db 25,0x40 ; plot_pt+mv_rel
040565 3F 01       0772*  @x1: 	dw 319
040567 EF 00       0773*  @y1: 	dw 239
040569             0774*  ; now the main event
040569             0775*  ; VDU 23, 27, &21, bitmapId; 0;
040569 17 1B 21    0776*          db 23,27,0x21
04056C 00 20 00 00 0777*  @bufId: dw 0x2000,0x0000
040570             0778*  @end: ; no padding required
040570             0779*  
040570             0780*  vdu_buff_screen_paste_full:
040570 21 7B 05 04 0781*          ld hl,@begin
040574 01 0B 00 00 0782*          ld bc,@end-@begin
040578 5B DF       0783*          rst.lil $18
04057A C9          0784*          ret
04057B             0785*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
04057B 17 1B 20    0786*  @begin:    db 23,27,0x20
04057E 00 20       0787*  @bufferId: dw 0x2000
040580             0788*  ; VDU 25, mode, x; y;: PLOT command
040580 19 ED       0789*             db 25,0xED ; plot_bmp+dr_abs_fg
040582 00 00 00 00 0790*             dw 0x0000,0x0000
040586             0791*  @end: ; no padding required
040586             0792*  
040586             0793*  vdu_buff_screen_capture_tiles:
040586 21 91 05 04 0794*          ld hl,@begin
04058A 01 13 00 00 0795*          ld bc,@end-@begin
04058E 5B DF       0796*          rst.lil $18
040590 C9          0797*          ret
040591             0798*  @begin:
040591             0799*  ; absolute move gfx cursor to top-left screen coordinate
040591             0800*  ; VDU 25, mode, x; y;: PLOT command
040591 19 44       0801*          db 25,0x44 ; plot_pt+mv_abs
040593 00 00       0802*  @x0: 	dw 0
040595 00 00       0803*  @y0: 	dw 0
040597             0804*  ; relative move gfx cursor to bottom-right screen coordinate
040597             0805*  ; VDU 25, mode, x; y;: PLOT command
040597 19 40       0806*          db 25,0x40 ; plot_pt+mv_rel
040599 FF 00       0807*  @x1: 	dw 319-64
04059B EF 00       0808*  @y1: 	dw 239
04059D             0809*  ; now the main event
04059D             0810*  ; VDU 23, 27, &21, bitmapId; 0;
04059D 17 1B 21    0811*          db 23,27,0x21
0405A0 00 20 00 00 0812*  @bufId: dw 0x2000,0x0000
0405A4             0813*  @end: ; no padding required
0405A4             0814*  
0405A4             0815*  vdu_buff_screen_paste_tiles:
0405A4 21 AF 05 04 0816*          ld hl,@begin
0405A8 01 0B 00 00 0817*          ld bc,@end-@begin
0405AC 5B DF       0818*          rst.lil $18
0405AE C9          0819*          ret
0405AF             0820*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0405AF 17 1B 20    0821*  @begin:    db 23,27,0x20
0405B2 00 20       0822*  @bufferId: dw 0x2000
0405B4             0823*  ; VDU 25, mode, x; y;: PLOT command
0405B4 19 ED       0824*             db 25,0xED ; plot_bmp+dr_abs_fg
0405B6 00 00 01 00 0825*             dw 0x0000,0x0001
0405BA             0826*  @end: ; no padding required
0405BA             0827*  
0405BA             0828*  ; VDU 23, 27, 2, w; h; col1; col2;: Create a solid colour rectangular bitmap
0405BA             0829*  ; VDU 23, 27, 3, x; y;: Draw current bitmap on screen at pixel position x, y
0405BA             0830*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer *
0405BA             0831*  ; Value	Meaning
0405BA             0832*  ; 0	RGBA8888 (4-bytes per pixel)
0405BA             0833*  ; 1	RGBA2222 (1-bytes per pixel)
0405BA             0834*  ; 2	Mono/Mask (1-bit per pixel)
0405BA             0835*  ; 3	Reserved for internal use by VDP ("native" format)VDP.
0405BA             0836*  ;     They have some significant limitations, and are not intended for general use.
0405BA             0837*  
0405BA             0838*  ; =========================================================================
0405BA             0839*  ; Sprites
0405BA             0840*  ; -------------------------------------------------------------------------
0405BA             0841*  ; VDU 23, 27, 4, n: Select sprite n
0405BA             0842*  ; VDU 23, 27, 5: Clear frames in current sprite
0405BA             0843*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
0405BA             0844*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
0405BA             0845*  ; VDU 23, 27, 7, n: Activate n sprites
0405BA             0846*  ; VDU 23, 27, 8: Select next frame of current sprite
0405BA             0847*  ; VDU 23, 27, 9: Select previous frame of current sprite
0405BA             0848*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
0405BA             0849*  ; VDU 23, 27, 11: Show current sprite
0405BA             0850*  ; VDU 23, 27, 12: Hide current sprite
0405BA             0851*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
0405BA             0852*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
0405BA             0853*  ; VDU 23, 27, 15: Update the sprites in the GPU
0405BA             0854*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
0405BA             0855*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
0405BA             0856*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
0405BA             0857*  
0405BA             0858*  ; =========================================================================
0405BA             0859*  ; Mouse cursor
0405BA             0860*  ; -------------------------------------------------------------------------
0405BA             0861*  ; VDU 23, 27, &40, hotX, hotY: Setup a mouse cursor with a hot spot at hotX, hotY
0405BA             0862*  
0405BA             0863*  ; #### from vdu_plot.asm ####
0405BA             0864*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0405BA             0865*  ; PLOT code 	(Decimal) 	Effect
0405BA             0866*  ; &00-&07 	0-7 	Solid line, includes both ends
0405BA             0867*  plot_sl_both: equ 0x00
0405BA             0868*  
0405BA             0869*  ; &08-&0F 	8-15 	Solid line, final point omitted
0405BA             0870*  plot_sl_first: equ 0x08
0405BA             0871*  
0405BA             0872*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0405BA             0873*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0405BA             0874*  
0405BA             0875*  ; &20-&27 	32-39 	Solid line, first point omitted
0405BA             0876*  plot_sl_last: equ 0x20
0405BA             0877*  
0405BA             0878*  ; &28-&2F 	40-47 	Solid line, both points omitted
0405BA             0879*  plot_sl_none: equ 0x28
0405BA             0880*  
0405BA             0881*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0405BA             0882*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0405BA             0883*  
0405BA             0884*  ; &40-&47 	64-71 	Point plot
0405BA             0885*  plot_pt: equ 0x40
0405BA             0886*  
0405BA             0887*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
0405BA             0888*  plot_lf_lr_non_bg: equ 0x48
0405BA             0889*  
0405BA             0890*  ; &50-&57 	80-87 	Triangle fill
0405BA             0891*  plot_tf: equ 0x50
0405BA             0892*  
0405BA             0893*  ; &58-&5F 	88-95 	Line fill right to background §§
0405BA             0894*  plot_lf_r_bg: equ 0x58
0405BA             0895*  
0405BA             0896*  ; &60-&67 	96-103 	Rectangle fill
0405BA             0897*  plot_rf: equ 0x60
0405BA             0898*  
0405BA             0899*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
0405BA             0900*  plot_lf_lr_fg: equ 0x60
0405BA             0901*  
0405BA             0902*  ; &70-&77 	112-119 	Parallelogram fill
0405BA             0903*  plot_pf: equ 0x70
0405BA             0904*  
0405BA             0905*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
0405BA             0906*  plot_lf_r_non_fg: equ 0x78
0405BA             0907*  
0405BA             0908*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
0405BA             0909*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0405BA             0910*  
0405BA             0911*  ; &90-&97 	144-151 	Circle outline
0405BA             0912*  plot_co: equ 0x90
0405BA             0913*  
0405BA             0914*  ; &98-&9F 	152-159 	Circle fill
0405BA             0915*  plot_cf: equ 0x98
0405BA             0916*  
0405BA             0917*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
0405BA             0918*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
0405BA             0919*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
0405BA             0920*  
0405BA             0921*  ; &B8-&BF 	184-191 	Rectangle copy/move
0405BA             0922*  plot_rcm: equ 0xB8
0405BA             0923*  
0405BA             0924*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0405BA             0925*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0405BA             0926*  ; &D0-&D7 	208-215 	Not defined
0405BA             0927*  ; &D8-&DF 	216-223 	Not defined
0405BA             0928*  ; &E0-&E7 	224-231 	Not defined
0405BA             0929*  
0405BA             0930*  ; &E8-&EF 	232-239 	Bitmap plot §
0405BA             0931*  plot_bmp: equ 0xE8
0405BA             0932*  
0405BA             0933*  ; &F0-&F7 	240-247 	Not defined
0405BA             0934*  ; &F8-&FF 	248-255 	Not defined
0405BA             0935*  
0405BA             0936*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
0405BA             0937*  ; Agon Console8 VDP 2.2.0
0405BA             0938*  
0405BA             0939*  ; Within each group of eight plot codes, the effects are as follows:
0405BA             0940*  ; Plot code 	Effect
0405BA             0941*  ; 0 	Move relative
0405BA             0942*  mv_rel: equ 0
0405BA             0943*  
0405BA             0944*  ; 1 	Plot relative in current foreground colour
0405BA             0945*  dr_rel_fg: equ 1
0405BA             0946*  
0405BA             0947*  ; 2 	Not supported (Plot relative in logical inverse colour)
0405BA             0948*  ; 3 	Plot relative in current background colour
0405BA             0949*  dr_rel_bg: equ 3
0405BA             0950*  
0405BA             0951*  ; 4 	Move absolute
0405BA             0952*  mv_abs: equ 4
0405BA             0953*  
0405BA             0954*  ; 5 	Plot absolute in current foreground colour
0405BA             0955*  dr_abs_fg: equ 5
0405BA             0956*  
0405BA             0957*  ; 6 	Not supported (Plot absolute in logical inverse colour)
0405BA             0958*  ; 7 	Plot absolute in current background colour
0405BA             0959*  dr_abs_bg: equ 7
0405BA             0960*  
0405BA             0961*  ; Codes 0-3 use the position data provided as part of the command
0405BA             0962*  ; as a relative position, adding the position given to the current
0405BA             0963*  ; graphical cursor position. Codes 4-7 use the position data provided
0405BA             0964*  ; as part of the command as an absolute position, setting the current
0405BA             0965*  ; graphical cursor position to the position given.
0405BA             0966*  
0405BA             0967*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0405BA             0968*  ; current pixel colour. These operations cannot currently be supported
0405BA             0969*  ; by the graphics system the Agon VDP uses, so these codes are not
0405BA             0970*  ; supported. Support for these codes may be added in a future version
0405BA             0971*  ; of the VDP firmware.
0405BA             0972*  
0405BA             0973*  ; 16 colour palette constants
0405BA             0974*  c_black: equ 0
0405BA             0975*  c_red_dk: equ 1
0405BA             0976*  c_green_dk: equ 2
0405BA             0977*  c_yellow_dk: equ 3
0405BA             0978*  c_blue_dk: equ 4
0405BA             0979*  c_magenta_dk: equ 5
0405BA             0980*  c_cyan_dk: equ 6
0405BA             0981*  c_grey: equ 7
0405BA             0982*  c_grey_dk: equ 8
0405BA             0983*  c_red: equ 9
0405BA             0984*  c_green: equ 10
0405BA             0985*  c_yellow: equ 11
0405BA             0986*  c_blue: equ 12
0405BA             0987*  c_magenta: equ 13
0405BA             0988*  c_cyan: equ 14
0405BA             0989*  c_white: equ 15
0405BA             0990*  
0405BA             0991*  ; VDU 25, mode, x; y;: PLOT command
0405BA             0992*  ; inputs: a=mode, bc=x0, de=y0
0405BA             0993*  vdu_plot:
0405BA 32 D4 05 04 0994*      ld (@mode),a
0405BE ED 43 D5 05 0995*      ld (@x0),bc
       04          
0405C3 ED 53 D7 05 0996*      ld (@y0),de
       04          
0405C8 21 D3 05 04 0997*  	ld hl,@cmd
0405CC 01 06 00 00 0998*  	ld bc,@end-@cmd
0405D0 5B DF       0999*  	rst.lil $18
0405D2 C9          1000*  	ret
0405D3 19          1001*  @cmd:   db 25
0405D4 00          1002*  @mode:  db 0
0405D5 00 00       1003*  @x0: 	dw 0
0405D7 00 00       1004*  @y0: 	dw 0
0405D9 00          1005*  @end:   db 0 ; extra byte to soak up deu
0405DA             1006*  
0405DA             1007*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0405DA             1008*  ; &E8-&EF 	232-239 	Bitmap plot §
0405DA             1009*  ; VDU 25, mode, x; y;: PLOT command
0405DA             1010*  ; inputs: bc=x0, de=y0
0405DA             1011*  ; prerequisites: vdu_buff_select
0405DA             1012*  vdu_plot_bmp:
0405DA ED 43 F1 05 1013*      ld (@x0),bc
       04          
0405DF ED 53 F3 05 1014*      ld (@y0),de
       04          
0405E4 21 EF 05 04 1015*  	ld hl,@cmd
0405E8 01 06 00 00 1016*  	ld bc,@end-@cmd
0405EC 5B DF       1017*  	rst.lil $18
0405EE C9          1018*  	ret
0405EF 19          1019*  @cmd:   db 25
0405F0 ED          1020*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0405F1 00 00       1021*  @x0: 	dw 0x0000
0405F3 00 00       1022*  @y0: 	dw 0x0000
0405F5 00          1023*  @end:   db 0x00 ; padding
0405F6             1024*  
0405F6             1025*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0405F6             1026*  ; &E8-&EF 	232-239 	Bitmap plot §
0405F6             1027*  ; VDU 25, mode, x; y;: PLOT command
0405F6             1028*  ; inputs: bc=x0, de=y0
0405F6             1029*  ; USING 16.8 FIXED POINT COORDINATES
0405F6             1030*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
0405F6             1031*  ;   the fractional portiion of the inputs are truncated
0405F6             1032*  ;   leaving only the 16-bit integer portion
0405F6             1033*  ; prerequisites: vdu_buff_select
0405F6             1034*  vdu_plot_bmp168:
0405F6             1035*  ; populate in the reverse of normal to keep the
0405F6             1036*  ; inputs from stomping on each other
0405F6 ED 53 14 06 1037*      ld (@y0-1),de
       04          
0405FB ED 43 12 06 1038*      ld (@x0-1),bc
       04          
040600 3E ED       1039*      ld a,plot_bmp+dr_abs_fg ; 0xED
040602 32 12 06 04 1040*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
040606 21 11 06 04 1041*  	ld hl,@cmd
04060A 01 06 00 00 1042*  	ld bc,@end-@cmd
04060E 5B DF       1043*  	rst.lil $18
040610 C9          1044*  	ret
040611 19          1045*  @cmd:   db 25
040612 ED          1046*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
040613 00 00       1047*  @x0: 	dw 0x0000
040615 00 00       1048*  @y0: 	dw 0x0000
040617             1049*  @end:  ; no padding required b/c we shifted de right
040617             1050*  
040617             1051*  ; draw a filled rectangle
040617             1052*  vdu_plot_rf:
040617 ED 43 3E 06 1053*      ld (@x0),bc
       04          
04061C ED 53 40 06 1054*      ld (@y0),de
       04          
040621 DD 22 44 06 1055*      ld (@x1),ix
       04          
040626 FD 22 46 06 1056*      ld (@y1),iy
       04          
04062B 3E 19       1057*      ld a,25 ; we have to reload the 2nd plot command
04062D 32 42 06 04 1058*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
040631 21 3C 06 04 1059*  	ld hl,@cmd0
040635 01 0C 00 00 1060*  	ld bc,@end-@cmd0
040639 5B DF       1061*  	rst.lil $18
04063B C9          1062*      ret
04063C 19          1063*  @cmd0:  db 25 ; plot
04063D 04          1064*  @arg0:  db plot_sl_both+mv_abs
04063E 00 00       1065*  @x0:    dw 0x0000
040640 00 00       1066*  @y0:    dw 0x0000
040642 19          1067*  @cmd1:  db 25 ; plot
040643 65          1068*  @arg1:  db plot_rf+dr_abs_fg
040644 00 00       1069*  @x1:    dw 0x0000
040646 00 00       1070*  @y1:    dw 0x0000
040648 00          1071*  @end:   db 0x00 ; padding
040649             1072*  
040649             1073*  ; draw a filled circle
040649             1074*  vdu_plot_cf:
040649 ED 43 70 06 1075*      ld (@x0),bc
       04          
04064E ED 53 72 06 1076*      ld (@y0),de
       04          
040653 DD 22 76 06 1077*      ld (@x1),ix
       04          
040658 FD 22 78 06 1078*      ld (@y1),iy
       04          
04065D 3E 19       1079*      ld a,25 ; we have to reload the 2nd plot command
04065F 32 74 06 04 1080*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
040663 21 6E 06 04 1081*  	ld hl,@cmd0
040667 01 0C 00 00 1082*  	ld bc,@end-@cmd0
04066B 5B DF       1083*  	rst.lil $18
04066D C9          1084*      ret
04066E 19          1085*  @cmd0:  db 25 ; plot
04066F 04          1086*  @arg0:  db plot_sl_both+mv_abs
040670 00 00       1087*  @x0:    dw 0x0000
040672 00 00       1088*  @y0:    dw 0x0000
040674 19          1089*  @cmd1:  db 25 ; plot
040675 9D          1090*  @arg1:  db plot_cf+dr_abs_fg
040676 00 00       1091*  @x1:    dw 0x0000
040678 00 00       1092*  @y1:    dw 0x0000
04067A 00          1093*  @end:   db 0x00 ; padding
04067B             1094*  
04067B             1095*  ; #### from vdu_sprites.asm ####
04067B             1096*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
04067B             1097*  ; the VDP can support up to 256 sprites. They must be defined
04067B             1098*  ; contiguously, and so the first sprite is sprite 0.
04067B             1099*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
04067B             1100*  ; Once a selection of sprites have been defined, you can activate
04067B             1101*  ; them using the VDU 23, 27, 7, n command, where n is the number
04067B             1102*  ; of sprites to activate. This will activate the first n sprites,
04067B             1103*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
04067B             1104*  
04067B             1105*  ; A single sprite can have multiple "frames", referring to
04067B             1106*  ; different bitmaps.
04067B             1107*  ; (These bitmaps do not need to be the same size.)
04067B             1108*  ; This allows a sprite to include an animation sequence,
04067B             1109*  ; which can be stepped through one frame at a time, or picked
04067B             1110*  ; in any order.
04067B             1111*  
04067B             1112*  ; Any format of bitmap can be used as a sprite frame. It should
04067B             1113*  ; be noted however that "native" format bitmaps are not
04067B             1114*  ; recommended for use as sprite frames, as they cannot get
04067B             1115*  ; erased from the screen. (As noted above, the "native" bitmap
04067B             1116*  ; format is not really intended for general use.) This is part
04067B             1117*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
04067B             1118*  ; screen are now stored in RGBA2222 format.
04067B             1119*  
04067B             1120*  ; An "active" sprite can be hidden, so it will stop being drawn,
04067B             1121*  ; and then later shown again.
04067B             1122*  
04067B             1123*  ; Moving sprites around the screen is done by changing the
04067B             1124*  ; position of the sprite. This can be done either by setting
04067B             1125*  ; the absolute position of the sprite, or by moving the sprite
04067B             1126*  ; by a given number of pixels. (Sprites are positioned using
04067B             1127*  ; pixel coordinates, and not by the logical OS coordinate system.)
04067B             1128*  ; In the current sprite system, sprites will not update their
04067B             1129*  ; position on-screen until either another drawing operation is
04067B             1130*  ; performed or an explicit VDU 23, 27, 15 command is performed.
04067B             1131*  
04067B             1132*  ; Here are the sprite commands:
04067B             1133*  ;
04067B             1134*  ; VDU 23, 27, 4,  n: Select sprite n
04067B             1135*  ; inputs: a is the 8-bit sprite id
04067B             1136*  ; vdu_sprite_select:
04067B             1137*  
04067B             1138*  ; VDU 23, 27, 5:  Clear frames in current sprite
04067B             1139*  ; inputs: none
04067B             1140*  ; prerequisites: vdu_sprite_select
04067B             1141*  ; vdu_sprite_clear_frames:
04067B             1142*  
04067B             1143*  ; VDU 23, 27, 6,  n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
04067B             1144*  ; inputs: a is the 8-bit bitmap number
04067B             1145*  ; prerequisites: vdu_sprite_select
04067B             1146*  ; vdu_sprite_add_bmp:
04067B             1147*  
04067B             1148*  ; VDU 23, 27, 7,  n: Activate n sprites
04067B             1149*  ; inputs: a is the number of sprites to activate
04067B             1150*  ; vdu_sprite_activate:
04067B             1151*  
04067B             1152*  ; VDU 23, 27, 8:  Select next frame of current sprite
04067B             1153*  ; inputs: none
04067B             1154*  ; prerequisites: vdu_sprite_select
04067B             1155*  ; vdu_sprite_next_frame:
04067B             1156*  
04067B             1157*  ; VDU 23, 27, 9:  Select previous frame of current sprite
04067B             1158*  ; inputs: none
04067B             1159*  ; prerequisites: vdu_sprite_select
04067B             1160*  ; vdu_sprite_prev_frame:
04067B             1161*  
04067B             1162*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
04067B             1163*  ; inputs: a is frame number to select
04067B             1164*  ; prerequisites: vdu_sprite_select
04067B             1165*  ; vdu_sprite_select_frame:
04067B             1166*  
04067B             1167*  ; VDU 23, 27, 11: Show current sprite
04067B             1168*  ; inputs: none
04067B             1169*  ; prerequisites: vdu_sprite_select
04067B             1170*  ; vdu_sprite_show:
04067B             1171*  
04067B             1172*  ; VDU 23, 27, 12: Hide current sprite
04067B             1173*  ; inputs: none
04067B             1174*  ; prerequisites: vdu_sprite_select
04067B             1175*  ; vdu_sprite_hide:
04067B             1176*  
04067B             1177*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
04067B             1178*  ; inputs: bc is x coordinate, de is y coordinate
04067B             1179*  ; prerequisites: vdu_sprite_select
04067B             1180*  ; vdu_sprite_move_abs:
04067B             1181*  ;
04067B             1182*  ; USING 16.8 FIXED POINT COORDINATES
04067B             1183*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
04067B             1184*  ;   the fractional portiion of the inputs are truncated
04067B             1185*  ;   leaving only the 16-bit integer portion
04067B             1186*  ; prerequisites: vdu_sprite_select
04067B             1187*  ; vdu_sprite_move_abs168:
04067B             1188*  
04067B             1189*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
04067B             1190*  ; inputs: bc is x coordinate, de is y coordinate
04067B             1191*  ; prerequisites: vdu_sprite_select
04067B             1192*  ; vdu_sprite_move_rel:
04067B             1193*  ;
04067B             1194*  ; USING 16.8 FIXED POINT COORDINATES
04067B             1195*  ; inputs: ub.c is dx, ud.e is dy
04067B             1196*  ;   the fractional portiion of the inputs are truncated
04067B             1197*  ;   leaving only the 16-bit integer portion
04067B             1198*  ; prerequisites: vdu_sprite_select
04067B             1199*  ; vdu_sprite_move_rel168:
04067B             1200*  
04067B             1201*  ; VDU 23, 27, 15: Update the sprites in the GPU
04067B             1202*  ; inputs: none
04067B             1203*  ; vdu_sprite_update:
04067B             1204*  
04067B             1205*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
04067B             1206*  ; inputs: none
04067B             1207*  ; vdu_sprite_bmp_reset:
04067B             1208*  
04067B             1209*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
04067B             1210*  ; inputs: none
04067B             1211*  ; vdu_sprite_reset:
04067B             1212*  
04067B             1213*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
04067B             1214*  ; inputs: a is the GCOL paint mode
04067B             1215*  ; prerequisites: vdu_sprite_select
04067B             1216*  ; vdu_sprite_set_gcol:
04067B             1217*  
04067B             1218*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
04067B             1219*  ; inputs: hl=bufferId
04067B             1220*  ; prerequisites: vdu_sprite_select
04067B             1221*  ; vdu_sprite_add_buff:
04067B             1222*  
04067B             1223*  @dummy_label: ; dummy label to serve as a break from the above comments and the below code
04067B             1224*  
04067B             1225*  ; VDU 23, 27, 4, n: Select sprite n
04067B             1226*  ; inputs: a is the 8-bit sprite id
04067B             1227*  vdu_sprite_select:
04067B 32 8D 06 04 1228*      ld (@sprite),a
04067F 21 8A 06 04 1229*      ld hl,@cmd
040683 01 04 00 00 1230*      ld bc,@end-@cmd
040687 5B DF       1231*      rst.lil $18
040689 C9          1232*      ret
04068A 17 1B 04    1233*  @cmd:    db 23,27,4
04068D 00          1234*  @sprite: db 0x00
04068E             1235*  @end:
04068E             1236*  
04068E             1237*  ; VDU 23, 27, 5: Clear frames in current sprite
04068E             1238*  ; inputs: none
04068E             1239*  ; prerequisites: vdu_sprite_select
04068E             1240*  vdu_sprite_clear_frames:
04068E 21 99 06 04 1241*      ld hl,@cmd
040692 01 03 00 00 1242*      ld bc,@end-@cmd
040696 5B DF       1243*      rst.lil $18
040698 C9          1244*      ret
040699 17 1B 05    1245*  @cmd: db 23,27,5
04069C             1246*  @end:
04069C             1247*  
04069C             1248*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
04069C             1249*  ; inputs: a is the 8-bit bitmap number
04069C             1250*  ; prerequisites: vdu_sprite_select
04069C             1251*  vdu_sprite_add_bmp:
04069C 32 AE 06 04 1252*      ld (@bmp),a
0406A0 21 AB 06 04 1253*      ld hl,@cmd
0406A4 01 04 00 00 1254*      ld bc,@end-@cmd
0406A8 5B DF       1255*      rst.lil $18
0406AA C9          1256*      ret
0406AB 17 1B 06    1257*  @cmd: db 23,27,6
0406AE 00          1258*  @bmp: db 0x00
0406AF             1259*  @end:
0406AF             1260*  
0406AF             1261*  ; VDU 23, 27, 7, n: Activate n sprites
0406AF             1262*  ; inputs: a is the number of sprites to activate
0406AF             1263*  vdu_sprite_activate:
0406AF 32 C1 06 04 1264*      ld (@num),a
0406B3 21 BE 06 04 1265*      ld hl,@cmd
0406B7 01 04 00 00 1266*      ld bc,@end-@cmd
0406BB 5B DF       1267*      rst.lil $18
0406BD C9          1268*      ret
0406BE 17 1B 07    1269*  @cmd: db 23,27,7
0406C1 00          1270*  @num: db 0x00
0406C2             1271*  @end:
0406C2             1272*  
0406C2             1273*  ; VDU 23, 27, 8: Select next frame of current sprite
0406C2             1274*  ; inputs: none
0406C2             1275*  ; prerequisites: vdu_sprite_select
0406C2             1276*  vdu_sprite_next_frame:
0406C2 21 CD 06 04 1277*      ld hl,@cmd
0406C6 01 03 00 00 1278*      ld bc,@end-@cmd
0406CA 5B DF       1279*      rst.lil $18
0406CC C9          1280*      ret
0406CD 17 1B 08    1281*  @cmd: db 23,27,8
0406D0             1282*  @end:
0406D0             1283*  
0406D0             1284*  ; VDU 23, 27, 9: Select previous frame of current sprite
0406D0             1285*  ; inputs: none
0406D0             1286*  ; prerequisites: vdu_sprite_select
0406D0             1287*  vdu_sprite_prev_frame:
0406D0 21 DB 06 04 1288*      ld hl,@cmd
0406D4 01 03 00 00 1289*      ld bc,@end-@cmd
0406D8 5B DF       1290*      rst.lil $18
0406DA C9          1291*      ret
0406DB 17 1B 09    1292*  @cmd: db 23,27,9
0406DE             1293*  @end:
0406DE             1294*  
0406DE             1295*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
0406DE             1296*  ; inputs: a is frame number to select
0406DE             1297*  ; prerequisites: vdu_sprite_select
0406DE             1298*  vdu_sprite_select_frame:
0406DE 32 F0 06 04 1299*      ld (@frame),a
0406E2 21 ED 06 04 1300*      ld hl,@cmd
0406E6 01 04 00 00 1301*      ld bc,@end-@cmd
0406EA 5B DF       1302*      rst.lil $18
0406EC C9          1303*      ret
0406ED 17 1B 0A    1304*  @cmd:    db 23,27,10
0406F0 00          1305*  @frame:  db 0x00
0406F1             1306*  @end:
0406F1             1307*  
0406F1             1308*  ; VDU 23, 27, 11: Show current sprite
0406F1             1309*  ; inputs: none
0406F1             1310*  ; prerequisites: vdu_sprite_select
0406F1             1311*  vdu_sprite_show:
0406F1 21 FC 06 04 1312*      ld hl,@cmd
0406F5 01 03 00 00 1313*      ld bc,@end-@cmd
0406F9 5B DF       1314*      rst.lil $18
0406FB C9          1315*      ret
0406FC 17 1B 0B    1316*  @cmd: db 23,27,11
0406FF             1317*  @end:
0406FF             1318*  
0406FF             1319*  ; VDU 23, 27, 12: Hide current sprite
0406FF             1320*  ; inputs: none
0406FF             1321*  ; prerequisites: vdu_sprite_select
0406FF             1322*  vdu_sprite_hide:
0406FF 21 0A 07 04 1323*      ld hl,@cmd
040703 01 03 00 00 1324*      ld bc,@end-@cmd
040707 5B DF       1325*      rst.lil $18
040709 C9          1326*      ret
04070A 17 1B 0C    1327*  @cmd: db 23,27,12
04070D             1328*  @end:
04070D             1329*  
04070D             1330*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
04070D             1331*  ; inputs: bc is x coordinate, de is y coordinate
04070D             1332*  ; prerequisites: vdu_sprite_select
04070D             1333*  vdu_sprite_move_abs:
04070D ED 43 25 07 1334*      ld (@xpos),bc
       04          
040712 ED 53 27 07 1335*      ld (@ypos),de
       04          
040717 21 22 07 04 1336*      ld hl,@cmd
04071B 01 07 00 00 1337*      ld bc,@end-@cmd
04071F 5B DF       1338*      rst.lil $18
040721 C9          1339*      ret
040722 17 1B 0D    1340*  @cmd:  db 23,27,13
040725 00 00       1341*  @xpos: dw 0x0000
040727 00 00       1342*  @ypos: dw 0x0000
040729 00          1343*  @end:  db 0x00 ; padding
04072A             1344*  
04072A             1345*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
04072A             1346*  ; inputs: bc is x coordinate, de is y coordinate
04072A             1347*  ; prerequisites: vdu_sprite_select
04072A             1348*  vdu_sprite_move_rel:
04072A ED 43 42 07 1349*      ld (@dx),bc
       04          
04072F ED 53 44 07 1350*      ld (@dy),de
       04          
040734 21 3F 07 04 1351*      ld hl,@cmd
040738 01 07 00 00 1352*      ld bc,@end-@cmd
04073C 5B DF       1353*      rst.lil $18
04073E C9          1354*      ret
04073F 17 1B 0E    1355*  @cmd: db 23,27,14
040742 00 00       1356*  @dx:  dw 0x0000
040744 00 00       1357*  @dy:  dw 0x0000
040746 00          1358*  @end: db 0x00 ; padding
040747             1359*  
040747             1360*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
040747             1361*  ; USING 16.8 FIXED POINT COORDINATES
040747             1362*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
040747             1363*  ;   the fractional portiion of the inputs are truncated
040747             1364*  ;   leaving only the 16-bit integer portion
040747             1365*  ; prerequisites: vdu_sprite_select
040747             1366*  vdu_sprite_move_abs168:
040747             1367*  ; populate in the reverse of normal to keep the
040747             1368*  ; inputs from stomping on each other
040747 ED 53 66 07 1369*      ld (@ypos-1),de
       04          
04074C ED 43 64 07 1370*      ld (@xpos-1),bc
       04          
040751 3E 0D       1371*      ld a,13       ; restore the final byte of the command
040753 32 64 07 04 1372*      ld (@cmd+2),a ; string that got stomped on by bcu
040757 21 62 07 04 1373*      ld hl,@cmd
04075B 01 07 00 00 1374*      ld bc,@end-@cmd
04075F 5B DF       1375*      rst.lil $18
040761 C9          1376*      ret
040762 17 1B 0D    1377*  @cmd:  db 23,27,13
040765 00 00       1378*  @xpos: dw 0x0000
040767 00 00       1379*  @ypos: dw 0x0000
040769             1380*  @end:  ; no padding required b/c we shifted de right
040769             1381*  
040769             1382*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
040769             1383*  ; USING 16.8 FIXED POINT COORDINATES
040769             1384*  ; inputs: ub.c is dx, ud.e is dy
040769             1385*  ;   the fractional portiion of the inputs are truncated
040769             1386*  ;   leaving only the 16-bit integer portion
040769             1387*  ; prerequisites: vdu_sprite_select
040769             1388*  vdu_sprite_move_rel168:
040769             1389*  ; populate in the reverse of normal to keep the
040769             1390*  ; inputs from stomping on each other
040769 ED 53 88 07 1391*      ld (@dy-1),de
       04          
04076E ED 43 86 07 1392*      ld (@dx-1),bc
       04          
040773 3E 0E       1393*      ld a,14       ; restore the final byte of the command
040775 32 86 07 04 1394*      ld (@cmd+2),a ; string that got stomped on by bcu
040779 21 84 07 04 1395*      ld hl,@cmd
04077D 01 07 00 00 1396*      ld bc,@end-@cmd
040781 5B DF       1397*      rst.lil $18
040783 C9          1398*      ret
040784 17 1B 0E    1399*  @cmd:  db 23,27,14
040787 00 00       1400*  @dx: dw 0x0000
040789 00 00       1401*  @dy: dw 0x0000
04078B             1402*  @end:  ; no padding required b/c we shifted de right
04078B             1403*  
04078B             1404*  ; VDU 23, 27, 15: Update the sprites in the GPU
04078B             1405*  ; inputs: none
04078B             1406*  vdu_sprite_update:
04078B 21 96 07 04 1407*      ld hl,@cmd
04078F 01 03 00 00 1408*      ld bc,@end-@cmd
040793 5B DF       1409*      rst.lil $18
040795 C9          1410*      ret
040796 17 1B 0F    1411*  @cmd: db 23,27,15
040799             1412*  @end:
040799             1413*  
040799             1414*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
040799             1415*  ; inputs: none
040799             1416*  vdu_sprite_bmp_reset:
040799 21 A4 07 04 1417*      ld hl,@cmd
04079D 01 03 00 00 1418*      ld bc,@end-@cmd
0407A1 5B DF       1419*      rst.lil $18
0407A3 C9          1420*      ret
0407A4 17 1B 10    1421*  @cmd: db 23,27,16
0407A7             1422*  @end:
0407A7             1423*  
0407A7             1424*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
0407A7             1425*  ; inputs: none
0407A7             1426*  vdu_sprite_reset:
0407A7 21 B2 07 04 1427*      ld hl,@cmd
0407AB 01 03 00 00 1428*      ld bc,@end-@cmd
0407AF 5B DF       1429*      rst.lil $18
0407B1 C9          1430*      ret
0407B2 17 1B 11    1431*  @cmd: db 23,27,17
0407B5             1432*  @end:
0407B5             1433*  
0407B5             1434*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
0407B5             1435*  ; inputs: a is the GCOL paint mode
0407B5             1436*  ; prerequisites: vdu_sprite_select
0407B5             1437*  vdu_sprite_set_gcol:
0407B5 32 C7 07 04 1438*      ld (@mode),a
0407B9 21 C4 07 04 1439*      ld hl,@cmd
0407BD 01 04 00 00 1440*      ld bc,@end-@cmd
0407C1 5B DF       1441*      rst.lil $18
0407C3 C9          1442*      ret
0407C4 17 1B 12    1443*  @cmd:  db 23,27,18
0407C7 00          1444*  @mode: db 0x00
0407C8             1445*  @end:
0407C8             1446*  
0407C8             1447*  ; VDU 23, 27, &26, n;: Add bitmap bufferId
0407C8             1448*  ;     as a frame to current sprite using a 16-bit buffer ID
0407C8             1449*  ; inputs: hl=bufferId
0407C8             1450*  ; prerequisites: vdu_sprite_select
0407C8             1451*  vdu_sprite_add_buff:
0407C8 22 DA 07 04 1452*      ld (@bufferId),hl
0407CC 21 D7 07 04 1453*      ld hl,@cmd
0407D0 01 05 00 00 1454*      ld bc,@end-@cmd
0407D4 5B DF       1455*      rst.lil $18
0407D6 C9          1456*      ret
0407D7 17 1B 26    1457*  @cmd:      db 23,27,0x26
0407DA 00 00       1458*  @bufferId: dw 0x0000
0407DC 00          1459*  @end:      db 0x00 ; padding
0407DD             1460*  
0407DD             1461*  
0407DD             1462*  ; #### from sfx.asm ####
0407DD 00          1463*  sfx_last_channel: db 0x00 ; 8-bit value between 0 and 31
0407DE             1464*  
0407DE             1465*  vdu_clear_all_buffers:
0407DE             1466*  ; clear all buffers
0407DE 21 E9 07 04 1467*      ld hl,@beg
0407E2 01 06 00 00 1468*      ld bc,@end-@beg
0407E6 5B DF       1469*      rst.lil $18
0407E8 C9          1470*      ret
0407E9 17 00 A0    1471*  @beg: db 23,0,$A0
0407EC FF FF       1472*        dw -1 ; clear all buffers
0407EE 02          1473*        db 2  ; command 2: clear a buffer
0407EF             1474*  @end:
0407EF             0331   
0407EF 57 65 6C 63 0332   str_hello_world: db "Welcome to the Pingo 3D Demo!\r\n",0
       6F 6D 65 20 
       74 6F 20 74 
       68 65 20 50 
       69 6E 67 6F 
       20 33 44 20 
       44 65 6D 6F 
       21 0D 0A 00 
04080F 43 72 65 61 0333   str_create_object: db "Creating 3D object.\r\n",0
       74 69 6E 67 
       20 33 44 20 
       6F 62 6A 65 
       63 74 2E 0D 
       0A 00       
040825 53 63 61 6C 0334   str_scale_object: db "Scaling object.\r\n",0
       69 6E 67 20 
       6F 62 6A 65 
       63 74 2E 0D 
       0A 00       
040837 43 72 65 61 0335   str_create_target_bitmap: db "Creating target bitmap.\r\n",0
       74 69 6E 67 
       20 74 61 72 
       67 65 74 20 
       62 69 74 6D 
       61 70 2E 0D 
       0A 00       
040851 53 65 74 74 0336   str_set_texture_pixel: db "Setting texture pixel.\r\n",0
       69 6E 67 20 
       74 65 78 74 
       75 72 65 20 
       70 69 78 65 
       6C 2E 0D 0A 
       00          
04086A 43 72 65 61 0337   str_create_texture_bitmap: db "Creating texture bitmap.\r\n",0
       74 69 6E 67 
       20 74 65 78 
       74 75 72 65 
       20 62 69 74 
       6D 61 70 2E 
       0D 0A 00    
040885 53 65 6E 64 0338   str_zeroes: db "Sending some magic zeroes.\r\n",0
       69 6E 67 20 
       73 6F 6D 65 
       20 6D 61 67 
       69 63 20 7A 
       65 72 6F 65 
       73 2E 0D 0A 
       00          
0408A2 53 65 74 74 0339   str_set_tex_coord_idxs: db "Setting texture coordinate indices.\r\n",0
       69 6E 67 20 
       74 65 78 74 
       75 72 65 20 
       63 6F 6F 72 
       64 69 6E 61 
       74 65 20 69 
       6E 64 69 63 
       65 73 2E 0D 
       0A 00       
0408C8 53 65 6E 64 0340   str_set_texture_coordinates: db "Sending texture coordinates.\r\n",0
       69 6E 67 20 
       74 65 78 74 
       75 72 65 20 
       63 6F 6F 72 
       64 69 6E 61 
       74 65 73 2E 
       0D 0A 00    
0408E7 53 65 6E 64 0341   str_set_mesh_vertex_indexes: db "Sending vertex indexes.\r\n",0
       69 6E 67 20 
       76 65 72 74 
       65 78 20 69 
       6E 64 65 78 
       65 73 2E 0D 
       0A 00       
040901 53 65 6E 64 0342   str_send_vertices: db "Sending vertices.\r\n",0
       69 6E 67 20 
       76 65 72 74 
       69 63 65 73 
       2E 0D 0A 00 
040915 53 65 74 74 0343   str_set_camera_x_rotation: db "Setting camera X rotation.\r\n",0
       69 6E 67 20 
       63 61 6D 65 
       72 61 20 58 
       20 72 6F 74 
       61 74 69 6F 
       6E 2E 0D 0A 
       00          
040932 53 65 74 74 0344   str_set_camera_distance: db "Setting camera distance.\r\n",0
       69 6E 67 20 
       63 61 6D 65 
       72 61 20 64 
       69 73 74 61 
       6E 63 65 2E 
       0D 0A 00    
04094D 43 72 65 61 0345   str_create_control: db "Creating control structure.\r\n",0
       74 69 6E 67 
       20 63 6F 6E 
       74 72 6F 6C 
       20 73 74 72 
       75 63 74 75 
       72 65 2E 0D 
       0A 00       
04096B 49 6E 69 74 0346   str_init_cmplt: db "Initialization complete.\r\n",0
       69 61 6C 69 
       7A 61 74 69 
       6F 6E 20 63 
       6F 6D 70 6C 
       65 74 65 2E 
       0D 0A 00    
040986 52 65 6E 64 0347   str_render_to_bitmap: db "Rendering to bitmap.\r\n",0
       65 72 69 6E 
       67 20 74 6F 
       20 62 69 74 
       6D 61 70 2E 
       0D 0A 00    
04099D 44 69 73 70 0348   str_display_output_bitmap: db "Displaying output bitmap.\r\n",0
       6C 61 79 69 
       6E 67 20 6F 
       75 74 70 75 
       74 20 62 69 
       74 6D 61 70 
       2E 0D 0A 00 
0409B9 50 72 6F 67 0349   str_program_end: db "Program end.\r\n",0
       72 61 6D 20 
       65 6E 64 2E 
       0D 0A 00    
0409C8             0350   
0409C8             0351   
0409C8             0352   ; Print a zero-terminated string
0409C8             0353   ; HL: Pointer to string
0409C8             0354   printString:
0409C8 C5          0355   	PUSH	BC
0409C9 01 00 00 00 0356   	LD		BC,0
0409CD 3E 00       0357   	LD 	 	A,0
0409CF 5B DF       0358   	RST.LIL 18h
0409D1 C1          0359   	POP		BC
0409D2 C9          0360   	RET
