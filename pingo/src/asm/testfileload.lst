PC     Output      Line
040000             0001       include "pingo/src/asm/mos_api.asm"
040000             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.asm
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
040000             0005*  ;			Added MOS error codes for return in HL
040000             0006*  ; Created:	03/08/2022
040000             0007*  ; Last Updated:	10/08/2023
040000             0008*  ;
040000             0009*  ; Modinfo:
040000             0010*  ; 05/08/2022:	Added mos_feof
040000             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0015*  ; 13/10/2022:	Added mos_oscli
040000             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0025*  ; 19/05/2023:	Added sysvar_scrMode
040000             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0027*  ; 03/08/2023:	Added mos_setkbvector
040000             0028*  ; 10/08/2023:	Added mos_getkbmap
040000             0029*  
040000             0030*  ; VDP control (VDU 23, 0, n)
040000             0031*  ;
040000             0032*  vdp_gp:				EQU 80h
040000             0033*  vdp_keycode:		EQU 81h
040000             0034*  vdp_cursor:			EQU	82h
040000             0035*  vdp_scrchar:		EQU	83h
040000             0036*  vdp_scrpixel:		EQU	84h
040000             0037*  vdp_audio:			EQU	85h
040000             0038*  vdp_mode:			EQU	86h
040000             0039*  vdp_rtc:			EQU	87h
040000             0040*  vdp_keystate:		EQU	88h
040000             0041*  vdp_logicalcoords:	EQU	C0h
040000             0042*  vdp_terminalmode:	EQU	FFh
040000             0043*  
040000             0044*  ; MOS high level functions
040000             0045*  ;
040000             0046*  mos_getkey:			EQU	00h
040000             0047*  mos_load:			EQU	01h
040000             0048*  mos_save:			EQU	02h
040000             0049*  mos_cd:				EQU	03h
040000             0050*  mos_dir:			EQU	04h
040000             0051*  mos_del:			EQU	05h
040000             0052*  mos_ren:			EQU	06h
040000             0053*  mos_mkdir:			EQU	07h
040000             0054*  mos_sysvars:		EQU	08h
040000             0055*  mos_editline:		EQU	09h
040000             0056*  mos_fopen:			EQU	0Ah
040000             0057*  mos_fclose:			EQU	0Bh
040000             0058*  mos_fgetc:			EQU	0Ch
040000             0059*  mos_fputc:			EQU	0Dh
040000             0060*  mos_feof:			EQU	0Eh
040000             0061*  mos_getError:		EQU	0Fh
040000             0062*  mos_oscli:			EQU	10h
040000             0063*  mos_copy:			EQU	11h
040000             0064*  mos_getrtc:			EQU	12h
040000             0065*  mos_setrtc:			EQU	13h
040000             0066*  mos_setintvector:	EQU	14h
040000             0067*  mos_uopen:			EQU	15h
040000             0068*  mos_uclose:			EQU	16h
040000             0069*  mos_ugetc:			EQU	17h
040000             0070*  mos_uputc:			EQU	18h
040000             0071*  mos_getfil:			EQU	19h
040000             0072*  mos_fread:			EQU	1Ah
040000             0073*  mos_fwrite:			EQU	1Bh
040000             0074*  mos_flseek:			EQU	1Ch
040000             0075*  mos_setkbvector:	EQU	1Dh
040000             0076*  mos_getkbmap:		EQU	1Eh
040000             0077*  
040000             0078*  ; MOS program exit codes
040000             0079*  ;
040000             0080*  EXIT_OK:				EQU  0;	"OK",
040000             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040000             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040000             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040000             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040000             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040000             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040000             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040000             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040000             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040000             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040000             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040000             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040000             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040000             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040000             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040000             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040000             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040000             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040000             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040000             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040000             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040000             0102*  ; FatFS file access functions
040000             0103*  ;
040000             0104*  ffs_fopen:			EQU	80h
040000             0105*  ffs_fclose:			EQU	81h
040000             0106*  ffs_fread:			EQU	82h
040000             0107*  ffs_fwrite:			EQU	83h
040000             0108*  ffs_flseek:			EQU	84h
040000             0109*  ffs_ftruncate:		EQU	85h
040000             0110*  ffs_fsync:			EQU	86h
040000             0111*  ffs_fforward:		EQU	87h
040000             0112*  ffs_fexpand:		EQU	88h
040000             0113*  ffs_fgets:			EQU	89h
040000             0114*  ffs_fputc:			EQU	8Ah
040000             0115*  ffs_fputs:			EQU	8Bh
040000             0116*  ffs_fprintf:		EQU	8Ch
040000             0117*  ffs_ftell:			EQU	8Dh
040000             0118*  ffs_feof:			EQU	8Eh
040000             0119*  ffs_fsize:			EQU	8Fh
040000             0120*  ffs_ferror:			EQU	90h
040000             0121*  
040000             0122*  ; FatFS directory access functions
040000             0123*  ;
040000             0124*  ffs_dopen:			EQU	91h
040000             0125*  ffs_dclose:			EQU	92h
040000             0126*  ffs_dread:			EQU	93h
040000             0127*  ffs_dfindfirst:		EQU	94h
040000             0128*  ffs_dfindnext:		EQU	95h
040000             0129*  
040000             0130*  ; FatFS file and directory management functions
040000             0131*  ;
040000             0132*  ffs_stat:			EQU	96h
040000             0133*  ffs_unlink:			EQU	97h
040000             0134*  ffs_rename:			EQU	98h
040000             0135*  ffs_chmod:			EQU	99h
040000             0136*  ffs_utime:			EQU	9Ah
040000             0137*  ffs_mkdir:			EQU	9Bh
040000             0138*  ffs_chdir:			EQU	9Ch
040000             0139*  ffs_chdrive:		EQU	9Dh
040000             0140*  ffs_getcwd:			EQU	9Eh
040000             0141*  
040000             0142*  ; FatFS volume management and system configuration functions
040000             0143*  ;
040000             0144*  ffs_mount:			EQU	9Fh
040000             0145*  ffs_mkfs:			EQU	A0h
040000             0146*  ffs_fdisk:			EQU	A1h
040000             0147*  ffs_getfree:		EQU	A2h
040000             0148*  ffs_getlabel:		EQU	A3h
040000             0149*  ffs_setlabel:		EQU	A4h
040000             0150*  ffs_setcp:			EQU	A5h
040000             0151*  
040000             0152*  ; File access modes
040000             0153*  ;
040000             0154*  fa_read:			EQU	01h
040000             0155*  fa_write:			EQU	02h
040000             0156*  fa_open_existing:	EQU	00h
040000             0157*  fa_create_new:		EQU	04h
040000             0158*  fa_create_always:	EQU	08h
040000             0159*  fa_open_always:		EQU	10h
040000             0160*  fa_open_append:		EQU	30h
040000             0161*  
040000             0162*  ; System variable indexes for api_sysvars
040000             0163*  ; Index into _sysvars in globals.asm
040000             0164*  ;
040000             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040000             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040000             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040000             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040000             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040000             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040000             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040000             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040000             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040000             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040000             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040000             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040000             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040000             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040000             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040000             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040000             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
040000             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0191*  
040000             0192*  ; Flags for the VPD protocol
040000             0193*  ;
040000             0194*  vdp_pflag_cursor:		EQU	00000001b
040000             0195*  vdp_pflag_scrchar:		EQU	00000010b
040000             0196*  vdp_pflag_point:		EQU	00000100b
040000             0197*  vdp_pflag_audio:		EQU	00001000b
040000             0198*  vdp_pflag_mode:			EQU	00010000b
040000             0199*  vdp_pflag_rtc:			EQU	00100000b
040000             0200*  
040000             0201*  ;
040000             0202*  ; FatFS structures
040000             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0204*  ;
040000             0205*  ; Object ID and allocation information (FFOBJID)
040000             0206*  ;
040000             0207*  ; Indexes into FFOBJID structure
040000             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040000             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040000             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
040000             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040000             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040000             0214*  ;
040000             0215*  ; File object structure (FIL)
040000             0216*  ;
040000             0217*  ; Indexes into FIL structure
040000             0218*  fil_obj:		EQU 0	; 15: Object identifier
040000             0219*  fil_flag:		EQU	15 	;  1: File status flags
040000             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
040000             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040000             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040000             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040000             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040000             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040000             0226*  ;
040000             0227*  ; Directory object structure (DIR)
040000             0228*  ; Indexes into DIR structure
040000             0229*  dir_obj:		EQU  0	; 15: Object identifier
040000             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
040000             0231*  dir_clust:		EQU	19	;  4: Current cluster
040000             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040000             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040000             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040000             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0236*  ;
040000             0237*  ; File information structure (FILINFO)
040000             0238*  ;
040000             0239*  ; Indexes into FILINFO structure
040000             0240*  filinfo_fsize:		EQU 0	;   4: File size
040000             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
040000             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
040000             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
040000             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
040000             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
040000             0246*  ;
040000             0247*  ; Macro for calling the API
040000             0248*  ; Parameters:
040000             0249*  ; - function: One of the function numbers listed above
040000             0250*  ;
040000             0251*  	MACRO	MOSCALL	function
040000             0252*  			LD	A, function
040000             0253*  			RST.LIL	08h
040000             0254*  	ENDMACRO
040000             0002   
040000             0003       .assume adl=1
040000             0004       .org 0x040000
040000             0005   
040000 C3 45 00 04 0006       jp start
040004             0007   
040004 FF FF FF FF 0008       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0009       .db "MOS"
040043 00          0010       .db 00h
040044 01          0011       .db 01h
040045             0012   
040045             0013   start:
040045 F5          0014       push af
040046 C5          0015       push bc
040047 D5          0016       push de
040048 DD E5       0017       push ix
04004A FD E5       0018       push iy
04004C             0019   
04004C CD 79 00 04 0020       call main
040050             0021   
040050             0022   exit:
040050 FD E1       0023       pop iy
040052 DD E1       0024       pop ix
040054 D1          0025       pop de
040055 C1          0026       pop bc
040056 F1          0027       pop af
040057 21 00 00 00 0028       ld hl,0
04005B             0029   
04005B C9          0030       ret
04005C             0031   
04005C 70 69 6E 67 0032   image_filename: db "pingo/src/blender/Lara.rgba8",0
       6F 2F 73 72 
       63 2F 62 6C 
       65 6E 64 65 
       72 2F 4C 61 
       72 61 2E 72 
       67 62 61 38 
       00          
040079             0033   image_buffer: equ 256
040079             0034   image_width: equ 256
040079             0035   image_height: equ 184
040079             0036   image_size: equ image_width*image_height*4
040079             0037   
040079             0038   main:
040079 3E 08       0039       ld a,8 ; 320x240x64 single-buffered
04007B CD 88 03 04 0040       call vdu_set_screen_mode
04007F             0041   
04007F             0042   ; load image file to a buffer and make it a bitmap
04007F AF          0043       xor a ; rgba8
040080 01 00 01 00 0044       ld bc,image_width
040084 11 B8 00 00 0045       ld de,image_height
040088 21 00 01 00 0046       ld hl,image_buffer
04008C DD 21 00 E0 0047       ld ix,image_size
       02          
040091 FD 21 5C 00 0048       ld iy,image_filename
       04          
040096             0049   
040096             0050       ; call dumpRegistersHex
040096             0051       ; ret
040096             0052   
040096 CD AF 00 04 0053       call vdu_load_img
04009A             0054   
04009A             0055   ; plot the bitmap
04009A 21 00 01 00 0056       ld hl,image_buffer
04009E CD 9E 03 04 0057       call vdu_buff_select
0400A2 01 00 00 00 0058       ld bc,0
0400A6 11 00 00 00 0059       ld de,0
0400AA CD D4 03 04 0060       call vdu_plot_bmp
0400AE             0061   
0400AE C9          0062       ret
0400AF             0063   
0400AF             0064   ; load an image file to a buffer and make it a bitmap
0400AF             0065   ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0400AF             0066   vdu_load_img:
0400AF             0067   ; back up image type and dimension parameters
0400AF F5          0068       push af
0400B0 C5          0069   	push bc
0400B1 D5          0070   	push de
0400B2             0071   ; load the image
0400B2 CD BD 00 04 0072   	call vdu_load_buffer_from_file
0400B6             0073   ; now make it a bitmap
0400B6 D1          0074   	pop de ; image height
0400B7 C1          0075   	pop bc ; image width
0400B8 F1          0076   	pop af ; image type
0400B9 C3 B3 03 04 0077   	jp vdu_bmp_create ; will return to caller from there
0400BD             0078   
0400BD             0079   ; inputs: hl = bufferId, ix = file size ; iy = pointer to filename
0400BD             0080   vdu_load_buffer_from_file:
0400BD             0081   ; load buffer ids
0400BD 22 FB 00 04 0082       ld (@id0),hl
0400C1 22 4B 01 04 0083       ld (@id1),hl
0400C5             0084   ; clean up bytes that got stomped on by the ID loads
0400C5 3E 02       0085       ld a,2
0400C7 32 FD 00 04 0086       ld (@id0+2),a
0400CB AF          0087       xor a
0400CC 32 4D 01 04 0088       ld (@id1+2),a
0400D0             0089   ; load filesize from ix
0400D0 DD 22 5B 01 0090       ld (@filesize),ix
       04          
0400D5 ED 4B 5B 01 0091       ld bc,(@filesize) ; for the mos_load call
       04          
0400DA DD 2A 5C 01 0092       ld ix,(@filesize+1) ; now ix is filesize / 256 and will be our main loop counter
       04          
0400DF             0093   
0400DF             0094       ; call dumpRegistersHex
0400DF             0095       ; ret
0400DF             0096   
0400DF             0097   ; load the file from disk into ram
0400DF FD E5       0098       push iy
0400E1 E1          0099   	pop hl ; pointer to filename
0400E2 11 F0 03 04 0100   	ld de,filedata
0400E6 3E 01       0101   	ld a,mos_load
0400E8 5B CF       0102   	RST.LIL 08h
0400EA             0103   ; clear target buffer
0400EA 21 F8 00 04 0104       ld hl,@clear0
0400EE 01 06 00 00 0105       ld bc,@clear1-@clear0
0400F2 5B DF       0106       rst.lil $18
0400F4 C3 FE 00 04 0107       jp @clear1
0400F8 17 00 A0    0108   @clear0: db 23,0,0xA0
0400FB 00 00       0109   @id0:	dw 0x0000 ; bufferId
0400FD 02          0110   		db 2 ; clear buffer
0400FE             0111   @clear1:
0400FE             0112   
0400FE             0113   ; load default chunk size
0400FE 01 00 01 00 0114       ld bc,256
040102 ED 43 4E 01 0115       ld (@chunksize),bc
       04          
040107             0116   ; point hl at the start of the file data
040107 21 F0 03 04 0117       ld hl,filedata
04010B             0118   
04010B             0119       ; call dumpRegistersHex
04010B             0120   
04010B             0121   @loop:
04010B DD 2B       0122       dec ix
04010D             0123   
04010D CD 9A 02 04 0124       call dumpRegistersHex
040111 CD 49 02 04 0125       call dumpFlags
040115             0126   
040115 FA 2A 01 04 0127       jp m,@lastchunk
040119 CA 2A 01 04 0128       jp z,@lastchunk
04011D E5          0129       push hl ; store pointer to file data
04011E             0130   
04011E CD 9A 02 04 0131       call dumpRegistersHex
040122             0132   
040122 CD 3A 01 04 0133       call @loadchunk ; load the next chunk
040126             0134       ; ld a,'.'
040126             0135       ; rst.lil 10h
040126 C3 0B 01 04 0136       jp @loop ; loop back to load the next chunk
04012A             0137   
04012A             0138   @lastchunk:
04012A 01 00 00 00 0139       ld bc,0 ; make sure bcu is zero
04012E DD 7E 00    0140       ld a,(ix) ; get the remaining bytes
040131 A7          0141       and a
040132 C8          0142       ret z ; no more to load so we're done
040133 4F          0143       ld c,a ; bc is number of final bytes to load
040134 ED 43 4E 01 0144       ld (@chunksize),bc
       04          
040139 E5          0145       push hl ; store pointer to file data
04013A             0146       ; fall through to loadchunk
04013A             0147   
04013A             0148   @loadchunk:
04013A 21 48 01 04 0149       ld hl,@chunk0
04013E 01 08 00 00 0150       ld bc,@chunk1-@chunk0
040142 5B DF       0151       rst.lil $18
040144 C3 50 01 04 0152       jp @chunk1
040148             0153   @chunk0:
040148             0154   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040148 17 00 A0    0155   		db 23,0,0xA0
04014B 00 00       0156   @id1:	dw 0x0000 ; bufferId
04014D 00          0157   		db 0 ; load buffer
04014E 00 00       0158   @chunksize:	dw 0x0000 ; length of data in bytes
040150             0159   @chunk1:
040150 E1          0160       pop hl ; get the file data pointer
040151 ED 4B 4E 01 0161       ld bc,(@chunksize)
       04          
040156 5B DF       0162       rst.lil $18
040158 09          0163       add hl,bc ; advance the file data pointer
040159 C9          0164       ret
04015A 00          0165               db 0x00 ; padding
04015B 00 00 00    0166   @filesize: dl 0 ; file size in bytes
04015E 00          0167               db 0x00 ; padding
04015F             0168   
04015F             0169   
04015F             0170   
04015F             0171   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
04015F             0172   ; Print a zero-terminated string
04015F             0173   ; HL: Pointer to string
04015F             0174   printString:
04015F C5          0175   	PUSH	BC
040160 01 00 00 00 0176   	LD		BC,0
040164 3E 00       0177   	LD 	 	A,0
040166 5B DF       0178   	RST.LIL 18h
040168 C1          0179   	POP		BC
040169 C9          0180   	RET
04016A             0181   ; print a VDU sequence
04016A             0182   ; HL: Pointer to VDU sequence - <1 byte length> <data>
04016A             0183   sendVDUsequence:
04016A C5          0184   	PUSH	BC
04016B 01 00 00 00 0185   	LD		BC, 0
04016F 4E          0186   	LD		C, (HL)
040170 5B DF       0187   	RST.LIL	18h
040172 C1          0188   	POP		BC
040173 C9          0189   	RET
040174             0190   ; Print Newline sequence to VDP
040174             0191   printNewLine:
040174 3E 0D       0192   	LD	A, '\r'
040176 5B D7       0193   	RST.LIL 10h
040178 3E 0A       0194   	LD	A, '\n'
04017A 5B D7       0195   	RST.LIL 10h
04017C C9          0196   	RET
04017D             0197   ; Print a 24-bit HEX number
04017D             0198   ; HLU: Number to print
04017D             0199   printHex24:
04017D E5          0200   	PUSH	HL
04017E 21 02 00 00 0201   	LD		HL, 2
040182 39          0202   	ADD		HL, SP
040183 7E          0203   	LD		A, (HL)
040184 E1          0204   	POP		HL
040185 CD 8F 01 04 0205   	CALL	printHex8
040189             0206   ; Print a 16-bit HEX number
040189             0207   ; HL: Number to print
040189             0208   printHex16:
040189 7C          0209   	LD		A,H
04018A CD 8F 01 04 0210   	CALL	printHex8
04018E 7D          0211   	LD		A,L
04018F             0212   ; Print an 8-bit HEX number
04018F             0213   ; A: Number to print
04018F             0214   printHex8:
04018F 4F          0215   	LD		C,A
040190 1F          0216   	RRA
040191 1F          0217   	RRA
040192 1F          0218   	RRA
040193 1F          0219   	RRA
040194 CD 99 01 04 0220   	CALL	@F
040198 79          0221   	LD		A,C
040199             0222   @@:
040199 E6 0F       0223   	AND		0Fh
04019B C6 90       0224   	ADD		A,90h
04019D 27          0225   	DAA
04019E CE 40       0226   	ADC		A,40h
0401A0 27          0227   	DAA
0401A1 5B D7       0228   	RST.LIL	10h
0401A3 C9          0229   	RET
0401A4             0230   
0401A4             0231   
0401A4             0232   ; print the binary representation of the 8-bit value in a
0401A4             0233   ; destroys a, hl, bc
0401A4             0234   printBin8:
0401A4 06 08       0235       ld b,8      ; loop counter for 8 bits
0401A6 21 C1 01 04 0236       ld hl,@cmd  ; set hl to the low byte of the output string
0401AA             0237                   ; (which will be the high bit of the value in a)
0401AA             0238   @loop:
0401AA 07          0239       rlca ; put the next highest bit into carry
0401AB 38 04       0240       jr c,@one
0401AD 36 30       0241       ld (hl),'0'
0401AF 18 02       0242       jr @next_bit
0401B1             0243   @one:
0401B1 36 31       0244       ld (hl),'1'
0401B3             0245   @next_bit:
0401B3 23          0246       inc hl
0401B4 10 F4       0247       djnz @loop
0401B6             0248   ; print it
0401B6 21 C1 01 04 0249   	ld hl,@cmd
0401BA 01 08 00 00 0250   	ld bc,@end-@cmd
0401BE 5B DF       0251   	rst.lil $18
0401C0 C9          0252   	ret
0401C1             0253   @cmd: ds 8 ; eight bytes for eight bits
0401C9             0254   @end:
0401C9             0255   
0401C9             0256   ; Print a 0x HEX prefix
0401C9             0257   DisplayHexPrefix:
0401C9 3E 30       0258   	LD	A, '0'
0401CB 5B D7       0259   	RST.LIL 10h
0401CD 3E 78       0260   	LD	A, 'x'
0401CF 5B D7       0261   	RST.LIL 10h
0401D1 C9          0262   	RET
0401D2             0263   ; Prints the right justified decimal value in HL without leading zeroes
0401D2             0264   ; HL : Value to print
0401D2             0265   printDec:
0401D2 11 FE 01 04 0266   	LD	 DE, _printDecBuffer
0401D6 CD 07 02 04 0267   	CALL Num2String
0401DA             0268   ; BEGIN MY CODE
0401DA             0269   ; replace leading zeroes with spaces
0401DA 21 FE 01 04 0270       LD	 HL, _printDecBuffer
0401DE 06 07       0271       ld   B, 7 ; if HL was 0, we want to keep the final zero
0401E0             0272   @loop:
0401E0 7E          0273       LD	 A, (HL)
0401E1 FE 30       0274       CP	 '0'
0401E3 C2 F1 01 04 0275       JP	 NZ, @done
0401E7 3E 20       0276       LD   A, ' '
0401E9 77          0277       LD	 (HL), A
0401EA 23          0278       INC	 HL
0401EB CD 99 03 04 0279       CALL vdu_cursor_forward
0401EF 10 EF       0280       DJNZ @loop
0401F1             0281   @done:
0401F1             0282   ; END MY CODE
0401F1             0283   	; LD	 HL, _printDecBuffer
0401F1 CD 5F 01 04 0284   	CALL printString
0401F5             0285   ; Print Newline sequence to VDP
0401F5 3E 0D       0286   	LD	A, '\r'
0401F7 5B D7       0287   	RST.LIL 10h
0401F9 3E 0A       0288   	LD	A, '\n'
0401FB 5B D7       0289   	RST.LIL 10h
0401FD C9          0290   	RET
0401FE 00 00 00 00 0291   _printDecBuffer: blkb 9,0 ; nine bytes full of zeroes
       00 00 00 00 
       00          
040207             0292   
040207             0293   ; This routine converts the value from HL into its ASCII representation,
040207             0294   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040207             0295   ; so it will allways be 8 characters length
040207             0296   ; HL : Value to convert to string
040207             0297   ; DE : pointer to buffer, at least 8 byte + 0
040207             0298   Num2String:
040207 01 80 69 67 0299   	LD	 BC,-10000000
04020B CD 3E 02 04 0300   	CALL OneDigit
04020F 01 C0 BD F0 0301   	LD	 BC,-1000000
040213 CD 3E 02 04 0302   	CALL OneDigit
040217 01 60 79 FE 0303   	LD	 BC,-100000
04021B CD 3E 02 04 0304   	CALL OneDigit
04021F 01 F0 D8 FF 0305   	LD   BC,-10000
040223 CD 3E 02 04 0306   	CALL OneDigit
040227 01 18 FC FF 0307   	LD   BC,-1000
04022B CD 3E 02 04 0308   	CALL OneDigit
04022F 01 9C FF FF 0309   	LD   BC,-100
040233 CD 3E 02 04 0310   	CALL OneDigit
040237 0E F6       0311   	LD   C,-10
040239 CD 3E 02 04 0312   	CALL OneDigit
04023D 48          0313   	LD   C,B
04023E             0314   OneDigit:
04023E 3E 2F       0315   	LD   A,'0'-1
040240             0316   DivideMe:
040240 3C          0317   	INC  A
040241 09          0318   	ADD  HL,BC
040242 38 FC       0319   	JR   C,DivideMe
040244 ED 42       0320   	SBC  HL,BC
040246 12          0321   	LD   (DE),A
040247 13          0322   	INC  DE
040248 C9          0323   	RET
040249             0324   
040249             0325   
040249             0326   ; inputs: whatever is in the flags register
040249             0327   ; outputs: binary representation of flags
040249             0328   ;          with a header so we know which is what
040249             0329   ; destroys: nothing
040249             0330   ; preserves: everything
040249             0331   dumpFlags:
040249             0332   ; first we curse zilog for not giving direct access to flags
040249 F5          0333       push af ; this is so we can send it back unharmed
04024A F5          0334       push af ; this is so we can pop it to hl
04024B             0335   ; store everything in scratch
04024B 22 56 03 04 0336       ld (uhl),hl
04024F ED 43 59 03 0337       ld (ubc),bc
       04          
040254 ED 53 5C 03 0338       ld (ude),de
       04          
040259 DD 22 5F 03 0339       ld (uix),ix
       04          
04025E FD 22 62 03 0340       ld (uiy),iy
       04          
040263             0341   ; next we print the header
040263 21 8F 02 04 0342       ld hl,@header
040267 CD 5F 01 04 0343       call printString
04026B E1          0344       pop hl ; flags are now in l
04026C 7D          0345       ld a,l ; flags are now in a
04026D CD A4 01 04 0346       call printBin8
040271 CD 74 01 04 0347   	call printNewLine
040275             0348   ; restore everything
040275 2A 56 03 04 0349       ld hl, (uhl)
040279 ED 4B 59 03 0350       ld bc, (ubc)
       04          
04027E ED 5B 5C 03 0351       ld de, (ude)
       04          
040283 DD 2A 5F 03 0352       ld ix, (uix)
       04          
040288 FD 2A 62 03 0353       ld iy, (uiy)
       04          
04028D F1          0354       pop af ; send her home the way she came
04028E C9          0355       ret
04028F             0356   ; Bit 7 (S): Sign flag
04028F             0357   ; Bit 6 (Z): Zero flag
04028F             0358   ; Bit 5 (5): Reserved (copy of bit 5 of the result)
04028F             0359   ; Bit 4 (H): Half Carry flag
04028F             0360   ; Bit 3 (3): Reserved (copy of bit 3 of the result)
04028F             0361   ; Bit 2 (PV): Parity/Overflow flag
04028F             0362   ; Bit 1 (N): Subtract flag
04028F             0363   ; Bit 0 (C): Carry flag
04028F 53 5A 78 48 0364   @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
04029A             0365   
04029A             0366   
04029A             0367   ; print registers to screen in hexidecimal format
04029A             0368   ; inputs: none
04029A             0369   ; outputs: values of every register printed to screen
04029A             0370   ;    values of each register in global scratch memory
04029A             0371   ; destroys: nothing
04029A             0372   dumpRegistersHex:
04029A             0373   ; store everything in scratch
04029A 22 56 03 04 0374       ld (uhl),hl
04029E ED 43 59 03 0375       ld (ubc),bc
       04          
0402A3 ED 53 5C 03 0376       ld (ude),de
       04          
0402A8 DD 22 5F 03 0377       ld (uix),ix
       04          
0402AD FD 22 62 03 0378       ld (uiy),iy
       04          
0402B2 F5          0379       push af ; fml
0402B3 E1          0380       pop hl  ; thanks, zilog
0402B4 22 53 03 04 0381       ld (uaf),hl
0402B8 F5          0382       push af ; dammit
0402B9             0383   
0402B9             0384   ; home the cursor
0402B9 CD 83 03 04 0385       call vdu_home_cursor
0402BD             0386   
0402BD             0387   ; print each register
0402BD 21 6B 03 04 0388       ld hl,str_afu
0402C1 CD 5F 01 04 0389       call printString
0402C5 2A 53 03 04 0390       ld hl,(uaf)
0402C9 CD 7D 01 04 0391       call printHex24
0402CD CD 74 01 04 0392       call printNewLine
0402D1             0393   
0402D1 21 6F 03 04 0394       ld hl,str_hlu
0402D5 CD 5F 01 04 0395       call printString
0402D9 2A 56 03 04 0396       ld hl,(uhl)
0402DD CD 7D 01 04 0397       call printHex24
0402E1 CD 74 01 04 0398       call printNewLine
0402E5             0399   
0402E5 21 73 03 04 0400       ld hl,str_bcu
0402E9 CD 5F 01 04 0401       call printString
0402ED 2A 59 03 04 0402       ld hl,(ubc)
0402F1 CD 7D 01 04 0403       call printHex24
0402F5 CD 74 01 04 0404       call printNewLine
0402F9             0405   
0402F9 21 77 03 04 0406       ld hl,str_deu
0402FD CD 5F 01 04 0407       call printString
040301 2A 5C 03 04 0408       ld hl,(ude)
040305 CD 7D 01 04 0409       call printHex24
040309 CD 74 01 04 0410       call printNewLine
04030D             0411   
04030D 21 7B 03 04 0412       ld hl,str_ixu
040311 CD 5F 01 04 0413       call printString
040315 2A 5F 03 04 0414       ld hl,(uix)
040319 CD 7D 01 04 0415       call printHex24
04031D CD 74 01 04 0416       call printNewLine
040321             0417   
040321 21 7F 03 04 0418       ld hl,str_iyu
040325 CD 5F 01 04 0419       call printString
040329 2A 62 03 04 0420       ld hl,(uiy)
04032D CD 7D 01 04 0421       call printHex24
040331 CD 74 01 04 0422       call printNewLine
040335             0423   
040335 CD 74 01 04 0424       call printNewLine
040339             0425   ; restore everything
040339 2A 56 03 04 0426       ld hl, (uhl)
04033D ED 4B 59 03 0427       ld bc, (ubc)
       04          
040342 ED 5B 5C 03 0428       ld de, (ude)
       04          
040347 DD 2A 5F 03 0429       ld ix, (uix)
       04          
04034C FD 2A 62 03 0430       ld iy, (uiy)
       04          
040351 F1          0431       pop af
040352             0432   ; all done
040352 C9          0433       ret
040353             0434   
040353             0435   ; global scratch memory for registers
040353 00 00 00    0436   uaf: dl 0
040356 00 00 00    0437   uhl: dl 0
040359 00 00 00    0438   ubc: dl 0
04035C 00 00 00    0439   ude: dl 0
04035F 00 00 00    0440   uix: dl 0
040362 00 00 00    0441   uiy: dl 0
040365 00 00 00    0442   usp: dl 0
040368 00 00 00    0443   upc: dl 0
04036B             0444   
04036B 61 66 3D 00 0445   str_afu: db "af=",0
04036F 68 6C 3D 00 0446   str_hlu: db "hl=",0
040373 62 63 3D 00 0447   str_bcu: db "bc=",0
040377 64 65 3D 00 0448   str_deu: db "de=",0
04037B 69 78 3D 00 0449   str_ixu: db "ix=",0
04037F 69 79 3D 00 0450   str_iyu: db "iy=",0
040383             0451   
040383             0452   ; VDU 30: Home cursor
040383             0453   vdu_home_cursor:
040383 3E 1E       0454       ld a,30
040385 5B D7       0455   	rst.lil $10
040387 C9          0456   	ret
040388             0457   
040388             0458   vdu_set_screen_mode:
040388 32 98 03 04 0459   	ld (@arg),a
04038C 21 97 03 04 0460   	ld hl,@cmd
040390 01 02 00 00 0461   	ld bc,@end-@cmd
040394 5B DF       0462   	rst.lil $18
040396 C9          0463   	ret
040397 16          0464   @cmd: db 22 ; set screen mode
040398 00          0465   @arg: db 0  ; screen mode parameter
040399             0466   @end:
040399             0467   
040399             0468   ; VDU 9: Move cursor forward one character
040399             0469   vdu_cursor_forward:
040399 3E 09       0470       ld a,9
04039B 5B D7       0471   	rst.lil $10
04039D C9          0472   	ret
04039E             0473   
04039E             0474   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
04039E             0475   ; inputs: hl=bufferId
04039E             0476   vdu_buff_select:
04039E 22 B0 03 04 0477   	ld (@bufferId),hl
0403A2 21 AD 03 04 0478   	ld hl,@cmd
0403A6 01 05 00 00 0479   	ld bc,@end-@cmd
0403AA 5B DF       0480   	rst.lil $18
0403AC C9          0481   	ret
0403AD 17 1B 20    0482   @cmd: db 23,27,0x20
0403B0 00 00       0483   @bufferId: dw 0x0000
0403B2 00          0484   @end: db 0x00 ; padding
0403B3             0485   
0403B3             0486   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0403B3             0487   ; inputs: a=format; bc=width; de=height
0403B3             0488   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0403B3             0489   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0403B3             0490   ; 0 	RGBA8888 (4-bytes per pixel)
0403B3             0491   ; 1 	RGBA2222 (1-bytes per pixel)
0403B3             0492   ; 2 	Mono/Mask (1-bit per pixel)
0403B3             0493   ; 3 	Reserved for internal use by VDP (“native” format)
0403B3             0494   vdu_bmp_create:
0403B3 ED 43 CF 03 0495       ld (@width),bc
       04          
0403B8 ED 53 D1 03 0496       ld (@height),de
       04          
0403BD 32 D3 03 04 0497       ld (@fmt),a
0403C1 21 CC 03 04 0498   	ld hl,@cmd
0403C5 01 08 00 00 0499   	ld bc,@end-@cmd
0403C9 5B DF       0500   	rst.lil $18
0403CB C9          0501   	ret
0403CC 17 1B 21    0502   @cmd:       db 23,27,0x21
0403CF 00 00       0503   @width:     dw 0x0000
0403D1 00 00       0504   @height:    dw 0x0000
0403D3 00          0505   @fmt:       db 0x00
0403D4             0506   @end:
0403D4             0507   
0403D4             0508   ; &E8-&EF 	232-239 	Bitmap plot §
0403D4             0509   plot_bmp: equ 0xE8
0403D4             0510   ; 5 	Plot absolute in current foreground colour
0403D4             0511   dr_abs_fg: equ 5
0403D4             0512   
0403D4             0513   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0403D4             0514   ; &E8-&EF 	232-239 	Bitmap plot §
0403D4             0515   ; VDU 25, mode, x; y;: PLOT command
0403D4             0516   ; inputs: bc=x0, de=y0
0403D4             0517   ; prerequisites: vdu_buff_select
0403D4             0518   vdu_plot_bmp:
0403D4 ED 43 EB 03 0519       ld (@x0),bc
       04          
0403D9 ED 53 ED 03 0520       ld (@y0),de
       04          
0403DE 21 E9 03 04 0521   	ld hl,@cmd
0403E2 01 06 00 00 0522   	ld bc,@end-@cmd
0403E6 5B DF       0523   	rst.lil $18
0403E8 C9          0524   	ret
0403E9 19          0525   @cmd:   db 25
0403EA ED          0526   @mode:  db plot_bmp+dr_abs_fg ; 0xED
0403EB 00 00       0527   @x0: 	dw 0x0000
0403ED 00 00       0528   @y0: 	dw 0x0000
0403EF 00          0529   @end:   db 0x00 ; padding
0403F0             0530   
0403F0             0531   filedata: ; no need to allocate space here if this is the final address label
